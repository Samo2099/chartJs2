<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>TestChart2</title>
  <base href="/chartJs2/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="stylesheet" href="styles.ef46db3751d8e999.css">
</head>

<body>
  <app-root></app-root>
  <script src="runtime.a7fadb62ddb59a90.js" type="module"></script>
  <script src="polyfills.95ae65d19a2776ee.js" type="module"></script>
  <script src="scripts.b9f8f9e25d562174.js" defer></script>
  <script src="main.9ab142b1038fd8d3.js" type="module"></script>


  <script>
    (() => { "use strict"; var e, _ = {}, h = {}; function n(e) { var a = h[e]; if (void 0 !== a) return a.exports; var r = h[e] = { exports: {} }; return _[e](r, r.exports, n), r.exports } n.m = _, e = [], n.O = (a, r, u, f) => { if (!r) { var c = 1 / 0; for (t = 0; t < e.length; t++) { for (var [r, u, f] = e[t], o = !0, l = 0; l < r.length; l++)(!1 & f || c >= f) && Object.keys(n.O).every(i => n.O[i](r[l])) ? r.splice(l--, 1) : (o = !1, f < c && (c = f)); if (o) { e.splice(t--, 1); var s = u(); void 0 !== s && (a = s) } } return a } f = f || 0; for (var t = e.length; t > 0 && e[t - 1][2] > f; t--)e[t] = e[t - 1]; e[t] = [r, u, f] }, n.n = e => { var a = e && e.__esModule ? () => e.default : () => e; return n.d(a, { a }), a }, n.d = (e, a) => { for (var r in a) n.o(a, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: a[r] }) }, n.o = (e, a) => Object.prototype.hasOwnProperty.call(e, a), (() => { var e = { 666: 0 }; n.O.j = u => 0 === e[u]; var a = (u, f) => { var l, s, [t, c, o] = f, v = 0; if (t.some(d => 0 !== e[d])) { for (l in c) n.o(c, l) && (n.m[l] = c[l]); if (o) var b = o(n) } for (u && u(f); v < t.length; v++)n.o(e, s = t[v]) && e[s] && e[s][0](), e[s] = 0; return n.O(b) }, r = self.webpackChunktestChart2 = self.webpackChunktestChart2 || []; r.forEach(a.bind(null, 0)), r.push = a.bind(null, r.push.bind(r)) })() })();
  </script>
  <script>
    "use strict"; (self.webpackChunktestChart2 = self.webpackChunktestChart2 || []).push([[429], { 443: (ie, Ee, de) => { de(583) }, 583: () => { !function (e) { const n = e.performance; function i(M) { n && n.mark && n.mark(M) } function o(M, E) { n && n.measure && n.measure(M, E) } i("Zone"); const c = e.__Zone_symbol_prefix || "__zone_symbol__"; function a(M) { return c + M } const y = !0 === e[a("forceDuplicateZoneCheck")]; if (e.Zone) { if (y || "function" != typeof e.Zone.__symbol__) throw new Error("Zone already loaded."); return e.Zone } let d = (() => { class M { constructor(t, r) { this._parent = t, this._name = r ? r.name || "unnamed" : "<root>", this._properties = r && r.properties || {}, this._zoneDelegate = new v(this, this._parent && this._parent._zoneDelegate, r) } static assertZonePatched() { if (e.Promise !== oe.ZoneAwarePromise) throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)") } static get root() { let t = M.current; for (; t.parent;)t = t.parent; return t } static get current() { return U.zone } static get currentTask() { return re } static __load_patch(t, r, k = !1) { if (oe.hasOwnProperty(t)) { if (!k && y) throw Error("Already loaded patch: " + t) } else if (!e["__Zone_disable_" + t]) { const C = "Zone:" + t; i(C), oe[t] = r(e, M, z), o(C, C) } } get parent() { return this._parent } get name() { return this._name } get(t) { const r = this.getZoneWith(t); if (r) return r._properties[t] } getZoneWith(t) { let r = this; for (; r;) { if (r._properties.hasOwnProperty(t)) return r; r = r._parent } return null } fork(t) { if (!t) throw new Error("ZoneSpec required!"); return this._zoneDelegate.fork(this, t) } wrap(t, r) { if ("function" != typeof t) throw new Error("Expecting function got: " + t); const k = this._zoneDelegate.intercept(this, t, r), C = this; return function () { return C.runGuarded(k, this, arguments, r) } } run(t, r, k, C) { U = { parent: U, zone: this }; try { return this._zoneDelegate.invoke(this, t, r, k, C) } finally { U = U.parent } } runGuarded(t, r = null, k, C) { U = { parent: U, zone: this }; try { try { return this._zoneDelegate.invoke(this, t, r, k, C) } catch ($) { if (this._zoneDelegate.handleError(this, $)) throw $ } } finally { U = U.parent } } runTask(t, r, k) { if (t.zone != this) throw new Error("A task can only be run in the zone of creation! (Creation: " + (t.zone || K).name + "; Execution: " + this.name + ")"); if (t.state === x && (t.type === Q || t.type === w)) return; const C = t.state != p; C && t._transitionTo(p, j), t.runCount++; const $ = re; re = t, U = { parent: U, zone: this }; try { t.type == w && t.data && !t.data.isPeriodic && (t.cancelFn = void 0); try { return this._zoneDelegate.invokeTask(this, t, r, k) } catch (l) { if (this._zoneDelegate.handleError(this, l)) throw l } } finally { t.state !== x && t.state !== h && (t.type == Q || t.data && t.data.isPeriodic ? C && t._transitionTo(j, p) : (t.runCount = 0, this._updateTaskCount(t, -1), C && t._transitionTo(x, p, x))), U = U.parent, re = $ } } scheduleTask(t) { if (t.zone && t.zone !== this) { let k = this; for (; k;) { if (k === t.zone) throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${t.zone.name}`); k = k.parent } } t._transitionTo(X, x); const r = []; t._zoneDelegates = r, t._zone = this; try { t = this._zoneDelegate.scheduleTask(this, t) } catch (k) { throw t._transitionTo(h, X, x), this._zoneDelegate.handleError(this, k), k } return t._zoneDelegates === r && this._updateTaskCount(t, 1), t.state == X && t._transitionTo(j, X), t } scheduleMicroTask(t, r, k, C) { return this.scheduleTask(new m(I, t, r, k, C, void 0)) } scheduleMacroTask(t, r, k, C, $) { return this.scheduleTask(new m(w, t, r, k, C, $)) } scheduleEventTask(t, r, k, C, $) { return this.scheduleTask(new m(Q, t, r, k, C, $)) } cancelTask(t) { if (t.zone != this) throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (t.zone || K).name + "; Execution: " + this.name + ")"); t._transitionTo(G, j, p); try { this._zoneDelegate.cancelTask(this, t) } catch (r) { throw t._transitionTo(h, G), this._zoneDelegate.handleError(this, r), r } return this._updateTaskCount(t, -1), t._transitionTo(x, G), t.runCount = 0, t } _updateTaskCount(t, r) { const k = t._zoneDelegates; -1 == r && (t._zoneDelegates = null); for (let C = 0; C < k.length; C++)k[C]._updateTaskCount(t.type, r) } } return M.__symbol__ = a, M })(); const P = { name: "", onHasTask: (M, E, t, r) => M.hasTask(t, r), onScheduleTask: (M, E, t, r) => M.scheduleTask(t, r), onInvokeTask: (M, E, t, r, k, C) => M.invokeTask(t, r, k, C), onCancelTask: (M, E, t, r) => M.cancelTask(t, r) }; class v { constructor(E, t, r) { this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 }, this.zone = E, this._parentDelegate = t, this._forkZS = r && (r && r.onFork ? r : t._forkZS), this._forkDlgt = r && (r.onFork ? t : t._forkDlgt), this._forkCurrZone = r && (r.onFork ? this.zone : t._forkCurrZone), this._interceptZS = r && (r.onIntercept ? r : t._interceptZS), this._interceptDlgt = r && (r.onIntercept ? t : t._interceptDlgt), this._interceptCurrZone = r && (r.onIntercept ? this.zone : t._interceptCurrZone), this._invokeZS = r && (r.onInvoke ? r : t._invokeZS), this._invokeDlgt = r && (r.onInvoke ? t : t._invokeDlgt), this._invokeCurrZone = r && (r.onInvoke ? this.zone : t._invokeCurrZone), this._handleErrorZS = r && (r.onHandleError ? r : t._handleErrorZS), this._handleErrorDlgt = r && (r.onHandleError ? t : t._handleErrorDlgt), this._handleErrorCurrZone = r && (r.onHandleError ? this.zone : t._handleErrorCurrZone), this._scheduleTaskZS = r && (r.onScheduleTask ? r : t._scheduleTaskZS), this._scheduleTaskDlgt = r && (r.onScheduleTask ? t : t._scheduleTaskDlgt), this._scheduleTaskCurrZone = r && (r.onScheduleTask ? this.zone : t._scheduleTaskCurrZone), this._invokeTaskZS = r && (r.onInvokeTask ? r : t._invokeTaskZS), this._invokeTaskDlgt = r && (r.onInvokeTask ? t : t._invokeTaskDlgt), this._invokeTaskCurrZone = r && (r.onInvokeTask ? this.zone : t._invokeTaskCurrZone), this._cancelTaskZS = r && (r.onCancelTask ? r : t._cancelTaskZS), this._cancelTaskDlgt = r && (r.onCancelTask ? t : t._cancelTaskDlgt), this._cancelTaskCurrZone = r && (r.onCancelTask ? this.zone : t._cancelTaskCurrZone), this._hasTaskZS = null, this._hasTaskDlgt = null, this._hasTaskDlgtOwner = null, this._hasTaskCurrZone = null; const k = r && r.onHasTask; (k || t && t._hasTaskZS) && (this._hasTaskZS = k ? r : P, this._hasTaskDlgt = t, this._hasTaskDlgtOwner = this, this._hasTaskCurrZone = E, r.onScheduleTask || (this._scheduleTaskZS = P, this._scheduleTaskDlgt = t, this._scheduleTaskCurrZone = this.zone), r.onInvokeTask || (this._invokeTaskZS = P, this._invokeTaskDlgt = t, this._invokeTaskCurrZone = this.zone), r.onCancelTask || (this._cancelTaskZS = P, this._cancelTaskDlgt = t, this._cancelTaskCurrZone = this.zone)) } fork(E, t) { return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, E, t) : new d(E, t) } intercept(E, t, r) { return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, E, t, r) : t } invoke(E, t, r, k, C) { return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, E, t, r, k, C) : t.apply(r, k) } handleError(E, t) { return !this._handleErrorZS || this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, E, t) } scheduleTask(E, t) { let r = t; if (this._scheduleTaskZS) this._hasTaskZS && r._zoneDelegates.push(this._hasTaskDlgtOwner), r = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, E, t), r || (r = t); else if (t.scheduleFn) t.scheduleFn(t); else { if (t.type != I) throw new Error("Task is missing scheduleFn."); R(t) } return r } invokeTask(E, t, r, k) { return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, E, t, r, k) : t.callback.apply(r, k) } cancelTask(E, t) { let r; if (this._cancelTaskZS) r = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, E, t); else { if (!t.cancelFn) throw Error("Task is not cancelable"); r = t.cancelFn(t) } return r } hasTask(E, t) { try { this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, E, t) } catch (r) { this.handleError(E, r) } } _updateTaskCount(E, t) { const r = this._taskCounts, k = r[E], C = r[E] = k + t; if (C < 0) throw new Error("More tasks executed then were scheduled."); 0 != k && 0 != C || this.hasTask(this.zone, { microTask: r.microTask > 0, macroTask: r.macroTask > 0, eventTask: r.eventTask > 0, change: E }) } } class m { constructor(E, t, r, k, C, $) { if (this._zone = null, this.runCount = 0, this._zoneDelegates = null, this._state = "notScheduled", this.type = E, this.source = t, this.data = k, this.scheduleFn = C, this.cancelFn = $, !r) throw new Error("callback is not defined"); this.callback = r; const l = this; this.invoke = E === Q && k && k.useG ? m.invokeTask : function () { return m.invokeTask.call(e, l, this, arguments) } } static invokeTask(E, t, r) { E || (E = this), ee++; try { return E.runCount++, E.zone.runTask(E, t, r) } finally { 1 == ee && _(), ee-- } } get zone() { return this._zone } get state() { return this._state } cancelScheduleRequest() { this._transitionTo(x, X) } _transitionTo(E, t, r) { if (this._state !== t && this._state !== r) throw new Error(`${this.type} '${this.source}': can not transition to '${E}', expecting state '${t}'${r ? " or '" + r + "'" : ""}, was '${this._state}'.`); this._state = E, E == x && (this._zoneDelegates = null) } toString() { return this.data && void 0 !== this.data.handleId ? this.data.handleId.toString() : Object.prototype.toString.call(this) } toJSON() { return { type: this.type, state: this.state, source: this.source, zone: this.zone.name, runCount: this.runCount } } } const L = a("setTimeout"), Z = a("Promise"), N = a("then"); let J, B = [], H = !1; function q(M) { if (J || e[Z] && (J = e[Z].resolve(0)), J) { let E = J[N]; E || (E = J.then), E.call(J, M) } else e[L](M, 0) } function R(M) { 0 === ee && 0 === B.length && q(_), M && B.push(M) } function _() { if (!H) { for (H = !0; B.length;) { const M = B; B = []; for (let E = 0; E < M.length; E++) { const t = M[E]; try { t.zone.runTask(t, null, null) } catch (r) { z.onUnhandledError(r) } } } z.microtaskDrainDone(), H = !1 } } const K = { name: "NO ZONE" }, x = "notScheduled", X = "scheduling", j = "scheduled", p = "running", G = "canceling", h = "unknown", I = "microTask", w = "macroTask", Q = "eventTask", oe = {}, z = { symbol: a, currentZoneFrame: () => U, onUnhandledError: W, microtaskDrainDone: W, scheduleMicroTask: R, showUncaughtError: () => !d[a("ignoreConsoleErrorUncaughtError")], patchEventTarget: () => [], patchOnProperties: W, patchMethod: () => W, bindArguments: () => [], patchThen: () => W, patchMacroTask: () => W, patchEventPrototype: () => W, isIEOrEdge: () => !1, getGlobalObjects: () => { }, ObjectDefineProperty: () => W, ObjectGetOwnPropertyDescriptor: () => { }, ObjectCreate: () => { }, ArraySlice: () => [], patchClass: () => W, wrapWithCurrentZone: () => W, filterProperties: () => [], attachOriginToPatched: () => W, _redefineProperty: () => W, patchCallbacks: () => W, nativeScheduleMicroTask: q }; let U = { parent: null, zone: new d(null, null) }, re = null, ee = 0; function W() { } o("Zone", "Zone"), e.Zone = d }("undefined" != typeof window && window || "undefined" != typeof self && self || global); const ie = Object.getOwnPropertyDescriptor, Ee = Object.defineProperty, de = Object.getPrototypeOf, ge = Object.create, Ve = Array.prototype.slice, Oe = "addEventListener", Se = "removeEventListener", Ze = Zone.__symbol__(Oe), Ne = Zone.__symbol__(Se), ce = "true", ae = "false", ke = Zone.__symbol__(""); function Ie(e, n) { return Zone.current.wrap(e, n) } function Me(e, n, i, o, c) { return Zone.current.scheduleMacroTask(e, n, i, o, c) } const A = Zone.__symbol__, Pe = "undefined" != typeof window, Te = Pe ? window : void 0, Y = Pe && Te || "object" == typeof self && self || global; function Le(e, n) { for (let i = e.length - 1; i >= 0; i--)"function" == typeof e[i] && (e[i] = Ie(e[i], n + "_" + i)); return e } function Fe(e) { return !e || !1 !== e.writable && !("function" == typeof e.get && void 0 === e.set) } const Be = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope, we = !("nw" in Y) && void 0 !== Y.process && "[object process]" === {}.toString.call(Y.process), je = !we && !Be && !(!Pe || !Te.HTMLElement), Ue = void 0 !== Y.process && "[object process]" === {}.toString.call(Y.process) && !Be && !(!Pe || !Te.HTMLElement), Re = {}, We = function (e) { if (!(e = e || Y.event)) return; let n = Re[e.type]; n || (n = Re[e.type] = A("ON_PROPERTY" + e.type)); const i = this || e.target || Y, o = i[n]; let c; if (je && i === Te && "error" === e.type) { const a = e; c = o && o.call(this, a.message, a.filename, a.lineno, a.colno, a.error), !0 === c && e.preventDefault() } else c = o && o.apply(this, arguments), null != c && !c && e.preventDefault(); return c }; function qe(e, n, i) { let o = ie(e, n); if (!o && i && ie(i, n) && (o = { enumerable: !0, configurable: !0 }), !o || !o.configurable) return; const c = A("on" + n + "patched"); if (e.hasOwnProperty(c) && e[c]) return; delete o.writable, delete o.value; const a = o.get, y = o.set, d = n.slice(2); let P = Re[d]; P || (P = Re[d] = A("ON_PROPERTY" + d)), o.set = function (v) { let m = this; !m && e === Y && (m = Y), m && ("function" == typeof m[P] && m.removeEventListener(d, We), y && y.call(m, null), m[P] = v, "function" == typeof v && m.addEventListener(d, We, !1)) }, o.get = function () { let v = this; if (!v && e === Y && (v = Y), !v) return null; const m = v[P]; if (m) return m; if (a) { let L = a.call(this); if (L) return o.set.call(this, L), "function" == typeof v.removeAttribute && v.removeAttribute(n), L } return null }, Ee(e, n, o), e[c] = !0 } function Xe(e, n, i) { if (n) for (let o = 0; o < n.length; o++)qe(e, "on" + n[o], i); else { const o = []; for (const c in e) "on" == c.slice(0, 2) && o.push(c); for (let c = 0; c < o.length; c++)qe(e, o[c], i) } } const ne = A("originalInstance"); function ve(e) { const n = Y[e]; if (!n) return; Y[A(e)] = n, Y[e] = function () { const c = Le(arguments, e); switch (c.length) { case 0: this[ne] = new n; break; case 1: this[ne] = new n(c[0]); break; case 2: this[ne] = new n(c[0], c[1]); break; case 3: this[ne] = new n(c[0], c[1], c[2]); break; case 4: this[ne] = new n(c[0], c[1], c[2], c[3]); break; default: throw new Error("Arg list too long.") } }, ue(Y[e], n); const i = new n(function () { }); let o; for (o in i) "XMLHttpRequest" === e && "responseBlob" === o || function (c) { "function" == typeof i[c] ? Y[e].prototype[c] = function () { return this[ne][c].apply(this[ne], arguments) } : Ee(Y[e].prototype, c, { set: function (a) { "function" == typeof a ? (this[ne][c] = Ie(a, e + "." + c), ue(this[ne][c], a)) : this[ne][c] = a }, get: function () { return this[ne][c] } }) }(o); for (o in n) "prototype" !== o && n.hasOwnProperty(o) && (Y[e][o] = n[o]) } function le(e, n, i) { let o = e; for (; o && !o.hasOwnProperty(n);)o = de(o); !o && e[n] && (o = e); const c = A(n); let a = null; if (o && (!(a = o[c]) || !o.hasOwnProperty(c)) && (a = o[c] = o[n], Fe(o && ie(o, n)))) { const d = i(a, c, n); o[n] = function () { return d(this, arguments) }, ue(o[n], a) } return a } function lt(e, n, i) { let o = null; function c(a) { const y = a.data; return y.args[y.cbIdx] = function () { a.invoke.apply(this, arguments) }, o.apply(y.target, y.args), a } o = le(e, n, a => function (y, d) { const P = i(y, d); return P.cbIdx >= 0 && "function" == typeof d[P.cbIdx] ? Me(P.name, d[P.cbIdx], P, c) : a.apply(y, d) }) } function ue(e, n) { e[A("OriginalDelegate")] = n } let ze = !1, Ae = !1; function ft() { if (ze) return Ae; ze = !0; try { const e = Te.navigator.userAgent; (-1 !== e.indexOf("MSIE ") || -1 !== e.indexOf("Trident/") || -1 !== e.indexOf("Edge/")) && (Ae = !0) } catch (e) { } return Ae } Zone.__load_patch("ZoneAwarePromise", (e, n, i) => { const o = Object.getOwnPropertyDescriptor, c = Object.defineProperty, y = i.symbol, d = [], P = !0 === e[y("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")], v = y("Promise"), m = y("then"); i.onUnhandledError = l => { if (i.showUncaughtError()) { const u = l && l.rejection; u ? console.error("Unhandled Promise rejection:", u instanceof Error ? u.message : u, "; Zone:", l.zone.name, "; Task:", l.task && l.task.source, "; Value:", u, u instanceof Error ? u.stack : void 0) : console.error(l) } }, i.microtaskDrainDone = () => { for (; d.length;) { const l = d.shift(); try { l.zone.runGuarded(() => { throw l.throwOriginal ? l.rejection : l }) } catch (u) { N(u) } } }; const Z = y("unhandledPromiseRejectionHandler"); function N(l) { i.onUnhandledError(l); try { const u = n[Z]; "function" == typeof u && u.call(this, l) } catch (u) { } } function B(l) { return l && l.then } function H(l) { return l } function J(l) { return t.reject(l) } const q = y("state"), R = y("value"), _ = y("finally"), K = y("parentPromiseValue"), x = y("parentPromiseState"), j = null, p = !0, G = !1; function I(l, u) { return s => { try { z(l, u, s) } catch (f) { z(l, !1, f) } } } const w = function () { let l = !1; return function (s) { return function () { l || (l = !0, s.apply(null, arguments)) } } }, oe = y("currentTaskTrace"); function z(l, u, s) { const f = w(); if (l === s) throw new TypeError("Promise resolved with itself"); if (l[q] === j) { let g = null; try { ("object" == typeof s || "function" == typeof s) && (g = s && s.then) } catch (b) { return f(() => { z(l, !1, b) })(), l } if (u !== G && s instanceof t && s.hasOwnProperty(q) && s.hasOwnProperty(R) && s[q] !== j) re(s), z(l, s[q], s[R]); else if (u !== G && "function" == typeof g) try { g.call(s, f(I(l, u)), f(I(l, !1))) } catch (b) { f(() => { z(l, !1, b) })() } else { l[q] = u; const b = l[R]; if (l[R] = s, l[_] === _ && u === p && (l[q] = l[x], l[R] = l[K]), u === G && s instanceof Error) { const T = n.currentTask && n.currentTask.data && n.currentTask.data.__creationTrace__; T && c(s, oe, { configurable: !0, enumerable: !1, writable: !0, value: T }) } for (let T = 0; T < b.length;)ee(l, b[T++], b[T++], b[T++], b[T++]); if (0 == b.length && u == G) { l[q] = 0; let T = s; try { throw new Error("Uncaught (in promise): " + function a(l) { return l && l.toString === Object.prototype.toString ? (l.constructor && l.constructor.name || "") + ": " + JSON.stringify(l) : l ? l.toString() : Object.prototype.toString.call(l) }(s) + (s && s.stack ? "\n" + s.stack : "")) } catch (D) { T = D } P && (T.throwOriginal = !0), T.rejection = s, T.promise = l, T.zone = n.current, T.task = n.currentTask, d.push(T), i.scheduleMicroTask() } } } return l } const U = y("rejectionHandledHandler"); function re(l) { if (0 === l[q]) { try { const u = n[U]; u && "function" == typeof u && u.call(this, { rejection: l[R], promise: l }) } catch (u) { } l[q] = G; for (let u = 0; u < d.length; u++)l === d[u].promise && d.splice(u, 1) } } function ee(l, u, s, f, g) { re(l); const b = l[q], T = b ? "function" == typeof f ? f : H : "function" == typeof g ? g : J; u.scheduleMicroTask("Promise.then", () => { try { const D = l[R], O = !!s && _ === s[_]; O && (s[K] = D, s[x] = b); const S = u.run(T, void 0, O && T !== J && T !== H ? [] : [D]); z(s, !0, S) } catch (D) { z(s, !1, D) } }, s) } const M = function () { }, E = e.AggregateError; class t { static toString() { return "function ZoneAwarePromise() { [native code] }" } static resolve(u) { return z(new this(null), p, u) } static reject(u) { return z(new this(null), G, u) } static any(u) { if (!u || "function" != typeof u[Symbol.iterator]) return Promise.reject(new E([], "All promises were rejected")); const s = []; let f = 0; try { for (let T of u) f++, s.push(t.resolve(T)) } catch (T) { return Promise.reject(new E([], "All promises were rejected")) } if (0 === f) return Promise.reject(new E([], "All promises were rejected")); let g = !1; const b = []; return new t((T, D) => { for (let O = 0; O < s.length; O++)s[O].then(S => { g || (g = !0, T(S)) }, S => { b.push(S), f--, 0 === f && (g = !0, D(new E(b, "All promises were rejected"))) }) }) } static race(u) { let s, f, g = new this((D, O) => { s = D, f = O }); function b(D) { s(D) } function T(D) { f(D) } for (let D of u) B(D) || (D = this.resolve(D)), D.then(b, T); return g } static all(u) { return t.allWithCallback(u) } static allSettled(u) { return (this && this.prototype instanceof t ? this : t).allWithCallback(u, { thenCallback: f => ({ status: "fulfilled", value: f }), errorCallback: f => ({ status: "rejected", reason: f }) }) } static allWithCallback(u, s) { let f, g, b = new this((S, V) => { f = S, g = V }), T = 2, D = 0; const O = []; for (let S of u) { B(S) || (S = this.resolve(S)); const V = D; try { S.then(F => { O[V] = s ? s.thenCallback(F) : F, T--, 0 === T && f(O) }, F => { s ? (O[V] = s.errorCallback(F), T--, 0 === T && f(O)) : g(F) }) } catch (F) { g(F) } T++, D++ } return T -= 2, 0 === T && f(O), b } constructor(u) { const s = this; if (!(s instanceof t)) throw new Error("Must be an instanceof Promise."); s[q] = j, s[R] = []; try { const f = w(); u && u(f(I(s, p)), f(I(s, G))) } catch (f) { z(s, !1, f) } } get [Symbol.toStringTag]() { return "Promise" } get [Symbol.species]() { return t } then(u, s) { var f; let g = null === (f = this.constructor) || void 0 === f ? void 0 : f[Symbol.species]; (!g || "function" != typeof g) && (g = this.constructor || t); const b = new g(M), T = n.current; return this[q] == j ? this[R].push(T, b, u, s) : ee(this, T, b, u, s), b } catch(u) { return this.then(null, u) } finally(u) { var s; let f = null === (s = this.constructor) || void 0 === s ? void 0 : s[Symbol.species]; (!f || "function" != typeof f) && (f = t); const g = new f(M); g[_] = _; const b = n.current; return this[q] == j ? this[R].push(b, g, u, u) : ee(this, b, g, u, u), g } } t.resolve = t.resolve, t.reject = t.reject, t.race = t.race, t.all = t.all; const r = e[v] = e.Promise; e.Promise = t; const k = y("thenPatched"); function C(l) { const u = l.prototype, s = o(u, "then"); if (s && (!1 === s.writable || !s.configurable)) return; const f = u.then; u[m] = f, l.prototype.then = function (g, b) { return new t((D, O) => { f.call(this, D, O) }).then(g, b) }, l[k] = !0 } return i.patchThen = C, r && (C(r), le(e, "fetch", l => function $(l) { return function (u, s) { let f = l.apply(u, s); if (f instanceof t) return f; let g = f.constructor; return g[k] || C(g), f } }(l))), Promise[n.__symbol__("uncaughtPromiseErrors")] = d, t }), Zone.__load_patch("toString", e => { const n = Function.prototype.toString, i = A("OriginalDelegate"), o = A("Promise"), c = A("Error"), a = function () { if ("function" == typeof this) { const v = this[i]; if (v) return "function" == typeof v ? n.call(v) : Object.prototype.toString.call(v); if (this === Promise) { const m = e[o]; if (m) return n.call(m) } if (this === Error) { const m = e[c]; if (m) return n.call(m) } } return n.call(this) }; a[i] = n, Function.prototype.toString = a; const y = Object.prototype.toString; Object.prototype.toString = function () { return "function" == typeof Promise && this instanceof Promise ? "[object Promise]" : y.call(this) } }); let ye = !1; if ("undefined" != typeof window) try { const e = Object.defineProperty({}, "passive", { get: function () { ye = !0 } }); window.addEventListener("test", e, e), window.removeEventListener("test", e, e) } catch (e) { ye = !1 } const ht = { useG: !0 }, te = {}, Ye = {}, $e = new RegExp("^" + ke + "(\\w+)(true|false)$"), Ke = A("propagationStopped"); function Je(e, n) { const i = (n ? n(e) : e) + ae, o = (n ? n(e) : e) + ce, c = ke + i, a = ke + o; te[e] = {}, te[e][ae] = c, te[e][ce] = a } function dt(e, n, i, o) { const c = o && o.add || Oe, a = o && o.rm || Se, y = o && o.listeners || "eventListeners", d = o && o.rmAll || "removeAllListeners", P = A(c), v = "." + c + ":", Z = function (R, _, K) { if (R.isRemoved) return; const x = R.callback; let X; "object" == typeof x && x.handleEvent && (R.callback = p => x.handleEvent(p), R.originalDelegate = x); try { R.invoke(R, _, [K]) } catch (p) { X = p } const j = R.options; return j && "object" == typeof j && j.once && _[a].call(_, K.type, R.originalDelegate ? R.originalDelegate : R.callback, j), X }; function N(R, _, K) { if (!(_ = _ || e.event)) return; const x = R || _.target || e, X = x[te[_.type][K ? ce : ae]]; if (X) { const j = []; if (1 === X.length) { const p = Z(X[0], x, _); p && j.push(p) } else { const p = X.slice(); for (let G = 0; G < p.length && (!_ || !0 !== _[Ke]); G++) { const h = Z(p[G], x, _); h && j.push(h) } } if (1 === j.length) throw j[0]; for (let p = 0; p < j.length; p++) { const G = j[p]; n.nativeScheduleMicroTask(() => { throw G }) } } } const B = function (R) { return N(this, R, !1) }, H = function (R) { return N(this, R, !0) }; function J(R, _) { if (!R) return !1; let K = !0; _ && void 0 !== _.useG && (K = _.useG); const x = _ && _.vh; let X = !0; _ && void 0 !== _.chkDup && (X = _.chkDup); let j = !1; _ && void 0 !== _.rt && (j = _.rt); let p = R; for (; p && !p.hasOwnProperty(c);)p = de(p); if (!p && R[c] && (p = R), !p || p[P]) return !1; const G = _ && _.eventNameToString, h = {}, I = p[P] = p[c], w = p[A(a)] = p[a], Q = p[A(y)] = p[y], oe = p[A(d)] = p[d]; let z; function U(s, f) { return !ye && "object" == typeof s && s ? !!s.capture : ye && f ? "boolean" == typeof s ? { capture: s, passive: !0 } : s ? "object" == typeof s && !1 !== s.passive ? Object.assign(Object.assign({}, s), { passive: !0 }) : s : { passive: !0 } : s } _ && _.prepend && (z = p[A(_.prepend)] = p[_.prepend]); const t = K ? function (s) { if (!h.isExisting) return I.call(h.target, h.eventName, h.capture ? H : B, h.options) } : function (s) { return I.call(h.target, h.eventName, s.invoke, h.options) }, r = K ? function (s) { if (!s.isRemoved) { const f = te[s.eventName]; let g; f && (g = f[s.capture ? ce : ae]); const b = g && s.target[g]; if (b) for (let T = 0; T < b.length; T++)if (b[T] === s) { b.splice(T, 1), s.isRemoved = !0, 0 === b.length && (s.allRemoved = !0, s.target[g] = null); break } } if (s.allRemoved) return w.call(s.target, s.eventName, s.capture ? H : B, s.options) } : function (s) { return w.call(s.target, s.eventName, s.invoke, s.options) }, C = _ && _.diff ? _.diff : function (s, f) { const g = typeof f; return "function" === g && s.callback === f || "object" === g && s.originalDelegate === f }, $ = Zone[A("UNPATCHED_EVENTS")], l = e[A("PASSIVE_EVENTS")], u = function (s, f, g, b, T = !1, D = !1) { return function () { const O = this || e; let S = arguments[0]; _ && _.transferEventName && (S = _.transferEventName(S)); let V = arguments[1]; if (!V) return s.apply(this, arguments); if (we && "uncaughtException" === S) return s.apply(this, arguments); let F = !1; if ("function" != typeof V) { if (!V.handleEvent) return s.apply(this, arguments); F = !0 } if (x && !x(s, V, O, arguments)) return; const fe = ye && !!l && -1 !== l.indexOf(S), se = U(arguments[2], fe); if ($) for (let _e = 0; _e < $.length; _e++)if (S === $[_e]) return fe ? s.call(O, S, V, se) : s.apply(this, arguments); const xe = !!se && ("boolean" == typeof se || se.capture), nt = !(!se || "object" != typeof se) && se.once, gt = Zone.current; let Ge = te[S]; Ge || (Je(S, G), Ge = te[S]); const rt = Ge[xe ? ce : ae]; let De, me = O[rt], ot = !1; if (me) { if (ot = !0, X) for (let _e = 0; _e < me.length; _e++)if (C(me[_e], V)) return } else me = O[rt] = []; const st = O.constructor.name, it = Ye[st]; it && (De = it[S]), De || (De = st + f + (G ? G(S) : S)), h.options = se, nt && (h.options.once = !1), h.target = O, h.capture = xe, h.eventName = S, h.isExisting = ot; const be = K ? ht : void 0; be && (be.taskData = h); const he = gt.scheduleEventTask(De, V, be, g, b); return h.target = null, be && (be.taskData = null), nt && (se.once = !0), !ye && "boolean" == typeof he.options || (he.options = se), he.target = O, he.capture = xe, he.eventName = S, F && (he.originalDelegate = V), D ? me.unshift(he) : me.push(he), T ? O : void 0 } }; return p[c] = u(I, v, t, r, j), z && (p.prependListener = u(z, ".prependListener:", function (s) { return z.call(h.target, h.eventName, s.invoke, h.options) }, r, j, !0)), p[a] = function () { const s = this || e; let f = arguments[0]; _ && _.transferEventName && (f = _.transferEventName(f)); const g = arguments[2], b = !!g && ("boolean" == typeof g || g.capture), T = arguments[1]; if (!T) return w.apply(this, arguments); if (x && !x(w, T, s, arguments)) return; const D = te[f]; let O; D && (O = D[b ? ce : ae]); const S = O && s[O]; if (S) for (let V = 0; V < S.length; V++) { const F = S[V]; if (C(F, T)) return S.splice(V, 1), F.isRemoved = !0, 0 === S.length && (F.allRemoved = !0, s[O] = null, "string" == typeof f) && (s[ke + "ON_PROPERTY" + f] = null), F.zone.cancelTask(F), j ? s : void 0 } return w.apply(this, arguments) }, p[y] = function () { const s = this || e; let f = arguments[0]; _ && _.transferEventName && (f = _.transferEventName(f)); const g = [], b = Qe(s, G ? G(f) : f); for (let T = 0; T < b.length; T++) { const D = b[T]; g.push(D.originalDelegate ? D.originalDelegate : D.callback) } return g }, p[d] = function () { const s = this || e; let f = arguments[0]; if (f) { _ && _.transferEventName && (f = _.transferEventName(f)); const g = te[f]; if (g) { const D = s[g[ae]], O = s[g[ce]]; if (D) { const S = D.slice(); for (let V = 0; V < S.length; V++) { const F = S[V]; this[a].call(this, f, F.originalDelegate ? F.originalDelegate : F.callback, F.options) } } if (O) { const S = O.slice(); for (let V = 0; V < S.length; V++) { const F = S[V]; this[a].call(this, f, F.originalDelegate ? F.originalDelegate : F.callback, F.options) } } } } else { const g = Object.keys(s); for (let b = 0; b < g.length; b++) { const D = $e.exec(g[b]); let O = D && D[1]; O && "removeListener" !== O && this[d].call(this, O) } this[d].call(this, "removeListener") } if (j) return this }, ue(p[c], I), ue(p[a], w), oe && ue(p[d], oe), Q && ue(p[y], Q), !0 } let q = []; for (let R = 0; R < i.length; R++)q[R] = J(i[R], o); return q } function Qe(e, n) { if (!n) { const a = []; for (let y in e) { const d = $e.exec(y); let P = d && d[1]; if (P && (!n || P === n)) { const v = e[y]; if (v) for (let m = 0; m < v.length; m++)a.push(v[m]) } } return a } let i = te[n]; i || (Je(n), i = te[n]); const o = e[i[ae]], c = e[i[ce]]; return o ? c ? o.concat(c) : o.slice() : c ? c.slice() : [] } function _t(e, n) { const i = e.Event; i && i.prototype && n.patchMethod(i.prototype, "stopImmediatePropagation", o => function (c, a) { c[Ke] = !0, o && o.apply(c, a) }) } function Et(e, n, i, o, c) { const a = Zone.__symbol__(o); if (n[a]) return; const y = n[a] = n[o]; n[o] = function (d, P, v) { return P && P.prototype && c.forEach(function (m) { const L = `${i}.${o}::` + m, Z = P.prototype; try { if (Z.hasOwnProperty(m)) { const N = e.ObjectGetOwnPropertyDescriptor(Z, m); N && N.value ? (N.value = e.wrapWithCurrentZone(N.value, L), e._redefineProperty(P.prototype, m, N)) : Z[m] && (Z[m] = e.wrapWithCurrentZone(Z[m], L)) } else Z[m] && (Z[m] = e.wrapWithCurrentZone(Z[m], L)) } catch (N) { } }), y.call(n, d, P, v) }, e.attachOriginToPatched(n[o], y) } function et(e, n, i) { if (!i || 0 === i.length) return n; const o = i.filter(a => a.target === e); if (!o || 0 === o.length) return n; const c = o[0].ignoreProperties; return n.filter(a => -1 === c.indexOf(a)) } function tt(e, n, i, o) { e && Xe(e, et(e, n, i), o) } function He(e) { return Object.getOwnPropertyNames(e).filter(n => n.startsWith("on") && n.length > 2).map(n => n.substring(2)) } Zone.__load_patch("util", (e, n, i) => { const o = He(e); i.patchOnProperties = Xe, i.patchMethod = le, i.bindArguments = Le, i.patchMacroTask = lt; const c = n.__symbol__("BLACK_LISTED_EVENTS"), a = n.__symbol__("UNPATCHED_EVENTS"); e[a] && (e[c] = e[a]), e[c] && (n[c] = n[a] = e[c]), i.patchEventPrototype = _t, i.patchEventTarget = dt, i.isIEOrEdge = ft, i.ObjectDefineProperty = Ee, i.ObjectGetOwnPropertyDescriptor = ie, i.ObjectCreate = ge, i.ArraySlice = Ve, i.patchClass = ve, i.wrapWithCurrentZone = Ie, i.filterProperties = et, i.attachOriginToPatched = ue, i._redefineProperty = Object.defineProperty, i.patchCallbacks = Et, i.getGlobalObjects = () => ({ globalSources: Ye, zoneSymbolEventNames: te, eventNames: o, isBrowser: je, isMix: Ue, isNode: we, TRUE_STR: ce, FALSE_STR: ae, ZONE_SYMBOL_PREFIX: ke, ADD_EVENT_LISTENER_STR: Oe, REMOVE_EVENT_LISTENER_STR: Se }) }); const Ce = A("zoneTask"); function pe(e, n, i, o) { let c = null, a = null; i += o; const y = {}; function d(v) { const m = v.data; return m.args[0] = function () { return v.invoke.apply(this, arguments) }, m.handleId = c.apply(e, m.args), v } function P(v) { return a.call(e, v.data.handleId) } c = le(e, n += o, v => function (m, L) { if ("function" == typeof L[0]) { const Z = { isPeriodic: "Interval" === o, delay: "Timeout" === o || "Interval" === o ? L[1] || 0 : void 0, args: L }, N = L[0]; L[0] = function () { try { return N.apply(this, arguments) } finally { Z.isPeriodic || ("number" == typeof Z.handleId ? delete y[Z.handleId] : Z.handleId && (Z.handleId[Ce] = null)) } }; const B = Me(n, L[0], Z, d, P); if (!B) return B; const H = B.data.handleId; return "number" == typeof H ? y[H] = B : H && (H[Ce] = B), H && H.ref && H.unref && "function" == typeof H.ref && "function" == typeof H.unref && (B.ref = H.ref.bind(H), B.unref = H.unref.bind(H)), "number" == typeof H || H ? H : B } return v.apply(e, L) }), a = le(e, i, v => function (m, L) { const Z = L[0]; let N; "number" == typeof Z ? N = y[Z] : (N = Z && Z[Ce], N || (N = Z)), N && "string" == typeof N.type ? "notScheduled" !== N.state && (N.cancelFn && N.data.isPeriodic || 0 === N.runCount) && ("number" == typeof Z ? delete y[Z] : Z && (Z[Ce] = null), N.zone.cancelTask(N)) : v.apply(e, L) }) } Zone.__load_patch("legacy", e => { const n = e[Zone.__symbol__("legacyPatch")]; n && n() }), Zone.__load_patch("queueMicrotask", (e, n, i) => { i.patchMethod(e, "queueMicrotask", o => function (c, a) { n.current.scheduleMicroTask("queueMicrotask", a[0]) }) }), Zone.__load_patch("timers", e => { const n = "set", i = "clear"; pe(e, n, i, "Timeout"), pe(e, n, i, "Interval"), pe(e, n, i, "Immediate") }), Zone.__load_patch("requestAnimationFrame", e => { pe(e, "request", "cancel", "AnimationFrame"), pe(e, "mozRequest", "mozCancel", "AnimationFrame"), pe(e, "webkitRequest", "webkitCancel", "AnimationFrame") }), Zone.__load_patch("blocking", (e, n) => { const i = ["alert", "prompt", "confirm"]; for (let o = 0; o < i.length; o++)le(e, i[o], (a, y, d) => function (P, v) { return n.current.run(a, e, v, d) }) }), Zone.__load_patch("EventTarget", (e, n, i) => { (function mt(e, n) { n.patchEventPrototype(e, n) })(e, i), function pt(e, n) { if (Zone[n.symbol("patchEventTarget")]) return; const { eventNames: i, zoneSymbolEventNames: o, TRUE_STR: c, FALSE_STR: a, ZONE_SYMBOL_PREFIX: y } = n.getGlobalObjects(); for (let P = 0; P < i.length; P++) { const v = i[P], Z = y + (v + a), N = y + (v + c); o[v] = {}, o[v][a] = Z, o[v][c] = N } const d = e.EventTarget; d && d.prototype && n.patchEventTarget(e, n, [d && d.prototype]) }(e, i); const o = e.XMLHttpRequestEventTarget; o && o.prototype && i.patchEventTarget(e, i, [o.prototype]) }), Zone.__load_patch("MutationObserver", (e, n, i) => { ve("MutationObserver"), ve("WebKitMutationObserver") }), Zone.__load_patch("IntersectionObserver", (e, n, i) => { ve("IntersectionObserver") }), Zone.__load_patch("FileReader", (e, n, i) => { ve("FileReader") }), Zone.__load_patch("on_property", (e, n, i) => { !function Tt(e, n) { if (we && !Ue || Zone[e.symbol("patchEvents")]) return; const i = n.__Zone_ignore_on_properties; let o = []; if (je) { const c = window; o = o.concat(["Document", "SVGElement", "Element", "HTMLElement", "HTMLBodyElement", "HTMLMediaElement", "HTMLFrameSetElement", "HTMLFrameElement", "HTMLIFrameElement", "HTMLMarqueeElement", "Worker"]); const a = function ut() { try { const e = Te.navigator.userAgent; if (-1 !== e.indexOf("MSIE ") || -1 !== e.indexOf("Trident/")) return !0 } catch (e) { } return !1 }() ? [{ target: c, ignoreProperties: ["error"] }] : []; tt(c, He(c), i && i.concat(a), de(c)) } o = o.concat(["XMLHttpRequest", "XMLHttpRequestEventTarget", "IDBIndex", "IDBRequest", "IDBOpenDBRequest", "IDBDatabase", "IDBTransaction", "IDBCursor", "WebSocket"]); for (let c = 0; c < o.length; c++) { const a = n[o[c]]; a && a.prototype && tt(a.prototype, He(a.prototype), i) } }(i, e) }), Zone.__load_patch("customElements", (e, n, i) => { !function yt(e, n) { const { isBrowser: i, isMix: o } = n.getGlobalObjects(); (i || o) && e.customElements && "customElements" in e && n.patchCallbacks(n, e.customElements, "customElements", "define", ["connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback"]) }(e, i) }), Zone.__load_patch("XHR", (e, n) => { !function P(v) { const m = v.XMLHttpRequest; if (!m) return; const L = m.prototype; let N = L[Ze], B = L[Ne]; if (!N) { const h = v.XMLHttpRequestEventTarget; if (h) { const I = h.prototype; N = I[Ze], B = I[Ne] } } const H = "readystatechange", J = "scheduled"; function q(h) { const I = h.data, w = I.target; w[a] = !1, w[d] = !1; const Q = w[c]; N || (N = w[Ze], B = w[Ne]), Q && B.call(w, H, Q); const oe = w[c] = () => { if (w.readyState === w.DONE) if (!I.aborted && w[a] && h.state === J) { const U = w[n.__symbol__("loadfalse")]; if (0 !== w.status && U && U.length > 0) { const re = h.invoke; h.invoke = function () { const ee = w[n.__symbol__("loadfalse")]; for (let W = 0; W < ee.length; W++)ee[W] === h && ee.splice(W, 1); !I.aborted && h.state === J && re.call(h) }, U.push(h) } else h.invoke() } else !I.aborted && !1 === w[a] && (w[d] = !0) }; return N.call(w, H, oe), w[i] || (w[i] = h), p.apply(w, I.args), w[a] = !0, h } function R() { } function _(h) { const I = h.data; return I.aborted = !0, G.apply(I.target, I.args) } const K = le(L, "open", () => function (h, I) { return h[o] = 0 == I[2], h[y] = I[1], K.apply(h, I) }), X = A("fetchTaskAborting"), j = A("fetchTaskScheduling"), p = le(L, "send", () => function (h, I) { if (!0 === n.current[j] || h[o]) return p.apply(h, I); { const w = { target: h, url: h[y], isPeriodic: !1, args: I, aborted: !1 }, Q = Me("XMLHttpRequest.send", R, w, q, _); h && !0 === h[d] && !w.aborted && Q.state === J && Q.invoke() } }), G = le(L, "abort", () => function (h, I) { const w = function Z(h) { return h[i] }(h); if (w && "string" == typeof w.type) { if (null == w.cancelFn || w.data && w.data.aborted) return; w.zone.cancelTask(w) } else if (!0 === n.current[X]) return G.apply(h, I) }) }(e); const i = A("xhrTask"), o = A("xhrSync"), c = A("xhrListener"), a = A("xhrScheduled"), y = A("xhrURL"), d = A("xhrErrorBeforeScheduled") }), Zone.__load_patch("geolocation", e => { e.navigator && e.navigator.geolocation && function at(e, n) { const i = e.constructor.name; for (let o = 0; o < n.length; o++) { const c = n[o], a = e[c]; if (a) { if (!Fe(ie(e, c))) continue; e[c] = (d => { const P = function () { return d.apply(this, Le(arguments, i + "." + c)) }; return ue(P, d), P })(a) } } }(e.navigator.geolocation, ["getCurrentPosition", "watchPosition"]) }), Zone.__load_patch("PromiseRejectionEvent", (e, n) => { function i(o) { return function (c) { Qe(e, o).forEach(y => { const d = e.PromiseRejectionEvent; if (d) { const P = new d(o, { promise: c.promise, reason: c.rejection }); y.invoke(P) } }) } } e.PromiseRejectionEvent && (n[A("unhandledPromiseRejectionHandler")] = i("unhandledrejection"), n[A("rejectionHandledHandler")] = i("rejectionhandled")) }) } }, ie => { ie(ie.s = 443) }]);
  </script>
  <script>
    var yn = Object.defineProperty, vn = Object.defineProperties, kn = Object.getOwnPropertyDescriptors, hi = Object.getOwnPropertySymbols, Mn = Object.prototype.hasOwnProperty, wn = Object.prototype.propertyIsEnumerable, Be = (n, t, e) => t in n ? yn(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e, he = (n, t) => { for (var e in t || (t = {})) Mn.call(t, e) && Be(n, e, t[e]); if (hi) for (var e of hi(t)) wn.call(t, e) && Be(n, e, t[e]); return n }, de = (n, t) => vn(n, kn(t)), k = (n, t, e) => (Be(n, "symbol" != typeof t ? t + "" : t, e), e); import { r as Sn, a as Nt, e as di, c as ui, i as F, d as I, b as K, v as C, u as fi, l as Dn, f as Pt, g as V, h as Ht, s as dt, j as bt, k as O, _ as gi, t as st, m as Pn, n as An, T as Y, o as ue, p as fe, H as Q, P as rt, q as pi, w as mi, x as At, y as bi, z as xt, A as Cn, B as Wt, C as _t, D as xi, E as $, F as T, G as Ln, I as _i, J as yi, K as On, L as vi, M as ki, N as Tn, O as Z, Q as E, R as Rn, S as X, U as Ve, V as Mi, W as En, X as yt, Y as ge, Z as vt, $ as pe, a0 as N, a1 as Ne, a2 as U, a3 as Ct, a4 as zn, a5 as Fn, a6 as wi, a7 as me, a8 as Si, a9 as In, aa as Bn, ab as be, ac as Vn, ad as Nn, ae as Di, af as Pi, ag as Ai, ah as xe, ai as Hn, aj as ut, ak as Wn, al as jn, am as $n, an as Ci, ao as Un, ap as Yn, aq as Xn, ar as Kn, as as Gn, at as He, au as jt, av as qn, aw as kt, ax as Jn, ay as $t, az as Lt, aA as Li, aB as Zn, aC as Oi, aD as Qn, aE as to, aF as lt, aG as Ti, aH as Ri, aI as eo, aJ as We, aK as Ei, aL as _e, aM as Ut, aN as io, aO as so, aP as no } from "./chunks/helpers.segment.js"; import "@kurkle/color"; class oo { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, s) { const a = e.duration; e.listeners[s].forEach(r => r({ chart: t, initial: e.initial, numSteps: a, currentStep: Math.min(i - e.start, a) })) } _refresh() { this._request || (this._running = !0, this._request = Sn.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(t = Date.now()) { let e = 0; this._charts.forEach((i, s) => { if (!i.running || !i.items.length) return; const o = i.items; let l, a = o.length - 1, r = !1; for (; a >= 0; --a)l = o[a], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(t), r = !0) : (o[a] = o[o.length - 1], o.pop()); r && (s.draw(), this._notify(s, i, t, "progress")), o.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += o.length }), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t) { const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i) { this._getAnims(t).listeners[e].push(i) } add(t, e) { !e || !e.length || this._getAnims(t).items.push(...e) } has(t) { return this._getAnims(t).items.length > 0 } start(t) { const e = this._charts.get(t); !e || (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((i, s) => Math.max(i, s._duration), 0), this._refresh()) } running(t) { if (!this._running) return !1; const e = this._charts.get(t); return !(!e || !e.running || !e.items.length) } stop(t) { const e = this._charts.get(t); if (!e || !e.items.length) return; const i = e.items; let s = i.length - 1; for (; s >= 0; --s)i[s].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t) { return this._charts.delete(t) } } var ot = new oo; const zi = "transparent", ao = { boolean: (n, t, e) => e > .5 ? t : n, color(n, t, e) { const i = ui(n || zi), s = i.valid && ui(t || zi); return s && s.valid ? s.mix(i, e).hexString() : t }, number: (n, t, e) => n + (t - n) * e }; class Fi { constructor(t, e, i, s) { const o = e[i]; s = Nt([t.to, s, o, t.from]); const a = Nt([t.from, o, s]); this._active = !0, this._fn = t.fn || ao[t.type || typeof a], this._easing = di[t.easing] || di.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = a, this._to = s, this._promises = void 0 } active() { return this._active } update(t, e, i) { if (this._active) { this._notify(!1); const s = this._target[this._prop], o = i - this._start, a = this._duration - o; this._start = i, this._duration = Math.floor(Math.max(a, t.duration)), this._total += o, this._loop = !!t.loop, this._to = Nt([t.to, e, s, t.from]), this._from = Nt([t.from, s, e]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(t) { const e = t - this._start, i = this._duration, s = this._prop, o = this._from, a = this._loop, r = this._to; let l; if (this._active = o !== r && (a || e < i), !this._active) return this._target[s] = r, void this._notify(!0); e < 0 ? this._target[s] = o : (l = e / i % 2, l = a && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[s] = this._fn(o, r, l)) } wait() { const t = this._promises || (this._promises = []); return new Promise((e, i) => { t.push({ res: e, rej: i }) }) } _notify(t) { const e = t ? "res" : "rej", i = this._promises || []; for (let s = 0; s < i.length; s++)i[s][e]() } } class je { constructor(t, e) { this._chart = t, this._properties = new Map, this.configure(e) } configure(t) { if (!F(t)) return; const e = Object.keys(I.animation), i = this._properties; Object.getOwnPropertyNames(t).forEach(s => { const o = t[s]; if (!F(o)) return; const a = {}; for (const r of e) a[r] = o[r]; (K(o.properties) && o.properties || [s]).forEach(r => { (r === s || !i.has(r)) && i.set(r, a) }) }) } _animateOptions(t, e) { const i = e.options, s = lo(t, i); if (!s) return []; const o = this._createAnimations(s, i); return i.$shared && ro(t.options.$animations, i).then(() => { t.options = i }, () => { }), o } _createAnimations(t, e) { const i = this._properties, s = [], o = t.$animations || (t.$animations = {}), a = Object.keys(e), r = Date.now(); let l; for (l = a.length - 1; l >= 0; --l) { const c = a[l]; if ("$" === c.charAt(0)) continue; if ("options" === c) { s.push(...this._animateOptions(t, e)); continue } const h = e[c]; let d = o[c]; const u = i.get(c); if (d) { if (u && d.active()) { d.update(u, h, r); continue } d.cancel() } u && u.duration ? (o[c] = d = new Fi(u, t, c, h), s.push(d)) : t[c] = h } return s } update(t, e) { if (0 === this._properties.size) return void Object.assign(t, e); const i = this._createAnimations(t, e); return i.length ? (ot.add(this._chart, i), !0) : void 0 } } function ro(n, t) { const e = [], i = Object.keys(t); for (let s = 0; s < i.length; s++) { const o = n[i[s]]; o && o.active() && e.push(o.wait()) } return Promise.all(e) } function lo(n, t) { if (!t) return; let e = n.options; if (e) return e.$shared && (n.options = e = Object.assign({}, e, { $shared: !1, $animations: {} })), e; n.options = t } function Ii(n, t) { const e = n && n.options || {}, i = e.reverse, s = void 0 === e.min ? t : 0, o = void 0 === e.max ? t : 0; return { start: i ? o : s, end: i ? s : o } } function co(n, t, e) { if (!1 === e) return !1; const i = Ii(n, e), s = Ii(t, e); return { top: s.end, right: i.end, bottom: s.start, left: i.start } } function ho(n) { let t, e, i, s; return F(n) ? (t = n.top, e = n.right, i = n.bottom, s = n.left) : t = e = i = s = n, { top: t, right: e, bottom: i, left: s, disabled: !1 === n } } function Bi(n, t) { const e = [], i = n._getSortedDatasetMetas(t); let s, o; for (s = 0, o = i.length; s < o; ++s)e.push(i[s].index); return e } function Vi(n, t, e, i = {}) { const s = n.keys, o = "single" === i.mode; let a, r, l, c; if (null !== t) { for (a = 0, r = s.length; a < r; ++a) { if (l = +s[a], l === e) { if (i.all) continue; break } c = n.values[l], V(c) && (o || 0 === t || dt(t) === dt(c)) && (t += c) } return t } } function uo(n) { const t = Object.keys(n), e = new Array(t.length); let i, s, o; for (i = 0, s = t.length; i < s; ++i)o = t[i], e[i] = { x: o, y: n[o] }; return e } function Ni(n, t) { const e = n && n.options.stacked; return e || void 0 === e && void 0 !== t.stack } function fo(n, t, e) { return `${n.id}.${t.id}.${e.stack || e.type}` } function go(n) { const { min: t, max: e, minDefined: i, maxDefined: s } = n.getUserBounds(); return { min: i ? t : Number.NEGATIVE_INFINITY, max: s ? e : Number.POSITIVE_INFINITY } } function po(n, t, e) { const i = n[t] || (n[t] = {}); return i[e] || (i[e] = {}) } function Hi(n, t, e, i) { for (const s of t.getMatchingVisibleMetas(i).reverse()) { const o = n[s.index]; if (e && o > 0 || !e && o < 0) return s.index } return null } function Wi(n, t) { const { chart: e, _cachedMeta: i } = n, s = e._stacks || (e._stacks = {}), { iScale: o, vScale: a, index: r } = i, l = o.axis, c = a.axis, h = fo(o, a, i), d = t.length; let u; for (let f = 0; f < d; ++f) { const g = t[f], { [l]: p, [c]: b } = g; u = (g._stacks || (g._stacks = {}))[c] = po(s, h, p), u[r] = b, u._top = Hi(u, a, !0, i.type), u._bottom = Hi(u, a, !1, i.type), (u._visualValues || (u._visualValues = {}))[r] = b } } function $e(n, t) { const e = n.scales; return Object.keys(e).filter(i => e[i].axis === t).shift() } function mo(n, t) { return bt(n, { active: !1, dataset: void 0, datasetIndex: t, index: t, mode: "default", type: "dataset" }) } function bo(n, t, e) { return bt(n, { active: !1, dataIndex: t, parsed: void 0, raw: void 0, element: e, index: t, mode: "default", type: "data" }) } function Yt(n, t) { const e = n.controller.index, i = n.vScale && n.vScale.axis; if (i) { t = t || n._parsed; for (const s of t) { const o = s._stacks; if (!o || void 0 === o[i] || void 0 === o[i][e]) return; delete o[i][e], void 0 !== o[i]._visualValues && void 0 !== o[i]._visualValues[e] && delete o[i]._visualValues[e] } } } const Ue = n => "reset" === n || "none" === n, ji = (n, t) => t ? n : Object.assign({}, n), xo = (n, t, e) => n && !t.hidden && t._stacked && { keys: Bi(e, !0), values: null }; class tt { constructor(t, e) { this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const t = this._cachedMeta; this.configure(), this.linkScales(), t._stacked = Ni(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(t) { this.index !== t && Yt(this._cachedMeta), this.index = t } linkScales() { const t = this.chart, e = this._cachedMeta, i = this.getDataset(), s = (d, u, f, g) => "x" === d ? u : "r" === d ? g : f, o = e.xAxisID = C(i.xAxisID, $e(t, "x")), a = e.yAxisID = C(i.yAxisID, $e(t, "y")), r = e.rAxisID = C(i.rAxisID, $e(t, "r")), l = e.indexAxis, c = e.iAxisID = s(l, o, a, r), h = e.vAxisID = s(l, a, o, r); e.xScale = this.getScaleForId(o), e.yScale = this.getScaleForId(a), e.rScale = this.getScaleForId(r), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(h) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(t) { return this.chart.scales[t] } _getOtherScale(t) { const e = this._cachedMeta; return t === e.iScale ? e.vScale : e.iScale } reset() { this._update("reset") } _destroy() { const t = this._cachedMeta; this._data && fi(this._data, this), t._stacked && Yt(t) } _dataCheck() { const t = this.getDataset(), e = t.data || (t.data = []), i = this._data; if (F(e)) this._data = uo(e); else if (i !== e) { if (i) { fi(i, this); const s = this._cachedMeta; Yt(s), s._parsed = [] } e && Object.isExtensible(e) && Dn(e, this), this._syncList = [], this._data = e } } addElements() { const t = this._cachedMeta; this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType) } buildOrUpdateElements(t) { const e = this._cachedMeta, i = this.getDataset(); let s = !1; this._dataCheck(); const o = e._stacked; e._stacked = Ni(e.vScale, e), e.stack !== i.stack && (s = !0, Yt(e), e.stack = i.stack), this._resyncElements(t), (s || o !== e._stacked) && Wi(this, e._parsed) } configure() { const t = this.chart.config, e = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), e, !0); this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(t, e) { const { _cachedMeta: i, _data: s } = this, { iScale: o, _stacked: a } = i, r = o.axis; let h, d, u, l = 0 === t && e === s.length || i._sorted, c = t > 0 && i._parsed[t - 1]; if (!1 === this._parsing) i._parsed = s, i._sorted = !0, u = s; else { u = K(s[t]) ? this.parseArrayData(i, s, t, e) : F(s[t]) ? this.parseObjectData(i, s, t, e) : this.parsePrimitiveData(i, s, t, e); const f = () => null === d[r] || c && d[r] < c[r]; for (h = 0; h < e; ++h)i._parsed[h + t] = d = u[h], l && (f() && (l = !1), c = d); i._sorted = l } a && Wi(this, u) } parsePrimitiveData(t, e, i, s) { const { iScale: o, vScale: a } = t, r = o.axis, l = a.axis, c = o.getLabels(), h = o === a, d = new Array(s); let u, f, g; for (u = 0, f = s; u < f; ++u)g = u + i, d[u] = { [r]: h || o.parse(c[g], g), [l]: a.parse(e[g], g) }; return d } parseArrayData(t, e, i, s) { const { xScale: o, yScale: a } = t, r = new Array(s); let l, c, h, d; for (l = 0, c = s; l < c; ++l)h = l + i, d = e[h], r[l] = { x: o.parse(d[0], h), y: a.parse(d[1], h) }; return r } parseObjectData(t, e, i, s) { const { xScale: o, yScale: a } = t, { xAxisKey: r = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(s); let h, d, u, f; for (h = 0, d = s; h < d; ++h)u = h + i, f = e[u], c[h] = { x: o.parse(Pt(f, r), u), y: a.parse(Pt(f, l), u) }; return c } getParsed(t) { return this._cachedMeta._parsed[t] } getDataElement(t) { return this._cachedMeta.data[t] } applyStack(t, e, i) { const o = this._cachedMeta, a = e[t.axis]; return Vi({ keys: Bi(this.chart, !0), values: e._stacks[t.axis]._visualValues }, a, o.index, { mode: i }) } updateRangeFromParsed(t, e, i, s) { const o = i[e.axis]; let a = null === o ? NaN : o; const r = s && i._stacks[e.axis]; s && r && (s.values = r, a = Vi(s, o, this._cachedMeta.index)), t.min = Math.min(t.min, a), t.max = Math.max(t.max, a) } getMinMax(t, e) { const i = this._cachedMeta, s = i._parsed, o = i._sorted && t === i.iScale, a = s.length, r = this._getOtherScale(t), l = xo(e, i, this.chart), c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: h, max: d } = go(r); let u, f; function g() { f = s[u]; const p = f[r.axis]; return !V(f[t.axis]) || h > p || d < p } for (u = 0; u < a && (g() || (this.updateRangeFromParsed(c, t, f, l), !o)); ++u); if (o) for (u = a - 1; u >= 0; --u)if (!g()) { this.updateRangeFromParsed(c, t, f, l); break } return c } getAllParsedValues(t) { const e = this._cachedMeta._parsed, i = []; let s, o, a; for (s = 0, o = e.length; s < o; ++s)a = e[s][t.axis], V(a) && i.push(a); return i } getMaxOverflow() { return !1 } getLabelAndValue(t) { const e = this._cachedMeta, i = e.iScale, s = e.vScale, o = this.getParsed(t); return { label: i ? "" + i.getLabelForValue(o[i.axis]) : "", value: s ? "" + s.getLabelForValue(o[s.axis]) : "" } } _update(t) { const e = this._cachedMeta; this.update(t || "default"), e._clip = ho(C(this.options.clip, co(e.xScale, e.yScale, this.getMaxOverflow()))) } update(t) { } draw() { const t = this._ctx, i = this._cachedMeta, s = i.data || [], o = this.chart.chartArea, a = [], r = this._drawStart || 0, l = this._drawCount || s.length - r, c = this.options.drawActiveElementsOnTop; let h; for (i.dataset && i.dataset.draw(t, o, r, l), h = r; h < r + l; ++h) { const d = s[h]; d.hidden || (d.active && c ? a.push(d) : d.draw(t, o)) } for (h = 0; h < a.length; ++h)a[h].draw(t, o) } getStyle(t, e) { const i = e ? "active" : "default"; return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i) } getContext(t, e, i) { const s = this.getDataset(); let o; if (t >= 0 && t < this._cachedMeta.data.length) { const a = this._cachedMeta.data[t]; o = a.$context || (a.$context = bo(this.getContext(), t, a)), o.parsed = this.getParsed(t), o.raw = s.data[t], o.index = o.dataIndex = t } else o = this.$context || (this.$context = mo(this.chart.getContext(), this.index)), o.dataset = s, o.index = o.datasetIndex = this.index; return o.active = !!e, o.mode = i, o } resolveDatasetElementOptions(t) { return this._resolveElementOptions(this.datasetElementType.id, t) } resolveDataElementOptions(t, e) { return this._resolveElementOptions(this.dataElementType.id, e, t) } _resolveElementOptions(t, e = "default", i) { const s = "active" === e, o = this._cachedDataOpts, a = t + "-" + e, r = o[a], l = this.enableOptionSharing && Ht(i); if (r) return ji(r, l); const c = this.chart.config, h = c.datasetElementScopeKeys(this._type, t), d = s ? [`${t}Hover`, "hover", t, ""] : [t, ""], u = c.getOptionScopes(this.getDataset(), h), f = Object.keys(I.elements[t]), p = c.resolveNamedOptions(u, f, () => this.getContext(i, s, e), d); return p.$shared && (p.$shared = l, o[a] = Object.freeze(ji(p, l))), p } _resolveAnimations(t, e, i) { const s = this.chart, o = this._cachedDataOpts, a = `animation-${e}`, r = o[a]; if (r) return r; let l; if (!1 !== s.options.animation) { const h = this.chart.config, d = h.datasetAnimationScopeKeys(this._type, e), u = h.getOptionScopes(this.getDataset(), d); l = h.createResolver(u, this.getContext(t, i, e)) } const c = new je(s, l && l.animations); return l && l._cacheable && (o[a] = Object.freeze(c)), c } getSharedOptions(t) { if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t)) } includeOptions(t, e) { return !e || Ue(t) || this.chart._animationsDisabled } _getSharedOptions(t, e) { const i = this.resolveDataElementOptions(t, e), s = this._sharedOptions, o = this.getSharedOptions(i), a = this.includeOptions(e, o) || o !== s; return this.updateSharedOptions(o, e, i), { sharedOptions: o, includeOptions: a } } updateElement(t, e, i, s) { Ue(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i) } updateSharedOptions(t, e, i) { t && !Ue(e) && this._resolveAnimations(void 0, e).update(t, i) } _setStyle(t, e, i, s) { t.active = s; const o = this.getStyle(e, s); this._resolveAnimations(e, i, s).update(t, { options: !s && this.getSharedOptions(o) || o }) } removeHoverStyle(t, e, i) { this._setStyle(t, i, "active", !1) } setHoverStyle(t, e, i) { this._setStyle(t, i, "active", !0) } _removeDatasetHoverStyle() { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !1) } _setDatasetHoverStyle() { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !0) } _resyncElements(t) { const e = this._data, i = this._cachedMeta.data; for (const [r, l, c] of this._syncList) this[r](l, c); this._syncList = []; const s = i.length, o = e.length, a = Math.min(o, s); a && this.parse(0, a), o > s ? this._insertElements(s, o - s, t) : o < s && this._removeElements(o, s - o) } _insertElements(t, e, i = !0) { const s = this._cachedMeta, o = s.data, a = t + e; let r; const l = c => { for (c.length += e, r = c.length - 1; r >= a; r--)c[r] = c[r - e] }; for (l(o), r = t; r < a; ++r)o[r] = new this.dataElementType; this._parsing && l(s._parsed), this.parse(t, e), i && this.updateElements(o, t, e, "reset") } updateElements(t, e, i, s) { } _removeElements(t, e) { const i = this._cachedMeta; if (this._parsing) { const s = i._parsed.splice(t, e); i._stacked && Yt(i, s) } i.data.splice(t, e) } _sync(t) { if (this._parsing) this._syncList.push(t); else { const [e, i, s] = t; this[e](i, s) } this.chart._dataChanges.push([this.index, ...t]) } _onDataPush() { const t = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - t, t]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(t, e) { e && this._sync(["_removeElements", t, e]); const i = arguments.length - 2; i && this._sync(["_insertElements", t, i]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } function _o(n, t) { if (!n._cache.$bar) { const e = n.getMatchingVisibleMetas(t); let i = []; for (let s = 0, o = e.length; s < o; s++)i = i.concat(e[s].controller.getAllParsedValues(n)); n._cache.$bar = gi(i.sort((s, o) => s - o)) } return n._cache.$bar } function yo(n) { const t = n.iScale, e = _o(t, n.type); let s, o, a, r, i = t._length; const l = () => { 32767 === a || -32768 === a || (Ht(r) && (i = Math.min(i, Math.abs(a - r) || i)), r = a) }; for (s = 0, o = e.length; s < o; ++s)a = t.getPixelForValue(e[s]), l(); for (r = void 0, s = 0, o = t.ticks.length; s < o; ++s)a = t.getPixelForTick(s), l(); return i } function vo(n, t, e, i) { const s = e.barThickness; let o, a; return O(s) ? (o = t.min * e.categoryPercentage, a = e.barPercentage) : (o = s * i, a = 1), { chunk: o / i, ratio: a, start: t.pixels[n] - o / 2 } } function ko(n, t, e, i) { const s = t.pixels, o = s[n]; let a = n > 0 ? s[n - 1] : null, r = n < s.length - 1 ? s[n + 1] : null; const l = e.categoryPercentage; null === a && (a = o - (null === r ? t.end - t.start : r - o)), null === r && (r = o + o - a); const c = o - (o - Math.min(a, r)) / 2 * l; return { chunk: Math.abs(r - a) / 2 * l / i, ratio: e.barPercentage, start: c } } function Mo(n, t, e, i) { const s = e.parse(n[0], i), o = e.parse(n[1], i), a = Math.min(s, o), r = Math.max(s, o); let l = a, c = r; Math.abs(a) > Math.abs(r) && (l = r, c = a), t[e.axis] = c, t._custom = { barStart: l, barEnd: c, start: s, end: o, min: a, max: r } } function $i(n, t, e, i) { return K(n) ? Mo(n, t, e, i) : t[e.axis] = e.parse(n, i), t } function Ui(n, t, e, i) { const s = n.iScale, o = n.vScale, a = s.getLabels(), r = s === o, l = []; let c, h, d, u; for (c = e, h = e + i; c < h; ++c)u = t[c], d = {}, d[s.axis] = r || s.parse(a[c], c), l.push($i(u, d, o, c)); return l } function Ye(n) { return n && void 0 !== n.barStart && void 0 !== n.barEnd } function wo(n, t, e) { return 0 !== n ? dt(n) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1) } function So(n) { let t, e, i, s, o; return n.horizontal ? (t = n.base > n.x, e = "left", i = "right") : (t = n.base < n.y, e = "bottom", i = "top"), t ? (s = "end", o = "start") : (s = "start", o = "end"), { start: e, end: i, reverse: t, top: s, bottom: o } } function Do(n, t, e, i) { let s = t.borderSkipped; const o = {}; if (!s) return void (n.borderSkipped = o); if (!0 === s) return void (n.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }); const { start: a, end: r, reverse: l, top: c, bottom: h } = So(n); "middle" === s && e && (n.enableBorderRadius = !0, (e._top || 0) === i ? s = c : (e._bottom || 0) === i ? s = h : (o[Yi(h, a, r, l)] = !0, s = c)), o[Yi(s, a, r, l)] = !0, n.borderSkipped = o } function Yi(n, t, e, i) { return n = i ? Xi(n = Po(n, t, e), e, t) : Xi(n, t, e) } function Po(n, t, e) { return n === t ? e : n === e ? t : n } function Xi(n, t, e) { return "start" === n ? t : "end" === n ? e : n } function Ao(n, { inflateAmount: t }, e) { n.inflateAmount = "auto" === t ? 1 === e ? .33 : 0 : t } k(tt, "defaults", {}), k(tt, "datasetElementType", null), k(tt, "dataElementType", null); class Xt extends tt { parsePrimitiveData(t, e, i, s) { return Ui(t, e, i, s) } parseArrayData(t, e, i, s) { return Ui(t, e, i, s) } parseObjectData(t, e, i, s) { const { iScale: o, vScale: a } = t, { xAxisKey: r = "x", yAxisKey: l = "y" } = this._parsing, c = "x" === o.axis ? r : l, h = "x" === a.axis ? r : l, d = []; let u, f, g, p; for (u = i, f = i + s; u < f; ++u)p = e[u], g = {}, g[o.axis] = o.parse(Pt(p, c), u), d.push($i(Pt(p, h), g, a, u)); return d } updateRangeFromParsed(t, e, i, s) { super.updateRangeFromParsed(t, e, i, s); const o = i._custom; o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max)) } getMaxOverflow() { return 0 } getLabelAndValue(t) { const e = this._cachedMeta, { iScale: i, vScale: s } = e, o = this.getParsed(t), a = o._custom, r = Ye(a) ? "[" + a.start + ", " + a.end + "]" : "" + s.getLabelForValue(o[s.axis]); return { label: "" + i.getLabelForValue(o[i.axis]), value: r } } initialize() { this.enableOptionSharing = !0, super.initialize(), this._cachedMeta.stack = this.getDataset().stack } update(t) { const e = this._cachedMeta; this.updateElements(e.data, 0, e.data.length, t) } updateElements(t, e, i, s) { const o = "reset" === s, { index: a, _cachedMeta: { vScale: r } } = this, l = r.getBasePixel(), c = r.isHorizontal(), h = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, s); for (let f = e; f < e + i; f++) { const g = this.getParsed(f), p = o || O(g[r.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(f), b = this._calculateBarIndexPixels(f, h), m = (g._stacks || {})[r.axis], x = { horizontal: c, base: p.base, enableBorderRadius: !m || Ye(g._custom) || a === m._top || a === m._bottom, x: c ? p.head : b.center, y: c ? b.center : p.head, height: c ? b.size : Math.abs(p.size), width: c ? Math.abs(p.size) : b.size }; u && (x.options = d || this.resolveDataElementOptions(f, t[f].active ? "active" : s)); const v = x.options || t[f].options; Do(x, v, m, a), Ao(x, v, h.ratio), this.updateElement(t[f], f, x, s) } } _getStacks(t, e) { const { iScale: i } = this._cachedMeta, s = i.getMatchingVisibleMetas(this._type).filter(l => l.controller.options.grouped), o = i.options.stacked, a = [], r = l => { const c = l.controller.getParsed(e), h = c && c[l.vScale.axis]; if (O(h) || isNaN(h)) return !0 }; for (const l of s) if ((void 0 === e || !r(l)) && ((!1 === o || -1 === a.indexOf(l.stack) || void 0 === o && void 0 === l.stack) && a.push(l.stack), l.index === t)) break; return a.length || a.push(void 0), a } _getStackCount(t) { return this._getStacks(void 0, t).length } _getStackIndex(t, e, i) { const s = this._getStacks(t, i), o = void 0 !== e ? s.indexOf(e) : -1; return -1 === o ? s.length - 1 : o } _getRuler() { const t = this.options, e = this._cachedMeta, i = e.iScale, s = []; let o, a; for (o = 0, a = e.data.length; o < a; ++o)s.push(i.getPixelForValue(this.getParsed(o)[i.axis], o)); const r = t.barThickness; return { min: r || yo(e), pixels: s, start: i._startPixel, end: i._endPixel, stackCount: this._getStackCount(), scale: i, grouped: t.grouped, ratio: r ? 1 : t.categoryPercentage * t.barPercentage } } _calculateBarValuePixels(t) { const { _cachedMeta: { vScale: e, _stacked: i, index: s }, options: { base: o, minBarLength: a } } = this, r = o || 0, l = this.getParsed(t), c = l._custom, h = Ye(c); let g, p, d = l[e.axis], u = 0, f = i ? this.applyStack(e, l, i) : d; f !== d && (u = f - d, f = d), h && (d = c.barStart, f = c.barEnd - c.barStart, 0 !== d && dt(d) !== dt(c.barEnd) && (u = 0), u += d); const b = O(o) || h ? u : o; let m = e.getPixelForValue(b); if (g = this.chart.getDataVisibility(t) ? e.getPixelForValue(u + f) : m, p = g - m, Math.abs(p) < a) { p = wo(p, e, r) * a, d === r && (m -= p / 2); const x = e.getPixelForDecimal(0), v = e.getPixelForDecimal(1), y = Math.min(x, v), _ = Math.max(x, v); m = Math.max(Math.min(m, _), y), g = m + p, i && !h && (l._stacks[e.axis]._visualValues[s] = e.getValueForPixel(g) - e.getValueForPixel(m)) } if (m === e.getPixelForValue(r)) { const x = dt(p) * e.getLineWidthForValue(r) / 2; m += x, p -= x } return { size: p, base: m, head: g, center: g + p / 2 } } _calculateBarIndexPixels(t, e) { const i = e.scale, s = this.options, o = s.skipNull, a = C(s.maxBarThickness, 1 / 0); let r, l; if (e.grouped) { const c = o ? this._getStackCount(t) : e.stackCount, h = "flex" === s.barThickness ? ko(t, e, s, c) : vo(t, e, s, c), d = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0); r = h.start + h.chunk * d + h.chunk / 2, l = Math.min(a, h.chunk * h.ratio) } else r = i.getPixelForValue(this.getParsed(t)[i.axis], t), l = Math.min(a, e.min * e.ratio); return { base: r - l / 2, head: r + l / 2, center: r, size: l } } draw() { const t = this._cachedMeta, e = t.vScale, i = t.data, s = i.length; let o = 0; for (; o < s; ++o)null !== this.getParsed(o)[e.axis] && i[o].draw(this._ctx) } } k(Xt, "id", "bar"), k(Xt, "defaults", { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }), k(Xt, "overrides", { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }); class Kt extends tt { initialize() { this.enableOptionSharing = !0, super.initialize() } parsePrimitiveData(t, e, i, s) { const o = super.parsePrimitiveData(t, e, i, s); for (let a = 0; a < o.length; a++)o[a]._custom = this.resolveDataElementOptions(a + i).radius; return o } parseArrayData(t, e, i, s) { const o = super.parseArrayData(t, e, i, s); for (let a = 0; a < o.length; a++)o[a]._custom = C(e[i + a][2], this.resolveDataElementOptions(a + i).radius); return o } parseObjectData(t, e, i, s) { const o = super.parseObjectData(t, e, i, s); for (let a = 0; a < o.length; a++) { const r = e[i + a]; o[a]._custom = C(r && r.r && +r.r, this.resolveDataElementOptions(a + i).radius) } return o } getMaxOverflow() { const t = this._cachedMeta.data; let e = 0; for (let i = t.length - 1; i >= 0; --i)e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2); return e > 0 && e } getLabelAndValue(t) { const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: o } = e, a = this.getParsed(t), r = s.getLabelForValue(a.x), l = o.getLabelForValue(a.y), c = a._custom; return { label: i[t] || "", value: "(" + r + ", " + l + (c ? ", " + c : "") + ")" } } update(t) { const e = this._cachedMeta.data; this.updateElements(e, 0, e.length, t) } updateElements(t, e, i, s) { const o = "reset" === s, { iScale: a, vScale: r } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(e, s), h = a.axis, d = r.axis; for (let u = e; u < e + i; u++) { const f = t[u], g = !o && this.getParsed(u), p = {}, b = p[h] = o ? a.getPixelForDecimal(.5) : a.getPixelForValue(g[h]), m = p[d] = o ? r.getBasePixel() : r.getPixelForValue(g[d]); p.skip = isNaN(b) || isNaN(m), c && (p.options = l || this.resolveDataElementOptions(u, f.active ? "active" : s), o && (p.options.radius = 0)), this.updateElement(f, u, p, s) } } resolveDataElementOptions(t, e) { const i = this.getParsed(t); let s = super.resolveDataElementOptions(t, e); s.$shared && (s = Object.assign({}, s, { $shared: !1 })); const o = s.radius; return "active" !== e && (s.radius = 0), s.radius += C(i && i._custom, o), s } } function Co(n, t, e) { let i = 1, s = 1, o = 0, a = 0; if (t < Y) { const r = n, l = r + t, c = Math.cos(r), h = Math.sin(r), d = Math.cos(l), u = Math.sin(l), f = (v, y, _) => fe(v, r, l, !0) ? 1 : Math.max(y, y * e, _, _ * e), g = (v, y, _) => fe(v, r, l, !0) ? -1 : Math.min(y, y * e, _, _ * e), p = f(0, c, d), b = f(Q, h, u), m = g(rt, c, d), x = g(rt + Q, h, u); i = (p - m) / 2, s = (b - x) / 2, o = -(p + m) / 2, a = -(b + x) / 2 } return { ratioX: i, ratioY: s, offsetX: o, offsetY: a } } k(Kt, "id", "bubble"), k(Kt, "defaults", { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }), k(Kt, "overrides", { scales: { x: { type: "linear" }, y: { type: "linear" } } }); class ft extends tt { constructor(t, e) { super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales() { } parse(t, e) { const i = this.getDataset().data, s = this._cachedMeta; if (!1 === this._parsing) s._parsed = i; else { let a, r, o = l => +i[l]; if (F(i[t])) { const { key: l = "value" } = this._parsing; o = c => +Pt(i[c], l) } for (a = t, r = t + e; a < r; ++a)s._parsed[a] = o(a) } } _getRotation() { return st(this.options.rotation - 90) } _getCircumference() { return st(this.options.circumference) } _getRotationExtents() { let t = Y, e = -Y; for (let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) { const s = this.chart.getDatasetMeta(i).controller, o = s._getRotation(), a = s._getCircumference(); t = Math.min(t, o), e = Math.max(e, o + a) } return { rotation: t, circumference: e - t } } update(t) { const e = this.chart, { chartArea: i } = e, s = this._cachedMeta, o = s.data, a = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, r = Math.max((Math.min(i.width, i.height) - a) / 2, 0), l = Math.min(Pn(this.options.cutout, r), 1), c = this._getRingWeight(this.index), { circumference: h, rotation: d } = this._getRotationExtents(), { ratioX: u, ratioY: f, offsetX: g, offsetY: p } = Co(d, h, l), x = Math.max(Math.min((i.width - a) / u, (i.height - a) / f) / 2, 0), v = An(this.options.radius, x), _ = (v - Math.max(v * l, 0)) / this._getVisibleDatasetWeightTotal(); this.offsetX = g * v, this.offsetY = p * v, s.total = this.calculateTotal(), this.outerRadius = v - _ * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - _ * c, 0), this.updateElements(o, 0, o.length, t) } _circumference(t, e) { const i = this.options, s = this._cachedMeta, o = this._getCircumference(); return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * o / Y) } updateElements(t, e, i, s) { const o = "reset" === s, a = this.chart, r = a.chartArea, h = (r.left + r.right) / 2, d = (r.top + r.bottom) / 2, u = o && a.options.animation.animateScale, f = u ? 0 : this.innerRadius, g = u ? 0 : this.outerRadius, { sharedOptions: p, includeOptions: b } = this._getSharedOptions(e, s); let x, m = this._getRotation(); for (x = 0; x < e; ++x)m += this._circumference(x, o); for (x = e; x < e + i; ++x) { const v = this._circumference(x, o), y = t[x], _ = { x: h + this.offsetX, y: d + this.offsetY, startAngle: m, endAngle: m + v, circumference: v, outerRadius: g, innerRadius: f }; b && (_.options = p || this.resolveDataElementOptions(x, y.active ? "active" : s)), m += v, this.updateElement(y, x, _, s) } } calculateTotal() { const t = this._cachedMeta, e = t.data; let s, i = 0; for (s = 0; s < e.length; s++) { const o = t._parsed[s]; null !== o && !isNaN(o) && this.chart.getDataVisibility(s) && !e[s].hidden && (i += Math.abs(o)) } return i } calculateCircumference(t) { const e = this._cachedMeta.total; return e > 0 && !isNaN(t) ? Y * (Math.abs(t) / e) : 0 } getLabelAndValue(t) { const i = this.chart, s = i.data.labels || [], o = ue(this._cachedMeta._parsed[t], i.options.locale); return { label: s[t] || "", value: o } } getMaxBorderWidth(t) { let e = 0; const i = this.chart; let s, o, a, r, l; if (!t) for (s = 0, o = i.data.datasets.length; s < o; ++s)if (i.isDatasetVisible(s)) { a = i.getDatasetMeta(s), t = a.data, r = a.controller; break } if (!t) return 0; for (s = 0, o = t.length; s < o; ++s)l = r.resolveDataElementOptions(s), "inner" !== l.borderAlign && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0)); return e } getMaxOffset(t) { let e = 0; for (let i = 0, s = t.length; i < s; ++i) { const o = this.resolveDataElementOptions(i); e = Math.max(e, o.offset || 0, o.hoverOffset || 0) } return e } _getRingWeightOffset(t) { let e = 0; for (let i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i)); return e } _getRingWeight(t) { return Math.max(C(this.chart.data.datasets[t].weight, 1), 0) } _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } } k(ft, "id", "doughnut"), k(ft, "defaults", { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", spacing: 0, indexAxis: "r" }), k(ft, "descriptors", { _scriptable: t => "spacing" !== t, _indexable: t => "spacing" !== t && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash") }), k(ft, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const e = t.data; if (e.labels.length && e.datasets.length) { const { labels: { pointStyle: i, color: s } } = t.legend.options; return e.labels.map((o, a) => { const l = t.getDatasetMeta(0).controller.getStyle(a); return { text: o, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: s, lineWidth: l.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(a), index: a } }) } return [] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } } } }); class Gt extends tt { initialize() { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update(t) { const e = this._cachedMeta, { dataset: i, data: s = [], _dataset: o } = e, a = this.chart._animationsDisabled; let { start: r, count: l } = pi(e, s, a); this._drawStart = r, this._drawCount = l, mi(e) && (r = 0, l = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!o._decimated, i.points = s; const c = this.resolveDatasetElementOptions(t); this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(i, void 0, { animated: !a, options: c }, t), this.updateElements(s, r, l, t) } updateElements(t, e, i, s) { const o = "reset" === s, { iScale: a, vScale: r, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: h, includeOptions: d } = this._getSharedOptions(e, s), u = a.axis, f = r.axis, { spanGaps: g, segment: p } = this.options, b = At(g) ? g : Number.POSITIVE_INFINITY, m = this.chart._animationsDisabled || o || "none" === s, x = e + i, v = t.length; let y = e > 0 && this.getParsed(e - 1); for (let _ = 0; _ < v; ++_) { const M = t[_], w = m ? M : {}; if (_ < e || _ >= x) { w.skip = !0; continue } const S = this.getParsed(_), D = O(S[f]), P = w[u] = a.getPixelForValue(S[u], _), A = w[f] = o || D ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, S, l) : S[f], _); w.skip = isNaN(P) || isNaN(A) || D, w.stop = _ > 0 && Math.abs(S[u] - y[u]) > b, p && (w.parsed = S, w.raw = c.data[_]), d && (w.options = h || this.resolveDataElementOptions(_, M.active ? "active" : s)), m || this.updateElement(M, _, w, s), y = S } } getMaxOverflow() { const t = this._cachedMeta, e = t.dataset, i = e.options && e.options.borderWidth || 0, s = t.data || []; if (!s.length) return i; const o = s[0].size(this.resolveDataElementOptions(0)), a = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1)); return Math.max(i, o, a) / 2 } draw() { const t = this._cachedMeta; t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw() } } k(Gt, "id", "line"), k(Gt, "defaults", { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }), k(Gt, "overrides", { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }); class Ot extends tt { constructor(t, e) { super(t, e), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue(t) { const i = this.chart, s = i.data.labels || [], o = ue(this._cachedMeta._parsed[t].r, i.options.locale); return { label: s[t] || "", value: o } } parseObjectData(t, e, i, s) { return bi.bind(this)(t, e, i, s) } update(t) { const e = this._cachedMeta.data; this._updateRadius(), this.updateElements(e, 0, e.length, t) } getMinMax() { const e = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; return this._cachedMeta.data.forEach((i, s) => { const o = this.getParsed(s).r; !isNaN(o) && this.chart.getDataVisibility(s) && (o < e.min && (e.min = o), o > e.max && (e.max = o)) }), e } _updateRadius() { const t = this.chart, e = t.chartArea, i = t.options, s = Math.min(e.right - e.left, e.bottom - e.top), o = Math.max(s / 2, 0), r = (o - Math.max(i.cutoutPercentage ? o / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount(); this.outerRadius = o - r * this.index, this.innerRadius = this.outerRadius - r } updateElements(t, e, i, s) { const o = "reset" === s, a = this.chart, l = a.options.animation, c = this._cachedMeta.rScale, h = c.xCenter, d = c.yCenter, u = c.getIndexAngle(0) - .5 * rt; let g, f = u; const p = 360 / this.countVisibleElements(); for (g = 0; g < e; ++g)f += this._computeAngle(g, s, p); for (g = e; g < e + i; g++) { const b = t[g]; let m = f, x = f + this._computeAngle(g, s, p), v = a.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0; f = x, o && (l.animateScale && (v = 0), l.animateRotate && (m = x = u)); const y = { x: h, y: d, innerRadius: 0, outerRadius: v, startAngle: m, endAngle: x, options: this.resolveDataElementOptions(g, b.active ? "active" : s) }; this.updateElement(b, g, y, s) } } countVisibleElements() { let e = 0; return this._cachedMeta.data.forEach((i, s) => { !isNaN(this.getParsed(s).r) && this.chart.getDataVisibility(s) && e++ }), e } _computeAngle(t, e, i) { return this.chart.getDataVisibility(t) ? st(this.resolveDataElementOptions(t, e).angle || i) : 0 } } k(Ot, "id", "polarArea"), k(Ot, "defaults", { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }), k(Ot, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const e = t.data; if (e.labels.length && e.datasets.length) { const { labels: { pointStyle: i, color: s } } = t.legend.options; return e.labels.map((o, a) => { const l = t.getDatasetMeta(0).controller.getStyle(a); return { text: o, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: s, lineWidth: l.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(a), index: a } }) } return [] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }); class ye extends ft { } k(ye, "id", "pie"), k(ye, "defaults", { cutout: 0, rotation: 0, circumference: 360, radius: "100%" }); class qt extends tt { getLabelAndValue(t) { const e = this._cachedMeta.vScale, i = this.getParsed(t); return { label: e.getLabels()[t], value: "" + e.getLabelForValue(i[e.axis]) } } parseObjectData(t, e, i, s) { return bi.bind(this)(t, e, i, s) } update(t) { const e = this._cachedMeta, i = e.dataset, s = e.data || [], o = e.iScale.getLabels(); if (i.points = s, "resize" !== t) { const a = this.resolveDatasetElementOptions(t); this.options.showLine || (a.borderWidth = 0), this.updateElement(i, void 0, { _loop: !0, _fullLoop: o.length === s.length, options: a }, t) } this.updateElements(s, 0, s.length, t) } updateElements(t, e, i, s) { const o = this._cachedMeta.rScale, a = "reset" === s; for (let r = e; r < e + i; r++) { const l = t[r], c = this.resolveDataElementOptions(r, l.active ? "active" : s), h = o.getPointPositionForValue(r, this.getParsed(r).r), d = a ? o.xCenter : h.x, u = a ? o.yCenter : h.y, f = { x: d, y: u, angle: h.angle, skip: isNaN(d) || isNaN(u), options: c }; this.updateElement(l, r, f, s) } } } k(qt, "id", "radar"), k(qt, "defaults", { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: !0, elements: { line: { fill: "start" } } }), k(qt, "overrides", { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }); class Jt extends tt { getLabelAndValue(t) { const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: o } = e, a = this.getParsed(t), r = s.getLabelForValue(a.x), l = o.getLabelForValue(a.y); return { label: i[t] || "", value: "(" + r + ", " + l + ")" } } update(t) { const e = this._cachedMeta, { data: i = [] } = e, s = this.chart._animationsDisabled; let { start: o, count: a } = pi(e, i, s); if (this._drawStart = o, this._drawCount = a, mi(e) && (o = 0, a = i.length), this.options.showLine) { const { dataset: r, _dataset: l } = e; r._chart = this.chart, r._datasetIndex = this.index, r._decimated = !!l._decimated, r.points = i; const c = this.resolveDatasetElementOptions(t); c.segment = this.options.segment, this.updateElement(r, void 0, { animated: !s, options: c }, t) } this.updateElements(i, o, a, t) } addElements() { const { showLine: t } = this.options; !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements() } updateElements(t, e, i, s) { const o = "reset" === s, { iScale: a, vScale: r, _stacked: l, _dataset: c } = this._cachedMeta, h = this.resolveDataElementOptions(e, s), d = this.getSharedOptions(h), u = this.includeOptions(s, d), f = a.axis, g = r.axis, { spanGaps: p, segment: b } = this.options, m = At(p) ? p : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || "none" === s; let v = e > 0 && this.getParsed(e - 1); for (let y = e; y < e + i; ++y) { const _ = t[y], M = this.getParsed(y), w = x ? _ : {}, S = O(M[g]), D = w[f] = a.getPixelForValue(M[f], y), P = w[g] = o || S ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, M, l) : M[g], y); w.skip = isNaN(D) || isNaN(P) || S, w.stop = y > 0 && Math.abs(M[f] - v[f]) > m, b && (w.parsed = M, w.raw = c.data[y]), u && (w.options = d || this.resolveDataElementOptions(y, _.active ? "active" : s)), x || this.updateElement(_, y, w, s), v = M } this.updateSharedOptions(d, s, h) } getMaxOverflow() { const t = this._cachedMeta, e = t.data || []; if (!this.options.showLine) { let r = 0; for (let l = e.length - 1; l >= 0; --l)r = Math.max(r, e[l].size(this.resolveDataElementOptions(l)) / 2); return r > 0 && r } const i = t.dataset, s = i.options && i.options.borderWidth || 0; if (!e.length) return s; const o = e[0].size(this.resolveDataElementOptions(0)), a = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1)); return Math.max(s, o, a) / 2 } } k(Jt, "id", "scatter"), k(Jt, "defaults", { datasetElementType: !1, dataElementType: "point", showLine: !1, fill: !1 }), k(Jt, "overrides", { interaction: { mode: "point" }, scales: { x: { type: "linear" }, y: { type: "linear" } } }); var Ki = Object.freeze({ __proto__: null, BarController: Xt, BubbleController: Kt, DoughnutController: ft, LineController: Gt, PieController: ye, PolarAreaController: Ot, RadarController: qt, ScatterController: Jt }); function Mt() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class ci { constructor(t) { k(this, "options"), this.options = t || {} } static override(t) { Object.assign(ci.prototype, t) } init() { } formats() { return Mt() } parse() { return Mt() } format() { return Mt() } add() { return Mt() } diff() { return Mt() } startOf() { return Mt() } endOf() { return Mt() } } var Gi = { _date: ci }; function Lo(n, t, e, i) { const { controller: s, data: o, _sorted: a } = n, r = s._cachedMeta.iScale; if (r && t === r.axis && "r" !== t && a && o.length) { const l = r._reversePixels ? Cn : Wt; if (!i) return l(o, t, e); if (s._sharedOptions) { const c = o[0], h = "function" == typeof c.getRange && c.getRange(t); if (h) { const d = l(o, t, e - h), u = l(o, t, e + h); return { lo: d.lo, hi: u.hi } } } } return { lo: 0, hi: o.length - 1 } } function Zt(n, t, e, i, s) { const o = n.getSortedVisibleDatasetMetas(), a = e[t]; for (let r = 0, l = o.length; r < l; ++r) { const { index: c, data: h } = o[r], { lo: d, hi: u } = Lo(o[r], t, a, s); for (let f = d; f <= u; ++f) { const g = h[f]; g.skip || i(g, c, f) } } } function Oo(n) { const t = -1 !== n.indexOf("x"), e = -1 !== n.indexOf("y"); return function (i, s) { const o = t ? Math.abs(i.x - s.x) : 0, a = e ? Math.abs(i.y - s.y) : 0; return Math.sqrt(Math.pow(o, 2) + Math.pow(a, 2)) } } function Xe(n, t, e, i, s) { const o = []; return !s && !n.isPointInArea(t) || Zt(n, e, t, function (r, l, c) { !s && !_t(r, n.chartArea, 0) || r.inRange(t.x, t.y, i) && o.push({ element: r, datasetIndex: l, index: c }) }, !0), o } function To(n, t, e, i) { let s = []; return Zt(n, e, t, function o(a, r, l) { const { startAngle: c, endAngle: h } = a.getProps(["startAngle", "endAngle"], i), { angle: d } = xi(a, { x: t.x, y: t.y }); fe(d, c, h) && s.push({ element: a, datasetIndex: r, index: l }) }), s } function Ro(n, t, e, i, s, o) { let a = []; const r = Oo(e); let l = Number.POSITIVE_INFINITY; return Zt(n, e, t, function c(h, d, u) { const f = h.inRange(t.x, t.y, s); if (i && !f) return; const g = h.getCenterPoint(s); if (!o && !n.isPointInArea(g) && !f) return; const b = r(t, g); b < l ? (a = [{ element: h, datasetIndex: d, index: u }], l = b) : b === l && a.push({ element: h, datasetIndex: d, index: u }) }), a } function Ke(n, t, e, i, s, o) { return o || n.isPointInArea(t) ? "r" !== e || i ? Ro(n, t, e, i, s, o) : To(n, t, e, s) : [] } function qi(n, t, e, i, s) { const o = [], a = "x" === e ? "inXRange" : "inYRange"; let r = !1; return Zt(n, e, t, (l, c, h) => { l[a](t[e], s) && (o.push({ element: l, datasetIndex: c, index: h }), r = r || l.inRange(t.x, t.y, s)) }), i && !r ? [] : o } var Ji = { evaluateInteractionItems: Zt, modes: { index(n, t, e, i) { const s = xt(t, n), o = e.axis || "x", a = e.includeInvisible || !1, r = e.intersect ? Xe(n, s, o, i, a) : Ke(n, s, o, !1, i, a), l = []; return r.length ? (n.getSortedVisibleDatasetMetas().forEach(c => { const h = r[0].index, d = c.data[h]; d && !d.skip && l.push({ element: d, datasetIndex: c.index, index: h }) }), l) : [] }, dataset(n, t, e, i) { const s = xt(t, n), o = e.axis || "xy", a = e.includeInvisible || !1; let r = e.intersect ? Xe(n, s, o, i, a) : Ke(n, s, o, !1, i, a); if (r.length > 0) { const l = r[0].datasetIndex, c = n.getDatasetMeta(l).data; r = []; for (let h = 0; h < c.length; ++h)r.push({ element: c[h], datasetIndex: l, index: h }) } return r }, point: (n, t, e, i) => Xe(n, xt(t, n), e.axis || "xy", i, e.includeInvisible || !1), nearest: (n, t, e, i) => Ke(n, xt(t, n), e.axis || "xy", e.intersect, i, e.includeInvisible || !1), x: (n, t, e, i) => qi(n, xt(t, n), "x", e.intersect, i), y: (n, t, e, i) => qi(n, xt(t, n), "y", e.intersect, i) } }; const Zi = ["left", "top", "right", "bottom"]; function Qt(n, t) { return n.filter(e => e.pos === t) } function Qi(n, t) { return n.filter(e => -1 === Zi.indexOf(e.pos) && e.box.axis === t) } function te(n, t) { return n.sort((e, i) => { const s = t ? i : e, o = t ? e : i; return s.weight === o.weight ? s.index - o.index : s.weight - o.weight }) } function Eo(n) { const t = []; let e, i, s, o, a, r; for (e = 0, i = (n || []).length; e < i; ++e)s = n[e], ({ position: o, options: { stack: a, stackWeight: r = 1 } } = s), t.push({ index: e, box: s, pos: o, horizontal: s.isHorizontal(), weight: s.weight, stack: a && o + a, stackWeight: r }); return t } function zo(n) { const t = {}; for (const e of n) { const { stack: i, pos: s, stackWeight: o } = e; if (!i || !Zi.includes(s)) continue; const a = t[i] || (t[i] = { count: 0, placed: 0, weight: 0, size: 0 }); a.count++, a.weight += o } return t } function Fo(n, t) { const e = zo(n), { vBoxMaxWidth: i, hBoxMaxHeight: s } = t; let o, a, r; for (o = 0, a = n.length; o < a; ++o) { r = n[o]; const { fullSize: l } = r.box, c = e[r.stack], h = c && r.stackWeight / c.weight; r.horizontal ? (r.width = h ? h * i : l && t.availableWidth, r.height = s) : (r.width = i, r.height = h ? h * s : l && t.availableHeight) } return e } function Io(n) { const t = Eo(n), e = te(t.filter(c => c.box.fullSize), !0), i = te(Qt(t, "left"), !0), s = te(Qt(t, "right")), o = te(Qt(t, "top"), !0), a = te(Qt(t, "bottom")), r = Qi(t, "x"), l = Qi(t, "y"); return { fullSize: e, leftAndTop: i.concat(o), rightAndBottom: s.concat(l).concat(a).concat(r), chartArea: Qt(t, "chartArea"), vertical: i.concat(s).concat(l), horizontal: o.concat(a).concat(r) } } function ts(n, t, e, i) { return Math.max(n[e], t[e]) + Math.max(n[i], t[i]) } function es(n, t) { n.top = Math.max(n.top, t.top), n.left = Math.max(n.left, t.left), n.bottom = Math.max(n.bottom, t.bottom), n.right = Math.max(n.right, t.right) } function Bo(n, t, e, i) { const { pos: s, box: o } = e, a = n.maxPadding; if (!F(s)) { e.size && (n[s] -= e.size); const d = i[e.stack] || { size: 0, count: 1 }; d.size = Math.max(d.size, e.horizontal ? o.height : o.width), e.size = d.size / d.count, n[s] += e.size } o.getPadding && es(a, o.getPadding()); const r = Math.max(0, t.outerWidth - ts(a, n, "left", "right")), l = Math.max(0, t.outerHeight - ts(a, n, "top", "bottom")), c = r !== n.w, h = l !== n.h; return n.w = r, n.h = l, e.horizontal ? { same: c, other: h } : { same: h, other: c } } function Vo(n) { const t = n.maxPadding; function e(i) { const s = Math.max(t[i] - n[i], 0); return n[i] += s, s } n.y += e("top"), n.x += e("left"), e("right"), e("bottom") } function No(n, t) { const e = t.maxPadding; return function i(s) { const o = { left: 0, top: 0, right: 0, bottom: 0 }; return s.forEach(a => { o[a] = Math.max(t[a], e[a]) }), o }(n ? ["left", "right"] : ["top", "bottom"]) } function ee(n, t, e, i) { const s = []; let o, a, r, l, c, h; for (o = 0, a = n.length, c = 0; o < a; ++o) { r = n[o], l = r.box, l.update(r.width || t.w, r.height || t.h, No(r.horizontal, t)); const { same: d, other: u } = Bo(t, e, r, i); c |= d && s.length, h = h || u, l.fullSize || s.push(r) } return c && ee(s, t, e, i) || h } function ve(n, t, e, i, s) { n.top = e, n.left = t, n.right = t + i, n.bottom = e + s, n.width = i, n.height = s } function is(n, t, e, i) { const s = e.padding; let { x: o, y: a } = t; for (const r of n) { const l = r.box, c = i[r.stack] || { count: 1, placed: 0, weight: 1 }, h = r.stackWeight / c.weight || 1; if (r.horizontal) { const d = t.w * h, u = c.size || l.height; Ht(c.start) && (a = c.start), l.fullSize ? ve(l, s.left, a, e.outerWidth - s.right - s.left, u) : ve(l, t.left + c.placed, a, d, u), c.start = a, c.placed += d, a = l.bottom } else { const d = t.h * h, u = c.size || l.width; Ht(c.start) && (o = c.start), l.fullSize ? ve(l, o, s.top, u, e.outerHeight - s.bottom - s.top) : ve(l, o, t.top + c.placed, u, d), c.start = o, c.placed += d, o = l.right } } t.x = o, t.y = a } var W = { addBox(n, t) { n.boxes || (n.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function () { return [{ z: 0, draw(e) { t.draw(e) } }] }, n.boxes.push(t) }, removeBox(n, t) { const e = n.boxes ? n.boxes.indexOf(t) : -1; -1 !== e && n.boxes.splice(e, 1) }, configure(n, t, e) { t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight }, update(n, t, e, i) { if (!n) return; const s = $(n.options.layout.padding), o = Math.max(t - s.width, 0), a = Math.max(e - s.height, 0), r = Io(n.boxes), l = r.vertical, c = r.horizontal; T(n.boxes, p => { "function" == typeof p.beforeLayout && p.beforeLayout() }); const h = l.reduce((p, b) => b.box.options && !1 === b.box.options.display ? p : p + 1, 0) || 1, d = Object.freeze({ outerWidth: t, outerHeight: e, padding: s, availableWidth: o, availableHeight: a, vBoxMaxWidth: o / 2 / h, hBoxMaxHeight: a / 2 }), u = Object.assign({}, s); es(u, $(i)); const f = Object.assign({ maxPadding: u, w: o, h: a, x: s.left, y: s.top }, s), g = Fo(l.concat(c), d); ee(r.fullSize, f, d, g), ee(l, f, d, g), ee(c, f, d, g) && ee(l, f, d, g), Vo(f), is(r.leftAndTop, f, d, g), f.x += f.w, f.y += f.h, is(r.rightAndBottom, f, d, g), n.chartArea = { left: f.left, top: f.top, right: f.left + f.w, bottom: f.top + f.h, height: f.h, width: f.w }, T(r.chartArea, p => { const b = p.box; Object.assign(b, n.chartArea), b.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class Ge { acquireContext(t, e) { } releaseContext(t) { return !1 } addEventListener(t, e, i) { } removeEventListener(t, e, i) { } getDevicePixelRatio() { return 1 } getMaximumSize(t, e, i, s) { return e = Math.max(0, e || t.width), i = i || t.height, { width: e, height: Math.max(0, s ? Math.floor(e / s) : i) } } isAttached(t) { return !0 } updateConfig(t) { } } class ss extends Ge { acquireContext(t) { return t && t.getContext && t.getContext("2d") || null } updateConfig(t) { t.options.animation = !1 } } const ke = "$chartjs", Ho = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, ns = n => null === n || "" === n; function Wo(n, t) { const e = n.style, i = n.getAttribute("height"), s = n.getAttribute("width"); if (n[ke] = { initial: { height: i, width: s, style: { display: e.display, height: e.height, width: e.width } } }, e.display = e.display || "block", e.boxSizing = e.boxSizing || "border-box", ns(s)) { const o = yi(n, "width"); void 0 !== o && (n.width = o) } if (ns(i)) if ("" === n.style.height) n.height = n.width / (t || 2); else { const o = yi(n, "height"); void 0 !== o && (n.height = o) } return n } const os = !!On && { passive: !0 }; function jo(n, t, e) { n.addEventListener(t, e, os) } function $o(n, t, e) { n.canvas.removeEventListener(t, e, os) } function Uo(n, t) { const e = Ho[n.type] || n.type, { x: i, y: s } = xt(n, t); return { type: e, chart: t, native: n, x: void 0 !== i ? i : null, y: void 0 !== s ? s : null } } function Me(n, t) { for (const e of n) if (e === t || e.contains(t)) return !0 } function Yo(n, t, e) { const i = n.canvas, s = new MutationObserver(o => { let a = !1; for (const r of o) a = a || Me(r.addedNodes, i), a = a && !Me(r.removedNodes, i); a && e() }); return s.observe(document, { childList: !0, subtree: !0 }), s } function Xo(n, t, e) { const i = n.canvas, s = new MutationObserver(o => { let a = !1; for (const r of o) a = a || Me(r.removedNodes, i), a = a && !Me(r.addedNodes, i); a && e() }); return s.observe(document, { childList: !0, subtree: !0 }), s } const ie = new Map; let as = 0; function rs() { const n = window.devicePixelRatio; n !== as && (as = n, ie.forEach((t, e) => { e.currentDevicePixelRatio !== n && t() })) } function Ko(n, t) { ie.size || window.addEventListener("resize", rs), ie.set(n, t) } function Go(n) { ie.delete(n), ie.size || window.removeEventListener("resize", rs) } function qo(n, t, e) { const i = n.canvas, s = i && _i(i); if (!s) return; const o = vi((r, l) => { const c = s.clientWidth; e(r, l), c < s.clientWidth && e() }, window), a = new ResizeObserver(r => { const l = r[0], c = l.contentRect.width, h = l.contentRect.height; 0 === c && 0 === h || o(c, h) }); return a.observe(s), Ko(n, o), a } function qe(n, t, e) { e && e.disconnect(), "resize" === t && Go(n) } function Jo(n, t, e) { const i = n.canvas, s = vi(o => { null !== n.ctx && e(Uo(o, n)) }, n); return jo(i, t, s), s } class ls extends Ge { acquireContext(t, e) { const i = t && t.getContext && t.getContext("2d"); return i && i.canvas === t ? (Wo(t, e), i) : null } releaseContext(t) { const e = t.canvas; if (!e[ke]) return !1; const i = e[ke].initial;["height", "width"].forEach(o => { const a = i[o]; O(a) ? e.removeAttribute(o) : e.setAttribute(o, a) }); const s = i.style || {}; return Object.keys(s).forEach(o => { e.style[o] = s[o] }), e.width = e.width, delete e[ke], !0 } addEventListener(t, e, i) { this.removeEventListener(t, e), (t.$proxies || (t.$proxies = {}))[e] = ({ attach: Yo, detach: Xo, resize: qo }[e] || Jo)(t, e, i) } removeEventListener(t, e) { const i = t.$proxies || (t.$proxies = {}), s = i[e]; s && (({ attach: qe, detach: qe, resize: qe }[e] || $o)(t, e, s), i[e] = void 0) } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(t, e, i, s) { return Ln(t, e, i, s) } isAttached(t) { const e = _i(t); return !(!e || !e.isConnected) } } function cs(n) { return !ki() || "undefined" != typeof OffscreenCanvas && n instanceof OffscreenCanvas ? ss : ls } class et { constructor() { k(this, "x"), k(this, "y"), k(this, "active", !1), k(this, "options"), k(this, "$animations") } tooltipPosition(t) { const { x: e, y: i } = this.getProps(["x", "y"], t); return { x: e, y: i } } hasValue() { return At(this.x) && At(this.y) } getProps(t, e) { const i = this.$animations; if (!e || !i) return this; const s = {}; return t.forEach(o => { s[o] = i[o] && i[o].active() ? i[o]._to : this[o] }), s } } function Zo(n, t) { const e = n.options.ticks, i = Qo(n), s = Math.min(e.maxTicksLimit || i, i), o = e.major.enabled ? ea(t) : [], a = o.length, r = o[0], l = o[a - 1], c = []; if (a > s) return ia(t, c, o, a / s), c; const h = ta(o, t, s); if (a > 0) { let d, u; const f = a > 1 ? Math.round((l - r) / (a - 1)) : null; for (we(t, c, h, O(f) ? 0 : r - f, r), d = 0, u = a - 1; d < u; d++)we(t, c, h, o[d], o[d + 1]); return we(t, c, h, l, O(f) ? t.length : l + f), c } return we(t, c, h), c } function Qo(n) { const t = n.options.offset, e = n._tickSize(); return Math.floor(Math.min(n._length / e + (t ? 0 : 1), n._maxLength / e)) } function ta(n, t, e) { const i = sa(n), s = t.length / e; if (!i) return Math.max(s, 1); const o = Tn(i); for (let a = 0, r = o.length - 1; a < r; a++) { const l = o[a]; if (l > s) return l } return Math.max(s, 1) } function ea(n) { const t = []; let e, i; for (e = 0, i = n.length; e < i; e++)n[e].major && t.push(e); return t } function ia(n, t, e, i) { let a, s = 0, o = e[0]; for (i = Math.ceil(i), a = 0; a < n.length; a++)a === o && (t.push(n[a]), s++, o = e[s * i]) } function we(n, t, e, i, s) { const o = C(i, 0), a = Math.min(C(s, n.length), n.length); let l, c, h, r = 0; for (e = Math.ceil(e), s && (l = s - i, e = l / Math.floor(l / e)), h = o; h < 0;)r++, h = Math.round(o + r * e); for (c = Math.max(o, 0); c < a; c++)c === h && (t.push(n[c]), r++, h = Math.round(o + r * e)) } function sa(n) { const t = n.length; let e, i; if (t < 2) return !1; for (i = n[0], e = 1; e < t; ++e)if (n[e] - n[e - 1] !== i) return !1; return i } k(et, "defaults", {}), k(et, "defaultRoutes"); const na = n => "left" === n ? "right" : "right" === n ? "left" : n, hs = (n, t, e) => "top" === t || "left" === t ? n[t] + e : n[t] - e, ds = (n, t) => Math.min(t || n, n); function us(n, t) { const e = [], i = n.length / t, s = n.length; let o = 0; for (; o < s; o += i)e.push(n[Math.floor(o)]); return e } function oa(n, t, e) { const i = n.ticks.length, s = Math.min(t, i - 1), o = n._startPixel, a = n._endPixel, r = 1e-6; let c, l = n.getPixelForTick(s); if (!(e && (c = 1 === i ? Math.max(l - o, a - l) : 0 === t ? (n.getPixelForTick(1) - l) / 2 : (l - n.getPixelForTick(s - 1)) / 2, l += s < t ? c : -c, l < o - r || l > a + r))) return l } function aa(n, t) { T(n, e => { const i = e.gc, s = i.length / 2; let o; if (s > t) { for (o = 0; o < s; ++o)delete e.data[i[o]]; i.splice(0, s) } }) } function se(n) { return n.drawTicks ? n.tickLength : 0 } function fs(n, t) { if (!n.display) return 0; const e = N(n.font, t), i = $(n.padding); return (K(n.text) ? n.text.length : 1) * e.lineHeight + i.height } function ra(n, t) { return bt(n, { scale: t, type: "scale" }) } function la(n, t, e) { return bt(n, { tick: e, index: t, type: "tick" }) } function ca(n, t, e) { let i = Ne(n); return (e && "right" !== t || !e && "right" === t) && (i = na(i)), i } function ha(n, t, e, i) { const { top: s, left: o, bottom: a, right: r, chart: l } = n, { chartArea: c, scales: h } = l; let u, f, g, d = 0; const p = a - s, b = r - o; if (n.isHorizontal()) { if (f = U(i, o, r), F(e)) { const m = Object.keys(e)[0]; g = h[m].getPixelForValue(e[m]) + p - t } else g = "center" === e ? (c.bottom + c.top) / 2 + p - t : hs(n, e, t); u = r - o } else { if (F(e)) { const m = Object.keys(e)[0]; f = h[m].getPixelForValue(e[m]) - b + t } else f = "center" === e ? (c.left + c.right) / 2 - b + t : hs(n, e, t); g = U(i, a, s), d = "left" === e ? -Q : Q } return { titleX: f, titleY: g, maxWidth: u, rotation: d } } class mt extends et { constructor(t) { super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(t) { this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax) } parse(t, e) { return t } getUserBounds() { let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: s } = this; return t = Z(t, Number.POSITIVE_INFINITY), e = Z(e, Number.NEGATIVE_INFINITY), i = Z(i, Number.POSITIVE_INFINITY), s = Z(s, Number.NEGATIVE_INFINITY), { min: Z(t, i), max: Z(e, s), minDefined: V(t), maxDefined: V(e) } } getMinMax(t) { let a, { min: e, max: i, minDefined: s, maxDefined: o } = this.getUserBounds(); if (s && o) return { min: e, max: i }; const r = this.getMatchingVisibleMetas(); for (let l = 0, c = r.length; l < c; ++l)a = r[l].controller.getMinMax(this, t), s || (e = Math.min(e, a.min)), o || (i = Math.max(i, a.max)); return e = o && e > i ? i : e, i = s && e > i ? e : i, { min: Z(e, Z(i, e)), max: Z(i, Z(e, i)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [] } getLabelItems(t = this.chart.chartArea) { return this._labelItems || (this._labelItems = this._computeLabelItems(t)) } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { E(this.options.beforeUpdate, [this]) } update(t, e, i) { const { beginAtZero: s, grace: o, ticks: a } = this.options, r = a.sampleSize; this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Rn(this, o, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = r < this.ticks.length; this._convertTicksToLabels(l ? us(this.ticks, r) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), a.display && (a.autoSkip || "auto" === a.source) && (this.ticks = Zo(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let e, i, t = this.options.reverse; this.isHorizontal() ? (e = this.left, i = this.right) : (e = this.top, i = this.bottom, t = !t), this._startPixel = e, this._endPixel = i, this._reversePixels = t, this._length = i - e, this._alignToPixels = this.options.alignToPixels } afterUpdate() { E(this.options.afterUpdate, [this]) } beforeSetDimensions() { E(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { E(this.options.afterSetDimensions, [this]) } _callHooks(t) { this.chart.notifyPlugins(t, this.getContext()), E(this.options[t], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { E(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(t) { const e = this.options.ticks; let i, s, o; for (i = 0, s = t.length; i < s; i++)o = t[i], o.label = E(e.callback, [o.value, i, t], this) } afterTickToLabelConversion() { E(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { E(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const t = this.options, e = t.ticks, i = ds(this.ticks.length, t.ticks.maxTicksLimit), s = e.minRotation || 0, o = e.maxRotation; let r, l, c, a = s; if (!this._isVisible() || !e.display || s >= o || i <= 1 || !this.isHorizontal()) return void (this.labelRotation = s); const h = this._getLabelSizes(), d = h.widest.width, u = h.highest.height, f = X(this.chart.width - d, 0, this.maxWidth); r = t.offset ? this.maxWidth / i : f / (i - 1), d + 6 > r && (r = f / (i - (t.offset ? .5 : 1)), l = this.maxHeight - se(t.grid) - e.padding - fs(t.title, this.chart.options.font), c = Math.sqrt(d * d + u * u), a = Ve(Math.min(Math.asin(X((h.highest.height + 6) / r, -1, 1)), Math.asin(X(l / c, -1, 1)) - Math.asin(X(u / c, -1, 1)))), a = Math.max(s, Math.min(o, a))), this.labelRotation = a } afterCalculateLabelRotation() { E(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { E(this.options.beforeFit, [this]) } fit() { const t = { width: 0, height: 0 }, { chart: e, options: { ticks: i, title: s, grid: o } } = this, a = this._isVisible(), r = this.isHorizontal(); if (a) { const l = fs(s, e.options.font); if (r ? (t.width = this.maxWidth, t.height = se(o) + l) : (t.height = this.maxHeight, t.width = se(o) + l), i.display && this.ticks.length) { const { first: c, last: h, widest: d, highest: u } = this._getLabelSizes(), f = 2 * i.padding, g = st(this.labelRotation), p = Math.cos(g), b = Math.sin(g); r ? t.height = Math.min(this.maxHeight, t.height + (i.mirror ? 0 : b * d.width + p * u.height) + f) : t.width = Math.min(this.maxWidth, t.width + (i.mirror ? 0 : p * d.width + b * u.height) + f), this._calculatePadding(c, h, b, p) } } this._handleMargins(), r ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom) } _calculatePadding(t, e, i, s) { const { ticks: { align: o, padding: a }, position: r } = this.options, l = 0 !== this.labelRotation, c = "top" !== r && "x" === this.axis; if (this.isHorizontal()) { const h = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1); let u = 0, f = 0; l ? c ? (u = s * t.width, f = i * e.height) : (u = i * t.height, f = s * e.width) : "start" === o ? f = e.width : "end" === o ? u = t.width : "inner" !== o && (u = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((u - h + a) * this.width / (this.width - h), 0), this.paddingRight = Math.max((f - d + a) * this.width / (this.width - d), 0) } else { let h = e.height / 2, d = t.height / 2; "start" === o ? (h = 0, d = t.height) : "end" === o && (h = e.height, d = 0), this.paddingTop = h + a, this.paddingBottom = d + a } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { E(this.options.afterFit, [this]) } isHorizontal() { const { axis: t, position: e } = this.options; return "top" === e || "bottom" === e || "x" === t } isFullSize() { return this.options.fullSize } _convertTicksToLabels(t) { let e, i; for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++)O(t[e].label) && (t.splice(e, 1), i--, e--); this.afterTickToLabelConversion() } _getLabelSizes() { let t = this._labelSizes; if (!t) { const e = this.options.ticks.sampleSize; let i = this.ticks; e < i.length && (i = us(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit) } return t } _computeLabelSizes(t, e, i) { const { ctx: s, _longestTextCache: o } = this, a = [], r = [], l = Math.floor(e / ds(e, i)); let d, u, f, g, p, b, m, x, v, y, _, c = 0, h = 0; for (d = 0; d < e; d += l) { if (g = t[d].label, p = this._resolveTickFontOptions(d), s.font = b = p.string, m = o[b] = o[b] || { data: {}, gc: [] }, x = p.lineHeight, v = y = 0, O(g) || K(g)) { if (K(g)) for (u = 0, f = g.length; u < f; ++u)_ = g[u], !O(_) && !K(_) && (v = Mi(s, m.data, m.gc, v, _), y += x) } else v = Mi(s, m.data, m.gc, v, g), y = x; a.push(v), r.push(y), c = Math.max(v, c), h = Math.max(y, h) } aa(o, e); const M = a.indexOf(c), w = r.indexOf(h), S = D => ({ width: a[D] || 0, height: r[D] || 0 }); return { first: S(0), last: S(e - 1), widest: S(M), highest: S(w), widths: a, heights: r } } getLabelForValue(t) { return t } getPixelForValue(t, e) { return NaN } getValueForPixel(t) { } getPixelForTick(t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getPixelForDecimal(t) { this._reversePixels && (t = 1 - t); const e = this._startPixel + t * this._length; return En(this._alignToPixels ? yt(this.chart, e, 0) : e) } getDecimalForPixel(t) { const e = (t - this._startPixel) / this._length; return this._reversePixels ? 1 - e : e } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: t, max: e } = this; return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 } getContext(t) { const e = this.ticks || []; if (t >= 0 && t < e.length) { const i = e[t]; return i.$context || (i.$context = la(this.getContext(), t, i)) } return this.$context || (this.$context = ra(this.chart.getContext(), this)) } _tickSize() { const t = this.options.ticks, e = st(this.labelRotation), i = Math.abs(Math.cos(e)), s = Math.abs(Math.sin(e)), o = this._getLabelSizes(), a = t.autoSkipPadding || 0, r = o ? o.widest.width + a : 0, l = o ? o.highest.height + a : 0; return this.isHorizontal() ? l * i > r * s ? r / i : l / s : l * s < r * i ? l / i : r / s } _isVisible() { const t = this.options.display; return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(t) { const e = this.axis, i = this.chart, s = this.options, { grid: o, position: a, border: r } = s, l = o.offset, c = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), u = se(o), f = [], g = r.setContext(this.getContext()), p = g.display ? g.width : 0, b = p / 2, m = function (z) { return yt(i, z, p) }; let x, v, y, _, M, w, S, D, P, A, L, H; if ("top" === a) x = m(this.bottom), w = this.bottom - u, D = x - b, A = m(t.top) + b, H = t.bottom; else if ("bottom" === a) x = m(this.top), A = t.top, H = m(t.bottom) - b, w = x + b, D = this.top + u; else if ("left" === a) x = m(this.right), M = this.right - u, S = x - b, P = m(t.left) + b, L = t.right; else if ("right" === a) x = m(this.left), P = t.left, L = m(t.right) - b, M = x + b, S = this.left + u; else if ("x" === e) { if ("center" === a) x = m((t.top + t.bottom) / 2 + .5); else if (F(a)) { const z = Object.keys(a)[0]; x = m(this.chart.scales[z].getPixelForValue(a[z])) } A = t.top, H = t.bottom, w = x + b, D = w + u } else if ("y" === e) { if ("center" === a) x = m((t.left + t.right) / 2); else if (F(a)) { const z = Object.keys(a)[0]; x = m(this.chart.scales[z].getPixelForValue(a[z])) } M = x - b, S = M - u, P = t.left, L = t.right } const J = C(s.ticks.maxTicksLimit, d), R = Math.max(1, Math.ceil(d / J)); for (v = 0; v < d; v += R) { const z = this.getContext(v), B = o.setContext(z), it = r.setContext(z), j = B.lineWidth, St = B.color, ce = it.dash || [], Dt = it.dashOffset, Ft = B.tickWidth, It = B.tickColor, Bt = B.tickBorderDash || [], Vt = B.tickBorderDashOffset; y = oa(this, v, l), void 0 !== y && (_ = yt(i, y, j), c ? M = S = P = L = _ : w = D = A = H = _, f.push({ tx1: M, ty1: w, tx2: S, ty2: D, x1: P, y1: A, x2: L, y2: H, width: j, color: St, borderDash: ce, borderDashOffset: Dt, tickWidth: Ft, tickColor: It, tickBorderDash: Bt, tickBorderDashOffset: Vt })) } return this._ticksLength = d, this._borderValue = x, f } _computeLabelItems(t) { const e = this.axis, i = this.options, { position: s, ticks: o } = i, a = this.isHorizontal(), r = this.ticks, { align: l, crossAlign: c, padding: h, mirror: d } = o, u = se(i.grid), f = u + h, g = d ? -h : f, p = -st(this.labelRotation), b = []; let m, x, v, y, _, M, w, S, D, P, A, L, H = "middle"; if ("top" === s) M = this.bottom - g, w = this._getXAxisLabelAlignment(); else if ("bottom" === s) M = this.top + g, w = this._getXAxisLabelAlignment(); else if ("left" === s) { const R = this._getYAxisLabelAlignment(u); w = R.textAlign, _ = R.x } else if ("right" === s) { const R = this._getYAxisLabelAlignment(u); w = R.textAlign, _ = R.x } else if ("x" === e) { if ("center" === s) M = (t.top + t.bottom) / 2 + f; else if (F(s)) { const R = Object.keys(s)[0]; M = this.chart.scales[R].getPixelForValue(s[R]) + f } w = this._getXAxisLabelAlignment() } else if ("y" === e) { if ("center" === s) _ = (t.left + t.right) / 2 - f; else if (F(s)) { const R = Object.keys(s)[0]; _ = this.chart.scales[R].getPixelForValue(s[R]) } w = this._getYAxisLabelAlignment(u).textAlign } "y" === e && ("start" === l ? H = "top" : "end" === l && (H = "bottom")); const J = this._getLabelSizes(); for (m = 0, x = r.length; m < x; ++m) { v = r[m], y = v.label; const R = o.setContext(this.getContext(m)); S = this.getPixelForTick(m) + o.labelOffset, D = this._resolveTickFontOptions(m), P = D.lineHeight, A = K(y) ? y.length : 1; const z = A / 2, B = R.color, it = R.textStrokeColor, j = R.textStrokeWidth; let ce, St = w; if (a ? (_ = S, "inner" === w && (St = m === x - 1 ? this.options.reverse ? "left" : "right" : 0 === m ? this.options.reverse ? "right" : "left" : "center"), L = "top" === s ? "near" === c || 0 !== p ? -A * P + P / 2 : "center" === c ? -J.highest.height / 2 - z * P + P : P / 2 - J.highest.height : "near" === c || 0 !== p ? P / 2 : "center" === c ? J.highest.height / 2 - z * P : J.highest.height - A * P, d && (L *= -1), 0 !== p && !R.showLabelBackdrop && (_ += P / 2 * Math.sin(p))) : (M = S, L = (1 - A) * P / 2), R.showLabelBackdrop) { const Dt = $(R.backdropPadding), Ft = J.heights[m], It = J.widths[m]; let Bt = L - Dt.top, Vt = 0 - Dt.left; switch (H) { case "middle": Bt -= Ft / 2; break; case "bottom": Bt -= Ft }switch (w) { case "center": Vt -= It / 2; break; case "right": Vt -= It }ce = { left: Vt, top: Bt, width: It + Dt.width, height: Ft + Dt.height, color: R.backdropColor } } b.push({ label: y, font: D, textOffset: L, options: { rotation: p, color: B, strokeColor: it, strokeWidth: j, textAlign: St, textBaseline: H, translation: [_, M], backdrop: ce } }) } return b } _getXAxisLabelAlignment() { const { position: t, ticks: e } = this.options; if (-st(this.labelRotation)) return "top" === t ? "left" : "right"; let s = "center"; return "start" === e.align ? s = "left" : "end" === e.align ? s = "right" : "inner" === e.align && (s = "inner"), s } _getYAxisLabelAlignment(t) { const { position: e, ticks: { crossAlign: i, mirror: s, padding: o } } = this.options, r = t + o, l = this._getLabelSizes().widest.width; let c, h; return "left" === e ? s ? (h = this.right + o, "near" === i ? c = "left" : "center" === i ? (c = "center", h += l / 2) : (c = "right", h += l)) : (h = this.right - r, "near" === i ? c = "right" : "center" === i ? (c = "center", h -= l / 2) : (c = "left", h = this.left)) : "right" === e ? s ? (h = this.left + o, "near" === i ? c = "right" : "center" === i ? (c = "center", h -= l / 2) : (c = "left", h -= l)) : (h = this.left + r, "near" === i ? c = "left" : "center" === i ? (c = "center", h += l / 2) : (c = "right", h = this.right)) : c = "right", { textAlign: c, x: h } } _computeLabelArea() { if (this.options.ticks.mirror) return; const t = this.chart, e = this.options.position; return "left" === e || "right" === e ? { top: 0, left: this.left, bottom: t.height, right: this.right } : "top" === e || "bottom" === e ? { top: this.top, left: 0, bottom: this.bottom, right: t.width } : void 0 } drawBackground() { const { ctx: t, options: { backgroundColor: e }, left: i, top: s, width: o, height: a } = this; e && (t.save(), t.fillStyle = e, t.fillRect(i, s, o, a), t.restore()) } getLineWidthForValue(t) { const e = this.options.grid; if (!this._isVisible() || !e.display) return 0; const s = this.ticks.findIndex(o => o.value === t); return s >= 0 ? e.setContext(this.getContext(s)).lineWidth : 0 } drawGrid(t) { const e = this.options.grid, i = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t)); let o, a; const r = (l, c, h) => { !h.width || !h.color || (i.save(), i.lineWidth = h.width, i.strokeStyle = h.color, i.setLineDash(h.borderDash || []), i.lineDashOffset = h.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(c.x, c.y), i.stroke(), i.restore()) }; if (e.display) for (o = 0, a = s.length; o < a; ++o) { const l = s[o]; e.drawOnChartArea && r({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l), e.drawTicks && r({ x: l.tx1, y: l.ty1 }, { x: l.tx2, y: l.ty2 }, { color: l.tickColor, width: l.tickWidth, borderDash: l.tickBorderDash, borderDashOffset: l.tickBorderDashOffset }) } } drawBorder() { const { chart: t, ctx: e, options: { border: i, grid: s } } = this, o = i.setContext(this.getContext()), a = i.display ? o.width : 0; if (!a) return; const r = s.setContext(this.getContext(0)).lineWidth, l = this._borderValue; let c, h, d, u; this.isHorizontal() ? (c = yt(t, this.left, a) - a / 2, h = yt(t, this.right, r) + r / 2, d = u = l) : (d = yt(t, this.top, a) - a / 2, u = yt(t, this.bottom, r) + r / 2, c = h = l), e.save(), e.lineWidth = o.width, e.strokeStyle = o.color, e.beginPath(), e.moveTo(c, d), e.lineTo(h, u), e.stroke(), e.restore() } drawLabels(t) { if (!this.options.ticks.display) return; const i = this.ctx, s = this._computeLabelArea(); s && ge(i, s); const o = this.getLabelItems(t); for (const a of o) vt(i, a.label, 0, a.textOffset, a.font, a.options); s && pe(i) } drawTitle() { const { ctx: t, options: { position: e, title: i, reverse: s } } = this; if (!i.display) return; const o = N(i.font), a = $(i.padding), r = i.align; let l = o.lineHeight / 2; "bottom" === e || "center" === e || F(e) ? (l += a.bottom, K(i.text) && (l += o.lineHeight * (i.text.length - 1))) : l += a.top; const { titleX: c, titleY: h, maxWidth: d, rotation: u } = ha(this, l, e, r); vt(t, i.text, 0, 0, o, { color: i.color, maxWidth: d, rotation: u, textAlign: ca(r, e, s), textBaseline: "middle", translation: [c, h] }) } draw(t) { !this._isVisible() || (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t)) } _layers() { const t = this.options, e = t.ticks && t.ticks.z || 0, i = C(t.grid && t.grid.z, -1), s = C(t.border && t.border.z, 0); return this._isVisible() && this.draw === mt.prototype.draw ? [{ z: i, draw: o => { this.drawBackground(), this.drawGrid(o), this.drawTitle() } }, { z: s, draw: () => { this.drawBorder() } }, { z: e, draw: o => { this.drawLabels(o) } }] : [{ z: e, draw: o => { this.draw(o) } }] } getMatchingVisibleMetas(t) { const e = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", s = []; let o, a; for (o = 0, a = e.length; o < a; ++o) { const r = e[o]; r[i] === this.id && (!t || r.type === t) && s.push(r) } return s } _resolveTickFontOptions(t) { const e = this.options.ticks.setContext(this.getContext(t)); return N(e.font) } _maxDigits() { const t = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / t } } class Se { constructor(t, e, i) { this.type = t, this.scope = e, this.override = i, this.items = Object.create(null) } isForType(t) { return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype) } register(t) { const e = Object.getPrototypeOf(t); let i; fa(e) && (i = this.register(e)); const s = this.items, o = t.id, a = this.scope + "." + o; if (!o) throw new Error("class does not have id: " + t); return o in s || (s[o] = t, da(t, a, i), this.override && I.override(t.id, t.overrides)), a } get(t) { return this.items[t] } unregister(t) { const e = this.items, i = t.id, s = this.scope; i in e && delete e[i], s && i in I[s] && (delete I[s][i], this.override && delete Ct[i]) } } function da(n, t, e) { const i = zn(Object.create(null), [e ? I.get(e) : {}, I.get(t), n.defaults]); I.set(t, i), n.defaultRoutes && ua(t, n.defaultRoutes), n.descriptors && I.describe(t, n.descriptors) } function ua(n, t) { Object.keys(t).forEach(e => { const i = e.split("."), s = i.pop(), o = [n].concat(i).join("."), a = t[e].split("."), r = a.pop(), l = a.join("."); I.route(o, s, l, r) }) } function fa(n) { return "id" in n && "defaults" in n } class ga { constructor() { this.controllers = new Se(tt, "datasets", !0), this.elements = new Se(et, "elements"), this.plugins = new Se(Object, "plugins"), this.scales = new Se(mt, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...t) { this._each("register", t) } remove(...t) { this._each("unregister", t) } addControllers(...t) { this._each("register", t, this.controllers) } addElements(...t) { this._each("register", t, this.elements) } addPlugins(...t) { this._each("register", t, this.plugins) } addScales(...t) { this._each("register", t, this.scales) } getController(t) { return this._get(t, this.controllers, "controller") } getElement(t) { return this._get(t, this.elements, "element") } getPlugin(t) { return this._get(t, this.plugins, "plugin") } getScale(t) { return this._get(t, this.scales, "scale") } removeControllers(...t) { this._each("unregister", t, this.controllers) } removeElements(...t) { this._each("unregister", t, this.elements) } removePlugins(...t) { this._each("unregister", t, this.plugins) } removeScales(...t) { this._each("unregister", t, this.scales) } _each(t, e, i) { [...e].forEach(s => { const o = i || this._getRegistryForType(s); i || o.isForType(s) || o === this.plugins && s.id ? this._exec(t, o, s) : T(s, a => { const r = i || this._getRegistryForType(a); this._exec(t, r, a) }) }) } _exec(t, e, i) { const s = Fn(t); E(i["before" + s], [], i), e[t](i), E(i["after" + s], [], i) } _getRegistryForType(t) { for (let e = 0; e < this._typedRegistries.length; e++) { const i = this._typedRegistries[e]; if (i.isForType(t)) return i } return this.plugins } _get(t, e, i) { const s = e.get(t); if (void 0 === s) throw new Error('"' + t + '" is not a registered ' + i + "."); return s } } var nt = new ga; class pa { constructor() { this._init = [] } notify(t, e, i, s) { "beforeInit" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")); const o = s ? this._descriptors(t).filter(s) : this._descriptors(t), a = this._notify(o, t, e, i); return "afterDestroy" === e && (this._notify(o, t, "stop"), this._notify(this._init, t, "uninstall")), a } _notify(t, e, i, s) { s = s || {}; for (const o of t) { const a = o.plugin; if (!1 === E(a[i], [e, s, o.options], a) && s.cancelable) return !1 } return !0 } invalidate() { O(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(t) { if (this._cache) return this._cache; const e = this._cache = this._createDescriptors(t); return this._notifyStateChanges(t), e } _createDescriptors(t, e) { const i = t && t.config, s = C(i.options && i.options.plugins, {}), o = ma(i); return !1 !== s || e ? xa(t, o, s, e) : [] } _notifyStateChanges(t) { const e = this._oldCache || [], i = this._cache, s = (o, a) => o.filter(r => !a.some(l => r.plugin.id === l.plugin.id)); this._notify(s(e, i), t, "stop"), this._notify(s(i, e), t, "start") } } function ma(n) { const t = {}, e = [], i = Object.keys(nt.plugins.items); for (let o = 0; o < i.length; o++)e.push(nt.getPlugin(i[o])); const s = n.plugins || []; for (let o = 0; o < s.length; o++) { const a = s[o]; -1 === e.indexOf(a) && (e.push(a), t[a.id] = !0) } return { plugins: e, localIds: t } } function ba(n, t) { return t || !1 !== n ? !0 === n ? {} : n : null } function xa(n, { plugins: t, localIds: e }, i, s) { const o = [], a = n.getContext(); for (const r of t) { const l = r.id, c = ba(i[l], s); null !== c && o.push({ plugin: r, options: _a(n.config, { plugin: r, local: e[l] }, c, a) }) } return o } function _a(n, { plugin: t, local: e }, i, s) { const o = n.pluginScopeKeys(t), a = n.getOptionScopes(i, o); return e && t.defaults && a.push(t.defaults), n.createResolver(a, s, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function Je(n, t) { return ((t.datasets || {})[n] || {}).indexAxis || t.indexAxis || (I.datasets[n] || {}).indexAxis || "x" } function ya(n, t) { let e = n; return "_index_" === n ? e = t : "_value_" === n && (e = "x" === t ? "y" : "x"), e } function va(n, t) { return n === t ? "_index_" : "_value_" } function gs(n) { if ("x" === n || "y" === n || "r" === n) return n } function ka(n) { return "top" === n || "bottom" === n ? "x" : "left" === n || "right" === n ? "y" : void 0 } function Ze(n, ...t) { if (gs(n)) return n; for (const e of t) { const i = e.axis || ka(e.position) || n.length > 1 && gs(n[0].toLowerCase()); if (i) return i } throw new Error(`Cannot determine type of '${n}' axis. Please provide 'axis' or 'position' option.`) } function ps(n, t, e) { if (e[t + "AxisID"] === n) return { axis: t } } function Ma(n, t) { if (t.data && t.data.datasets) { const e = t.data.datasets.filter(i => i.xAxisID === n || i.yAxisID === n); if (e.length) return ps(n, "x", e[0]) || ps(n, "y", e[0]) } return {} } function wa(n, t) { const e = Ct[n.type] || { scales: {} }, i = t.scales || {}, s = Je(n.type, t), o = Object.create(null); return Object.keys(i).forEach(a => { const r = i[a]; if (!F(r)) return console.error(`Invalid scale configuration for scale: ${a}`); if (r._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${a}`); const l = Ze(a, r, Ma(a, n), I.scales[r.type]), c = va(l, s), h = e.scales || {}; o[a] = be(Object.create(null), [{ axis: l }, r, h[l], h[c]]) }), n.data.datasets.forEach(a => { const r = a.type || n.type, l = a.indexAxis || Je(r, t), h = (Ct[r] || {}).scales || {}; Object.keys(h).forEach(d => { const u = ya(d, l), f = a[u + "AxisID"] || u; o[f] = o[f] || Object.create(null), be(o[f], [{ axis: u }, i[f], h[d]]) }) }), Object.keys(o).forEach(a => { const r = o[a]; be(r, [I.scales[r.type], I.scale]) }), o } function ms(n) { const t = n.options || (n.options = {}); t.plugins = C(t.plugins, {}), t.scales = wa(n, t) } function bs(n) { return (n = n || {}).datasets = n.datasets || [], n.labels = n.labels || [], n } function Sa(n) { return (n = n || {}).data = bs(n.data), ms(n), n } const xs = new Map, _s = new Set; function De(n, t) { let e = xs.get(n); return e || (e = t(), xs.set(n, e), _s.add(e)), e } const ne = (n, t, e) => { const i = Pt(t, e); void 0 !== i && n.add(i) }; class Da { constructor(t) { this._config = Sa(t), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(t) { this._config.type = t } get data() { return this._config.data } set data(t) { this._config.data = bs(t) } get options() { return this._config.options } set options(t) { this._config.options = t } get plugins() { return this._config.plugins } update() { const t = this._config; this.clearCache(), ms(t) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(t) { return De(t, () => [[`datasets.${t}`, ""]]) } datasetAnimationScopeKeys(t, e) { return De(`${t}.transition.${e}`, () => [[`datasets.${t}.transitions.${e}`, `transitions.${e}`], [`datasets.${t}`, ""]]) } datasetElementScopeKeys(t, e) { return De(`${t}-${e}`, () => [[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]]) } pluginScopeKeys(t) { const e = t.id; return De(`${this.type}-plugin-${e}`, () => [[`plugins.${e}`, ...t.additionalOptionScopes || []]]) } _cachedScopes(t, e) { const i = this._scopeCache; let s = i.get(t); return (!s || e) && (s = new Map, i.set(t, s)), s } getOptionScopes(t, e, i) { const { options: s, type: o } = this, a = this._cachedScopes(t, i), r = a.get(e); if (r) return r; const l = new Set; e.forEach(h => { t && (l.add(t), h.forEach(d => ne(l, t, d))), h.forEach(d => ne(l, s, d)), h.forEach(d => ne(l, Ct[o] || {}, d)), h.forEach(d => ne(l, I, d)), h.forEach(d => ne(l, wi, d)) }); const c = Array.from(l); return 0 === c.length && c.push(Object.create(null)), _s.has(e) && a.set(e, c), c } chartOptionScopes() { const { options: t, type: e } = this; return [t, Ct[e] || {}, I.datasets[e] || {}, { type: e }, I, wi] } resolveNamedOptions(t, e, i, s = [""]) { const o = { $shared: !0 }, { resolver: a, subPrefixes: r } = ys(this._resolverCache, t, s); let l = a; if (Aa(a, e)) { o.$shared = !1, i = me(i) ? i() : i; const c = this.createResolver(t, i, r); l = Si(a, i, c) } for (const c of e) o[c] = l[c]; return o } createResolver(t, e, i = [""], s) { const { resolver: o } = ys(this._resolverCache, t, i); return F(e) ? Si(o, e, void 0, s) : o } } function ys(n, t, e) { let i = n.get(t); i || (i = new Map, n.set(t, i)); const s = e.join(); let o = i.get(s); return o || (o = { resolver: In(t, e), subPrefixes: e.filter(r => !r.toLowerCase().includes("hover")) }, i.set(s, o)), o } const Pa = n => F(n) && Object.getOwnPropertyNames(n).reduce((t, e) => t || me(n[e]), !1); function Aa(n, t) { const { isScriptable: e, isIndexable: i } = Bn(n); for (const s of t) { const o = e(s), a = i(s), r = (a || o) && n[s]; if (o && (me(r) || Pa(r)) || a && K(r)) return !0 } return !1 } var Ca = "4.3.0"; const La = ["top", "bottom", "left", "right", "chartArea"]; function vs(n, t) { return "top" === n || "bottom" === n || -1 === La.indexOf(n) && "x" === t } function ks(n, t) { return function (e, i) { return e[n] === i[n] ? e[t] - i[t] : e[n] - i[n] } } function Ms(n) { const t = n.chart, e = t.options.animation; t.notifyPlugins("afterRender"), E(e && e.onComplete, [n], t) } function Oa(n) { const t = n.chart, e = t.options.animation; E(e && e.onProgress, [n], t) } function ws(n) { return ki() && "string" == typeof n ? n = document.getElementById(n) : n && n.length && (n = n[0]), n && n.canvas && (n = n.canvas), n } const Pe = {}, Ss = n => { const t = ws(n); return Object.values(Pe).filter(e => e.canvas === t).pop() }; function Ta(n, t, e) { const i = Object.keys(n); for (const s of i) { const o = +s; if (o >= t) { const a = n[s]; delete n[s], (e > 0 || o > t) && (n[o + e] = a) } } } function Ra(n, t, e, i) { return e && "mouseout" !== n.type ? i ? t : n : null } function Ea(n) { const { xScale: t, yScale: e } = n; if (t && e) return { left: t.left, right: t.right, top: e.top, bottom: e.bottom } } class gt { static register(...t) { nt.add(...t), Ds() } static unregister(...t) { nt.remove(...t), Ds() } constructor(t, e) { const i = this.config = new Da(e), s = ws(t), o = Ss(s); if (o) throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused."); const a = i.createResolver(i.chartOptionScopes(), this.getContext()); this.platform = new (i.platform || cs(s)), this.platform.updateConfig(i); const r = this.platform.acquireContext(s, a.aspectRatio), l = r && r.canvas, c = l && l.height, h = l && l.width; this.id = Vn(), this.ctx = r, this.canvas = l, this.width = h, this.height = c, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new pa, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Nn(d => this.update(d), a.resizeDelay || 0), this._dataChanges = [], Pe[this.id] = this, r && l ? (ot.listen(this, "complete", Ms), ot.listen(this, "progress", Oa), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item") } get aspectRatio() { const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: s, _aspectRatio: o } = this; return O(t) ? e && o ? o : s ? i / s : null : t } get data() { return this.config.data } set data(t) { this.config.data = t } get options() { return this._options } set options(t) { this.config.options = t } get registry() { return nt } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Di(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return Pi(this.canvas, this.ctx), this } stop() { return ot.stop(this), this } resize(t, e) { ot.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e) } _resize(t, e) { const i = this.options, a = this.platform.getMaximumSize(this.canvas, t, e, i.maintainAspectRatio && this.aspectRatio), r = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach"; this.width = a.width, this.height = a.height, this._aspectRatio = this.aspectRatio, Di(this, r, !0) && (this.notifyPlugins("resize", { size: a }), E(i.onResize, [this, a], this), this.attached && this._doResize(l) && this.render()) } ensureScalesHaveIDs() { T(this.options.scales || {}, (i, s) => { i.id = s }) } buildOrUpdateScales() { const t = this.options, e = t.scales, i = this.scales, s = Object.keys(i).reduce((a, r) => (a[r] = !1, a), {}); let o = []; e && (o = o.concat(Object.keys(e).map(a => { const r = e[a], l = Ze(a, r), c = "r" === l, h = "x" === l; return { options: r, dposition: c ? "chartArea" : h ? "bottom" : "left", dtype: c ? "radialLinear" : h ? "category" : "linear" } }))), T(o, a => { const r = a.options, l = r.id, c = Ze(l, r), h = C(r.type, a.dtype); (void 0 === r.position || vs(r.position, c) !== vs(a.dposition)) && (r.position = a.dposition), s[l] = !0; let d = null; l in i && i[l].type === h ? d = i[l] : (d = new (nt.getScale(h))({ id: l, type: h, ctx: this.ctx, chart: this }), i[d.id] = d), d.init(r, t) }), T(s, (a, r) => { a || delete i[r] }), T(i, a => { W.configure(this, a, a.options), W.addBox(this, a) }) } _updateMetasets() { const t = this._metasets, e = this.data.datasets.length, i = t.length; if (t.sort((s, o) => s.index - o.index), i > e) { for (let s = e; s < i; ++s)this._destroyDatasetMeta(s); t.splice(e, i - e) } this._sortedMetasets = t.slice(0).sort(ks("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: t, data: { datasets: e } } = this; t.length > e.length && delete this._stacks, t.forEach((i, s) => { 0 === e.filter(o => o === i._dataset).length && this._destroyDatasetMeta(s) }) } buildOrUpdateControllers() { const t = [], e = this.data.datasets; let i, s; for (this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++) { const o = e[i]; let a = this.getDatasetMeta(i); const r = o.type || this.config.type; if (a.type && a.type !== r && (this._destroyDatasetMeta(i), a = this.getDatasetMeta(i)), a.type = r, a.indexAxis = o.indexAxis || Je(r, this.options), a.order = o.order || 0, a.index = i, a.label = "" + o.label, a.visible = this.isDatasetVisible(i), a.controller) a.controller.updateIndex(i), a.controller.linkScales(); else { const l = nt.getController(r), { datasetElementType: c, dataElementType: h } = I.datasets[r]; Object.assign(l, { dataElementType: nt.getElement(h), datasetElementType: c && nt.getElement(c) }), a.controller = new l(this, i), t.push(a.controller) } } return this._updateMetasets(), t } _resetElements() { T(this.data.datasets, (t, e) => { this.getDatasetMeta(e).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(t) { const e = this.config; e.update(); const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", { mode: t, cancelable: !0 })) return; const o = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let a = 0; for (let c = 0, h = this.data.datasets.length; c < h; c++) { const { controller: d } = this.getDatasetMeta(c), u = !s && -1 === o.indexOf(d); d.buildOrUpdateElements(u), a = Math.max(+d.getMaxOverflow(), a) } a = this._minPadding = i.layout.autoPadding ? a : 0, this._updateLayout(a), s || T(o, c => { c.reset() }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", { mode: t }), this._layers.sort(ks("z", "_idx")); const { _active: r, _lastEvent: l } = this; l ? this._eventHandler(l, !0) : r.length && this._updateHoverStyles(r, r, !0), this.render() } _updateScales() { T(this.scales, t => { W.removeBox(this, t) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const t = this.options, e = new Set(Object.keys(this._listeners)), i = new Set(t.events); (!Ai(e, i) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || []; for (const { method: i, start: s, count: o } of e) Ta(t, s, "_removeElements" === i ? -o : o) } _getUniformDataChanges() { const t = this._dataChanges; if (!t || !t.length) return; this._dataChanges = []; const e = this.data.datasets.length, i = o => new Set(t.filter(a => a[0] === o).map((a, r) => r + "," + a.splice(1).join(","))), s = i(0); for (let o = 1; o < e; o++)if (!Ai(s, i(o))) return; return Array.from(s).map(o => o.split(",")).map(o => ({ method: o[1], start: +o[2], count: +o[3] })) } _updateLayout(t) { if (!1 === this.notifyPlugins("beforeLayout", { cancelable: !0 })) return; W.update(this, this.width, this.height, t); const e = this.chartArea, i = e.width <= 0 || e.height <= 0; this._layers = [], T(this.boxes, s => { i && "chartArea" === s.position || (s.configure && s.configure(), this._layers.push(...s._layers())) }, this), this._layers.forEach((s, o) => { s._idx = o }), this.notifyPlugins("afterLayout") } _updateDatasets(t) { if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: !0 })) { for (let e = 0, i = this.data.datasets.length; e < i; ++e)this.getDatasetMeta(e).controller.configure(); for (let e = 0, i = this.data.datasets.length; e < i; ++e)this._updateDataset(e, me(t) ? t({ datasetIndex: e }) : t); this.notifyPlugins("afterDatasetsUpdate", { mode: t }) } } _updateDataset(t, e) { const i = this.getDatasetMeta(t), s = { meta: i, index: t, mode: e, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetUpdate", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", s)) } render() { !1 !== this.notifyPlugins("beforeRender", { cancelable: !0 }) && (ot.has(this) ? this.attached && !ot.running(this) && ot.start(this) : (this.draw(), Ms({ chart: this }))) } draw() { let t; if (this._resizeBeforeDraw) { const { width: i, height: s } = this._resizeBeforeDraw; this._resize(i, s), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || !1 === this.notifyPlugins("beforeDraw", { cancelable: !0 })) return; const e = this._layers; for (t = 0; t < e.length && e[t].z <= 0; ++t)e[t].draw(this.chartArea); for (this._drawDatasets(); t < e.length; ++t)e[t].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(t) { const e = this._sortedMetasets, i = []; let s, o; for (s = 0, o = e.length; s < o; ++s) { const a = e[s]; (!t || a.visible) && i.push(a) } return i } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (!1 === this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 })) return; const t = this.getSortedVisibleDatasetMetas(); for (let e = t.length - 1; e >= 0; --e)this._drawDataset(t[e]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(t) { const e = this.ctx, i = t._clip, s = !i.disabled, o = Ea(t) || this.chartArea, a = { meta: t, index: t.index, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetDraw", a) && (s && ge(e, { left: !1 === i.left ? 0 : o.left - i.left, right: !1 === i.right ? this.width : o.right + i.right, top: !1 === i.top ? 0 : o.top - i.top, bottom: !1 === i.bottom ? this.height : o.bottom + i.bottom }), t.controller.draw(), s && pe(e), a.cancelable = !1, this.notifyPlugins("afterDatasetDraw", a)) } isPointInArea(t) { return _t(t, this.chartArea, this._minPadding) } getElementsAtEventForMode(t, e, i, s) { const o = Ji.modes[e]; return "function" == typeof o ? o(this, t, i, s) : [] } getDatasetMeta(t) { const e = this.data.datasets[t], i = this._metasets; let s = i.filter(o => o && o._dataset === e).pop(); return s || (s = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e && e.order || 0, index: t, _dataset: e, _parsed: [], _sorted: !1 }, i.push(s)), s } getContext() { return this.$context || (this.$context = bt(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(t) { const e = this.data.datasets[t]; if (!e) return !1; const i = this.getDatasetMeta(t); return "boolean" == typeof i.hidden ? !i.hidden : !e.hidden } setDatasetVisibility(t, e) { this.getDatasetMeta(t).hidden = !e } toggleDataVisibility(t) { this._hiddenIndices[t] = !this._hiddenIndices[t] } getDataVisibility(t) { return !this._hiddenIndices[t] } _updateVisibility(t, e, i) { const s = i ? "show" : "hide", o = this.getDatasetMeta(t), a = o.controller._resolveAnimations(void 0, s); Ht(e) ? (o.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), a.update(o, { visible: i }), this.update(r => r.datasetIndex === t ? s : void 0)) } hide(t, e) { this._updateVisibility(t, e, !1) } show(t, e) { this._updateVisibility(t, e, !0) } _destroyDatasetMeta(t) { const e = this._metasets[t]; e && e.controller && e.controller._destroy(), delete this._metasets[t] } _stop() { let t, e; for (this.stop(), ot.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: t, ctx: e } = this; this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Pi(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Pe[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...t) { return this.canvas.toDataURL(...t) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const t = this._listeners, e = this.platform, i = (o, a) => { e.addEventListener(this, o, a), t[o] = a }, s = (o, a, r) => { o.offsetX = a, o.offsetY = r, this._eventHandler(o) }; T(this.options.events, o => i(o, s)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const t = this._responsiveListeners, e = this.platform, i = (l, c) => { e.addEventListener(this, l, c), t[l] = c }, s = (l, c) => { t[l] && (e.removeEventListener(this, l, c), delete t[l]) }, o = (l, c) => { this.canvas && this.resize(l, c) }; let a; const r = () => { s("attach", r), this.attached = !0, this.resize(), i("resize", o), i("detach", a) }; a = () => { this.attached = !1, s("resize", o), this._stop(), this._resize(0, 0), i("attach", r) }, e.isAttached(this.canvas) ? r() : a() } unbindEvents() { T(this._listeners, (t, e) => { this.platform.removeEventListener(this, e, t) }), this._listeners = {}, T(this._responsiveListeners, (t, e) => { this.platform.removeEventListener(this, e, t) }), this._responsiveListeners = void 0 } updateHoverStyle(t, e, i) { const s = i ? "set" : "remove"; let o, a, r, l; for ("dataset" === e && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller["_" + s + "DatasetHoverStyle"]()), r = 0, l = t.length; r < l; ++r) { a = t[r]; const c = a && this.getDatasetMeta(a.datasetIndex).controller; c && c[s + "HoverStyle"](a.element, a.datasetIndex, a.index) } } getActiveElements() { return this._active || [] } setActiveElements(t) { const e = this._active || [], i = t.map(({ datasetIndex: o, index: a }) => { const r = this.getDatasetMeta(o); if (!r) throw new Error("No dataset found at index " + o); return { datasetIndex: o, element: r.data[a], index: a } }); !xe(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e)) } notifyPlugins(t, e, i) { return this._plugins.notify(this, t, e, i) } isPluginEnabled(t) { return 1 === this._plugins._cache.filter(e => e.plugin.id === t).length } _updateHoverStyles(t, e, i) { const s = this.options.hover, o = (l, c) => l.filter(h => !c.some(d => h.datasetIndex === d.datasetIndex && h.index === d.index)), a = o(e, t), r = i ? t : o(t, e); a.length && this.updateHoverStyle(a, s.mode, !1), r.length && s.mode && this.updateHoverStyle(r, s.mode, !0) } _eventHandler(t, e) { const i = { event: t, replay: e, cancelable: !0, inChartArea: this.isPointInArea(t) }, s = a => (a.options.events || this.options.events).includes(t.native.type); if (!1 === this.notifyPlugins("beforeEvent", i, s)) return; const o = this._handleEvent(t, e, i.inChartArea); return i.cancelable = !1, this.notifyPlugins("afterEvent", i, s), (o || i.changed) && this.render(), this } _handleEvent(t, e, i) { const { _active: s = [], options: o } = this, r = this._getActiveElements(t, s, i, e), l = Hn(t), c = Ra(t, this._lastEvent, i, l); i && (this._lastEvent = null, E(o.onHover, [t, r, this], this), l && E(o.onClick, [t, r, this], this)); const h = !xe(r, s); return (h || e) && (this._active = r, this._updateHoverStyles(r, s, e)), this._lastEvent = c, h } _getActiveElements(t, e, i, s) { if ("mouseout" === t.type) return []; if (!i) return e; const o = this.options.hover; return this.getElementsAtEventForMode(t, o.mode, o, s) } } function Ds() { return T(gt.instances, n => n._plugins.invalidate()) } function za(n, t, e) { const { startAngle: i, pixelMargin: s, x: o, y: a, outerRadius: r, innerRadius: l } = t; let c = s / r; n.beginPath(), n.arc(o, a, r, i - c, e + c), l > s ? (c = s / l, n.arc(o, a, l, e + c, i - c, !0)) : n.arc(o, a, s, e + Q, i - Q), n.closePath(), n.clip() } function Fa(n) { return Wn(n, ["outerStart", "outerEnd", "innerStart", "innerEnd"]) } function Ia(n, t, e, i) { const s = Fa(n.options.borderRadius), o = (e - t) / 2, a = Math.min(o, i * t / 2), r = l => { const c = (e - Math.min(o, l)) * i / 2; return X(l, 0, Math.min(o, c)) }; return { outerStart: r(s.outerStart), outerEnd: r(s.outerEnd), innerStart: X(s.innerStart, 0, a), innerEnd: X(s.innerEnd, 0, a) } } function Tt(n, t, e, i) { return { x: e + n * Math.cos(t), y: i + n * Math.sin(t) } } function Ae(n, t, e, i, s, o) { const { x: a, y: r, startAngle: l, pixelMargin: c, innerRadius: h } = t, d = Math.max(t.outerRadius + i + e - c, 0), u = h > 0 ? h + i + e + c : 0; let f = 0; const g = s - l; if (i) { const B = ((h > 0 ? h - i : 0) + (d > 0 ? d - i : 0)) / 2; f = (g - (0 !== B ? g * B / (B + i) : g)) / 2 } const b = (g - Math.max(.001, g * d - e / rt) / d) / 2, m = l + b + f, x = s - b - f, { outerStart: v, outerEnd: y, innerStart: _, innerEnd: M } = Ia(t, u, d, x - m), w = d - v, S = d - y, D = m + v / w, P = x - y / S, A = u + _, L = u + M, H = m + _ / A, J = x - M / L; if (n.beginPath(), o) { const R = (D + P) / 2; if (n.arc(a, r, d, D, R), n.arc(a, r, d, R, P), y > 0) { const j = Tt(S, P, a, r); n.arc(j.x, j.y, y, P, x + Q) } const z = Tt(L, x, a, r); if (n.lineTo(z.x, z.y), M > 0) { const j = Tt(L, J, a, r); n.arc(j.x, j.y, M, x + Q, J + Math.PI) } const B = (x - M / u + (m + _ / u)) / 2; if (n.arc(a, r, u, x - M / u, B, !0), n.arc(a, r, u, B, m + _ / u, !0), _ > 0) { const j = Tt(A, H, a, r); n.arc(j.x, j.y, _, H + Math.PI, m - Q) } const it = Tt(w, m, a, r); if (n.lineTo(it.x, it.y), v > 0) { const j = Tt(w, D, a, r); n.arc(j.x, j.y, v, m - Q, D) } } else { n.moveTo(a, r); const R = Math.cos(D) * d + a, z = Math.sin(D) * d + r; n.lineTo(R, z); const B = Math.cos(P) * d + a, it = Math.sin(P) * d + r; n.lineTo(B, it) } n.closePath() } function Ba(n, t, e, i, s) { const { fullCircles: o, startAngle: a, circumference: r } = t; let l = t.endAngle; if (o) { Ae(n, t, e, i, l, s); for (let c = 0; c < o; ++c)n.fill(); isNaN(r) || (l = a + (r % Y || Y)) } return Ae(n, t, e, i, l, s), n.fill(), l } function Va(n, t, e, i, s) { const { fullCircles: o, startAngle: a, circumference: r, options: l } = t, { borderWidth: c, borderJoinStyle: h, borderDash: d, borderDashOffset: u } = l, f = "inner" === l.borderAlign; if (!c) return; n.setLineDash(d || []), n.lineDashOffset = u, f ? (n.lineWidth = 2 * c, n.lineJoin = h || "round") : (n.lineWidth = c, n.lineJoin = h || "bevel"); let g = t.endAngle; if (o) { Ae(n, t, e, i, g, s); for (let p = 0; p < o; ++p)n.stroke(); isNaN(r) || (g = a + (r % Y || Y)) } f && za(n, t, g), o || (Ae(n, t, e, i, g, s), n.stroke()) } k(gt, "defaults", I), k(gt, "instances", Pe), k(gt, "overrides", Ct), k(gt, "registry", nt), k(gt, "version", Ca), k(gt, "getChart", Ss); class Rt extends et { constructor(t) { super(), k(this, "circumference"), k(this, "endAngle"), k(this, "fullCircles"), k(this, "innerRadius"), k(this, "outerRadius"), k(this, "pixelMargin"), k(this, "startAngle"), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t) } inRange(t, e, i) { const s = this.getProps(["x", "y"], i), { angle: o, distance: a } = xi(s, { x: t, y: e }), { startAngle: r, endAngle: l, innerRadius: c, outerRadius: h, circumference: d } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i), u = (this.options.spacing + this.options.borderWidth) / 2, g = C(d, l - r) >= Y || fe(o, r, l), p = ut(a, c + u, h + u); return g && p } getCenterPoint(t) { const { x: e, y: i, startAngle: s, endAngle: o, innerRadius: a, outerRadius: r } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], t), { offset: l, spacing: c } = this.options, h = (s + o) / 2, d = (a + r + c + l) / 2; return { x: e + Math.cos(h) * d, y: i + Math.sin(h) * d } } tooltipPosition(t) { return this.getCenterPoint(t) } draw(t) { const { options: e, circumference: i } = this, s = (e.offset || 0) / 4, o = (e.spacing || 0) / 2, a = e.circular; if (this.pixelMargin = "inner" === e.borderAlign ? .33 : 0, this.fullCircles = i > Y ? Math.floor(i / Y) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return; t.save(); const r = (this.startAngle + this.endAngle) / 2; t.translate(Math.cos(r) * s, Math.sin(r) * s); const c = s * (1 - Math.sin(Math.min(rt, i || 0))); t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor, Ba(t, this, c, o, a), Va(t, this, c, o, a), t.restore() } } function Ps(n, t, e = t) { n.lineCap = C(e.borderCapStyle, t.borderCapStyle), n.setLineDash(C(e.borderDash, t.borderDash)), n.lineDashOffset = C(e.borderDashOffset, t.borderDashOffset), n.lineJoin = C(e.borderJoinStyle, t.borderJoinStyle), n.lineWidth = C(e.borderWidth, t.borderWidth), n.strokeStyle = C(e.borderColor, t.borderColor) } function Na(n, t, e) { n.lineTo(e.x, e.y) } function Ha(n) { return n.stepped ? Kn : n.tension || "monotone" === n.cubicInterpolationMode ? Gn : Na } function As(n, t, e = {}) { const i = n.length, { start: s = 0, end: o = i - 1 } = e, { start: a, end: r } = t, l = Math.max(s, a), c = Math.min(o, r); return { count: i, start: l, loop: t.loop, ilen: c < l && !(s < a && o < a || s > r && o > r) ? i + c - l : c - l } } function Wa(n, t, e, i) { const { points: s, options: o } = t, { count: a, start: r, loop: l, ilen: c } = As(s, e, i), h = Ha(o); let f, g, p, { move: d = !0, reverse: u } = i || {}; for (f = 0; f <= c; ++f)g = s[(r + (u ? c - f : f)) % a], !g.skip && (d ? (n.moveTo(g.x, g.y), d = !1) : h(n, p, g, u, o.stepped), p = g); return l && (g = s[(r + (u ? c : 0)) % a], h(n, p, g, u, o.stepped)), !!l } function ja(n, t, e, i) { const s = t.points, { count: o, start: a, ilen: r } = As(s, e, i), { move: l = !0, reverse: c } = i || {}; let u, f, g, p, b, m, h = 0, d = 0; const x = y => (a + (c ? r - y : y)) % o, v = () => { p !== b && (n.lineTo(h, b), n.lineTo(h, p), n.lineTo(h, m)) }; for (l && (f = s[x(0)], n.moveTo(f.x, f.y)), u = 0; u <= r; ++u) { if (f = s[x(u)], f.skip) continue; const y = f.x, _ = f.y, M = 0 | y; M === g ? (_ < p ? p = _ : _ > b && (b = _), h = (d * h + y) / ++d) : (v(), n.lineTo(y, _), g = M, d = 0, p = b = _), m = _ } v() } function Qe(n) { const t = n.options; return n._decimated || n._loop || t.tension || "monotone" === t.cubicInterpolationMode || t.stepped || t.borderDash && t.borderDash.length ? Wa : ja } function $a(n) { return n.stepped ? Un : n.tension || "monotone" === n.cubicInterpolationMode ? Yn : Xn } function Ua(n, t, e, i) { let s = t._path; s || (s = t._path = new Path2D, t.path(s, e, i) && s.closePath()), Ps(n, t.options), n.stroke(s) } function Ya(n, t, e, i) { const { segments: s, options: o } = t, a = Qe(t); for (const r of s) Ps(n, o, r.style), n.beginPath(), a(n, t, r, { start: e, end: e + i - 1 }) && n.closePath(), n.stroke() } k(Rt, "id", "arc"), k(Rt, "defaults", { borderAlign: "center", borderColor: "#fff", borderDash: [], borderDashOffset: 0, borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: !0 }), k(Rt, "defaultRoutes", { backgroundColor: "backgroundColor" }), k(Rt, "descriptors", { _scriptable: !0, _indexable: t => "borderDash" !== t }); const Xa = "function" == typeof Path2D; function Ka(n, t, e, i) { Xa && !t.options.segment ? Ua(n, t, e, i) : Ya(n, t, e, i) } class ct extends et { constructor(t) { super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t) } updateControlPoints(t, e) { const i = this.options; !i.tension && "monotone" !== i.cubicInterpolationMode || i.stepped || this._pointsUpdated || (jn(this._points, i, t, i.spanGaps ? this._loop : this._fullLoop, e), this._pointsUpdated = !0) } set points(t) { this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1 } get points() { return this._points } get segments() { return this._segments || (this._segments = $n(this, this.options.segment)) } first() { const t = this.segments; return t.length && this.points[t[0].start] } last() { const t = this.segments, i = t.length; return i && this.points[t[i - 1].end] } interpolate(t, e) { const i = this.options, s = t[e], o = this.points, a = Ci(this, { property: e, start: s, end: s }); if (!a.length) return; const r = [], l = $a(i); let c, h; for (c = 0, h = a.length; c < h; ++c) { const { start: d, end: u } = a[c], f = o[d], g = o[u]; if (f === g) { r.push(f); continue } const b = l(f, g, Math.abs((s - f[e]) / (g[e] - f[e])), i.stepped); b[e] = t[e], r.push(b) } return 1 === r.length ? r[0] : r } pathSegment(t, e, i) { return Qe(this)(t, this, e, i) } path(t, e, i) { const s = this.segments, o = Qe(this); let a = this._loop; e = e || 0, i = i || this.points.length - e; for (const r of s) a &= o(t, this, r, { start: e, end: e + i - 1 }); return !!a } draw(t, e, i, s) { (this.points || []).length && (this.options || {}).borderWidth && (t.save(), Ka(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } } function Cs(n, t, e, i) { const s = n.options, { [e]: o } = n.getProps([e], i); return Math.abs(t - o) < s.radius + s.hitRadius } k(ct, "id", "line"), k(ct, "defaults", { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }), k(ct, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }), k(ct, "descriptors", { _scriptable: !0, _indexable: t => "borderDash" !== t && "fill" !== t }); class oe extends et { constructor(t) { super(), k(this, "parsed"), k(this, "skip"), k(this, "stop"), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t) } inRange(t, e, i) { const s = this.options, { x: o, y: a } = this.getProps(["x", "y"], i); return Math.pow(t - o, 2) + Math.pow(e - a, 2) < Math.pow(s.hitRadius + s.radius, 2) } inXRange(t, e) { return Cs(this, t, "x", e) } inYRange(t, e) { return Cs(this, t, "y", e) } getCenterPoint(t) { const { x: e, y: i } = this.getProps(["x", "y"], t); return { x: e, y: i } } size(t) { let e = (t = t || this.options || {}).radius || 0; return e = Math.max(e, e && t.hoverRadius || 0), 2 * (e + (e && t.borderWidth || 0)) } draw(t, e) { const i = this.options; this.skip || i.radius < .1 || !_t(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, He(t, i, this.x, this.y)) } getRange() { const t = this.options || {}; return t.radius + t.hitRadius } } function Ls(n, t) { const { x: e, y: i, base: s, width: o, height: a } = n.getProps(["x", "y", "base", "width", "height"], t); let r, l, c, h, d; return n.horizontal ? (d = a / 2, r = Math.min(e, s), l = Math.max(e, s), c = i - d, h = i + d) : (d = o / 2, r = e - d, l = e + d, c = Math.min(i, s), h = Math.max(i, s)), { left: r, top: c, right: l, bottom: h } } function pt(n, t, e, i) { return n ? 0 : X(t, e, i) } function Ga(n, t, e) { const s = n.borderSkipped, o = qn(n.options.borderWidth); return { t: pt(s.top, o.top, 0, e), r: pt(s.right, o.right, 0, t), b: pt(s.bottom, o.bottom, 0, e), l: pt(s.left, o.left, 0, t) } } function qa(n, t, e) { const { enableBorderRadius: i } = n.getProps(["enableBorderRadius"]), s = n.options.borderRadius, o = kt(s), a = Math.min(t, e), r = n.borderSkipped, l = i || F(s); return { topLeft: pt(!l || r.top || r.left, o.topLeft, 0, a), topRight: pt(!l || r.top || r.right, o.topRight, 0, a), bottomLeft: pt(!l || r.bottom || r.left, o.bottomLeft, 0, a), bottomRight: pt(!l || r.bottom || r.right, o.bottomRight, 0, a) } } function Ja(n) { const t = Ls(n), e = t.right - t.left, i = t.bottom - t.top, s = Ga(n, e / 2, i / 2), o = qa(n, e / 2, i / 2); return { outer: { x: t.left, y: t.top, w: e, h: i, radius: o }, inner: { x: t.left + s.l, y: t.top + s.t, w: e - s.l - s.r, h: i - s.t - s.b, radius: { topLeft: Math.max(0, o.topLeft - Math.max(s.t, s.l)), topRight: Math.max(0, o.topRight - Math.max(s.t, s.r)), bottomLeft: Math.max(0, o.bottomLeft - Math.max(s.b, s.l)), bottomRight: Math.max(0, o.bottomRight - Math.max(s.b, s.r)) } } } } function ti(n, t, e, i) { const s = null === t, o = null === e, r = n && !(s && o) && Ls(n, i); return r && (s || ut(t, r.left, r.right)) && (o || ut(e, r.top, r.bottom)) } function Za(n) { return n.topLeft || n.topRight || n.bottomLeft || n.bottomRight } function Qa(n, t) { n.rect(t.x, t.y, t.w, t.h) } function ei(n, t, e = {}) { const i = n.x !== e.x ? -t : 0, s = n.y !== e.y ? -t : 0; return { x: n.x + i, y: n.y + s, w: n.w + ((n.x + n.w !== e.x + e.w ? t : 0) - i), h: n.h + ((n.y + n.h !== e.y + e.h ? t : 0) - s), radius: n.radius } } k(oe, "id", "point"), k(oe, "defaults", { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }), k(oe, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); class ae extends et { constructor(t) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t) } draw(t) { const { inflateAmount: e, options: { borderColor: i, backgroundColor: s } } = this, { inner: o, outer: a } = Ja(this), r = Za(a.radius) ? jt : Qa; t.save(), (a.w !== o.w || a.h !== o.h) && (t.beginPath(), r(t, ei(a, e, o)), t.clip(), r(t, ei(o, -e, a)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), r(t, ei(o, e)), t.fillStyle = s, t.fill(), t.restore() } inRange(t, e, i) { return ti(this, t, e, i) } inXRange(t, e) { return ti(this, t, null, e) } inYRange(t, e) { return ti(this, null, t, e) } getCenterPoint(t) { const { x: e, y: i, base: s, horizontal: o } = this.getProps(["x", "y", "base", "horizontal"], t); return { x: o ? (e + s) / 2 : e, y: o ? i : (i + s) / 2 } } getRange(t) { return "x" === t ? this.width / 2 : this.height / 2 } } k(ae, "id", "bar"), k(ae, "defaults", { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }), k(ae, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); var Os = Object.freeze({ __proto__: null, ArcElement: Rt, BarElement: ae, LineElement: ct, PointElement: oe }); const ii = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"], Ts = ii.map(n => n.replace("rgb(", "rgba(").replace(")", ", 0.5)")); function Rs(n) { return ii[n % ii.length] } function Es(n) { return Ts[n % Ts.length] } function tr(n, t) { return n.borderColor = Rs(t), n.backgroundColor = Es(t), ++t } function er(n, t) { return n.backgroundColor = n.data.map(() => Rs(t++)), t } function ir(n, t) { return n.backgroundColor = n.data.map(() => Es(t++)), t } function sr(n) { let t = 0; return (e, i) => { const s = n.getDatasetMeta(i).controller; s instanceof ft ? t = er(e, t) : s instanceof Ot ? t = ir(e, t) : s && (t = tr(e, t)) } } function zs(n) { let t; for (t in n) if (n[t].borderColor || n[t].backgroundColor) return !0; return !1 } function nr(n) { return n && (n.borderColor || n.backgroundColor) } var Fs = { id: "colors", defaults: { enabled: !0, forceOverride: !1 }, beforeLayout(n, t, e) { if (!e.enabled) return; const { data: { datasets: i }, options: s } = n.config, { elements: o } = s; if (!e.forceOverride && (zs(i) || nr(s) || o && zs(o))) return; const a = sr(n); i.forEach(a) } }; function or(n, t, e, i, s) { const o = s.samples || i; if (o >= e) return n.slice(t, t + e); const a = [], r = (e - 2) / (o - 2); let l = 0; const c = t + e - 1; let d, u, f, g, p, h = t; for (a[l++] = n[h], d = 0; d < o - 2; d++) { let x, b = 0, m = 0; const v = Math.floor((d + 1) * r) + 1 + t, y = Math.min(Math.floor((d + 2) * r) + 1, e) + t, _ = y - v; for (x = v; x < y; x++)b += n[x].x, m += n[x].y; b /= _, m /= _; const M = Math.floor(d * r) + 1 + t, w = Math.min(Math.floor((d + 1) * r) + 1, e) + t, { x: S, y: D } = n[h]; for (f = g = -1, x = M; x < w; x++)g = .5 * Math.abs((S - b) * (n[x].y - D) - (S - n[x].x) * (m - D)), g > f && (f = g, u = n[x], p = x); a[l++] = u, h = p } return a[l++] = n[c], a } function ar(n, t, e, i) { let a, r, l, c, h, d, u, f, g, p, s = 0, o = 0; const b = [], x = n[t].x, y = n[t + e - 1].x - x; for (a = t; a < t + e; ++a) { r = n[a], l = (r.x - x) / y * i, c = r.y; const _ = 0 | l; if (_ === h) c < g ? (g = c, d = a) : c > p && (p = c, u = a), s = (o * s + r.x) / ++o; else { const M = a - 1; if (!O(d) && !O(u)) { const w = Math.min(d, u), S = Math.max(d, u); w !== f && w !== M && b.push(de(he({}, n[w]), { x: s })), S !== f && S !== M && b.push(de(he({}, n[S]), { x: s })) } a > 0 && M !== f && b.push(n[M]), b.push(r), h = _, o = 0, g = p = c, d = u = f = a } } return b } function Is(n) { if (n._decimated) { const t = n._data; delete n._decimated, delete n._data, Object.defineProperty(n, "data", { configurable: !0, enumerable: !0, writable: !0, value: t }) } } function Bs(n) { n.data.datasets.forEach(t => { Is(t) }) } function rr(n, t) { const e = t.length; let s, i = 0; const { iScale: o } = n, { min: a, max: r, minDefined: l, maxDefined: c } = o.getUserBounds(); return l && (i = X(Wt(t, o.axis, a).lo, 0, e - 1)), s = c ? X(Wt(t, o.axis, r).hi + 1, i, e) - i : e - i, { start: i, count: s } } var Vs = { id: "decimation", defaults: { algorithm: "min-max", enabled: !1 }, beforeElementsUpdate: (n, t, e) => { if (!e.enabled) return void Bs(n); const i = n.width; n.data.datasets.forEach((s, o) => { const { _data: a, indexAxis: r } = s, l = n.getDatasetMeta(o), c = a || s.data; if ("y" === Nt([r, n.options.indexAxis]) || !l.controller.supportsDecimation) return; const h = n.scales[l.xAxisID]; if ("linear" !== h.type && "time" !== h.type || n.options.parsing) return; let g, { start: d, count: u } = rr(l, c); if (u <= (e.threshold || 4 * i)) Is(s); else { switch (O(a) && (s._data = c, delete s.data, Object.defineProperty(s, "data", { configurable: !0, enumerable: !0, get: function () { return this._decimated }, set: function (p) { this._data = p } })), e.algorithm) { case "lttb": g = or(c, d, u, i, e); break; case "min-max": g = ar(c, d, u, i); break; default: throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`) }s._decimated = g } }) }, destroy(n) { Bs(n) } }; function lr(n, t, e) { const i = n.segments, s = n.points, o = t.points, a = []; for (const r of i) { let { start: l, end: c } = r; c = ni(l, c, s); const h = si(e, s[l], s[c], r.loop); if (!t.segments) { a.push({ source: r, target: h, start: s[l], end: s[c] }); continue } const d = Ci(t, h); for (const u of d) { const f = si(e, o[u.start], o[u.end], u.loop), g = Jn(r, s, f); for (const p of g) a.push({ source: p, target: u, start: { [e]: Ns(h, f, "start", Math.max) }, end: { [e]: Ns(h, f, "end", Math.min) } }) } } return a } function si(n, t, e, i) { if (i) return; let s = t[n], o = e[n]; return "angle" === n && (s = $t(s), o = $t(o)), { property: n, start: s, end: o } } function cr(n, t) { const { x: e = null, y: i = null } = n || {}, s = t.points, o = []; return t.segments.forEach(({ start: a, end: r }) => { r = ni(a, r, s); const l = s[a], c = s[r]; null !== i ? (o.push({ x: l.x, y: i }), o.push({ x: c.x, y: i })) : null !== e && (o.push({ x: e, y: l.y }), o.push({ x: e, y: c.y })) }), o } function ni(n, t, e) { for (; t > n; t--) { const i = e[t]; if (!isNaN(i.x) && !isNaN(i.y)) break } return t } function Ns(n, t, e, i) { return n && t ? i(n[e], t[e]) : n ? n[e] : t ? t[e] : 0 } function Hs(n, t) { let e = [], i = !1; return K(n) ? (i = !0, e = n) : e = cr(n, t), e.length ? new ct({ points: e, options: { tension: 0 }, _loop: i, _fullLoop: i }) : null } function Ws(n) { return n && !1 !== n.fill } function hr(n, t, e) { let s = n[t].fill; const o = [t]; let a; if (!e) return s; for (; !1 !== s && -1 === o.indexOf(s);) { if (!V(s)) return s; if (a = n[s], !a) return !1; if (a.visible) return s; o.push(s), s = a.fill } return !1 } function dr(n, t, e) { const i = pr(n); if (F(i)) return !isNaN(i.value) && i; let s = parseFloat(i); return V(s) && Math.floor(s) === s ? ur(i[0], t, s, e) : ["origin", "start", "end", "stack", "shape"].indexOf(i) >= 0 && i } function ur(n, t, e, i) { return ("-" === n || "+" === n) && (e = t + e), !(e === t || e < 0 || e >= i) && e } function fr(n, t) { let e = null; return "start" === n ? e = t.bottom : "end" === n ? e = t.top : F(n) ? e = t.getPixelForValue(n.value) : t.getBasePixel && (e = t.getBasePixel()), e } function gr(n, t, e) { let i; return i = "start" === n ? e : "end" === n ? t.options.reverse ? t.min : t.max : F(n) ? n.value : t.getBaseValue(), i } function pr(n) { const t = n.options, e = t.fill; let i = C(e && e.target, e); return void 0 === i && (i = !!t.backgroundColor), !1 !== i && null !== i && (!0 === i ? "origin" : i) } function mr(n) { const { scale: t, index: e, line: i } = n, s = [], o = i.segments, a = i.points, r = br(t, e); r.push(Hs({ x: null, y: t.bottom }, i)); for (let l = 0; l < o.length; l++) { const c = o[l]; for (let h = c.start; h <= c.end; h++)xr(s, a[h], r) } return new ct({ points: s, options: {} }) } function br(n, t) { const e = [], i = n.getMatchingVisibleMetas("line"); for (let s = 0; s < i.length; s++) { const o = i[s]; if (o.index === t) break; o.hidden || e.unshift(o.dataset) } return e } function xr(n, t, e) { const i = []; for (let s = 0; s < e.length; s++) { const o = e[s], { first: a, last: r, point: l } = _r(o, t, "x"); if (!(!l || a && r)) if (a) i.unshift(l); else if (n.push(l), !r) break } n.push(...i) } function _r(n, t, e) { const i = n.interpolate(t, e); if (!i) return {}; const s = i[e], o = n.segments, a = n.points; let r = !1, l = !1; for (let c = 0; c < o.length; c++) { const h = o[c], d = a[h.start][e], u = a[h.end][e]; if (ut(s, d, u)) { r = s === d, l = s === u; break } } return { first: r, last: l, point: i } } class js { constructor(t) { this.x = t.x, this.y = t.y, this.radius = t.radius } pathSegment(t, e, i) { const { x: s, y: o, radius: a } = this; return t.arc(s, o, a, (e = e || { start: 0, end: Y }).end, e.start, !0), !i.bounds } interpolate(t) { const { x: e, y: i, radius: s } = this, o = t.angle; return { x: e + Math.cos(o) * s, y: i + Math.sin(o) * s, angle: o } } } function yr(n) { const { chart: t, fill: e, line: i } = n; if (V(e)) return vr(t, e); if ("stack" === e) return mr(n); if ("shape" === e) return !0; const s = kr(n); return s instanceof js ? s : Hs(s, i) } function vr(n, t) { const e = n.getDatasetMeta(t); return e && n.isDatasetVisible(t) ? e.dataset : null } function kr(n) { return (n.scale || {}).getPointPositionForValue ? wr(n) : Mr(n) } function Mr(n) { const { scale: t = {}, fill: e } = n, i = fr(e, t); if (V(i)) { const s = t.isHorizontal(); return { x: s ? i : null, y: s ? null : i } } return null } function wr(n) { const { scale: t, fill: e } = n, i = t.options, s = t.getLabels().length, o = i.reverse ? t.max : t.min, a = gr(e, t, o), r = []; if (i.grid.circular) { const l = t.getPointPositionForValue(0, o); return new js({ x: l.x, y: l.y, radius: t.getDistanceFromCenterForValue(a) }) } for (let l = 0; l < s; ++l)r.push(t.getPointPositionForValue(l, a)); return r } function oi(n, t, e) { const i = yr(t), { line: s, scale: o, axis: a } = t, r = s.options, l = r.fill, c = r.backgroundColor, { above: h = c, below: d = c } = l || {}; i && s.points.length && (ge(n, e), Sr(n, { line: s, target: i, above: h, below: d, area: e, scale: o, axis: a }), pe(n)) } function Sr(n, t) { const { line: e, target: i, above: s, below: o, area: a, scale: r } = t, l = e._loop ? "angle" : t.axis; n.save(), "x" === l && o !== s && ($s(n, i, a.top), Us(n, { line: e, target: i, color: s, scale: r, property: l }), n.restore(), n.save(), $s(n, i, a.bottom)), Us(n, { line: e, target: i, color: o, scale: r, property: l }), n.restore() } function $s(n, t, e) { const { segments: i, points: s } = t; let o = !0, a = !1; n.beginPath(); for (const r of i) { const { start: l, end: c } = r, h = s[l], d = s[ni(l, c, s)]; o ? (n.moveTo(h.x, h.y), o = !1) : (n.lineTo(h.x, e), n.lineTo(h.x, h.y)), a = !!t.pathSegment(n, r, { move: a }), a ? n.closePath() : n.lineTo(d.x, e) } n.lineTo(t.first().x, e), n.closePath(), n.clip() } function Us(n, t) { const { line: e, target: i, property: s, color: o, scale: a } = t, r = lr(e, i, s); for (const { source: l, target: c, start: h, end: d } of r) { const { style: { backgroundColor: u = o } = {} } = l, f = !0 !== i; n.save(), n.fillStyle = u, Dr(n, a, f && si(s, h, d)), n.beginPath(); const g = !!e.pathSegment(n, l); let p; if (f) { g ? n.closePath() : Ys(n, i, d, s); const b = !!i.pathSegment(n, c, { move: g, reverse: !0 }); p = g && b, p || Ys(n, i, h, s) } n.closePath(), n.fill(p ? "evenodd" : "nonzero"), n.restore() } } function Dr(n, t, e) { const { top: i, bottom: s } = t.chart.chartArea, { property: o, start: a, end: r } = e || {}; "x" === o && (n.beginPath(), n.rect(a, i, r - a, s - i), n.clip()) } function Ys(n, t, e, i) { const s = t.interpolate(e, i); s && n.lineTo(s.x, s.y) } var Xs = { id: "filler", afterDatasetsUpdate(n, t, e) { const i = (n.data.datasets || []).length, s = []; let o, a, r, l; for (a = 0; a < i; ++a)o = n.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof ct && (l = { visible: n.isDatasetVisible(a), index: a, fill: dr(r, a, i), chart: n, axis: o.controller.options.indexAxis, scale: o.vScale, line: r }), o.$filler = l, s.push(l); for (a = 0; a < i; ++a)l = s[a], l && !1 !== l.fill && (l.fill = hr(s, a, e.propagate)) }, beforeDraw(n, t, e) { const i = "beforeDraw" === e.drawTime, s = n.getSortedVisibleDatasetMetas(), o = n.chartArea; for (let a = s.length - 1; a >= 0; --a) { const r = s[a].$filler; !r || (r.line.updateControlPoints(o, r.axis), i && r.fill && oi(n.ctx, r, o)) } }, beforeDatasetsDraw(n, t, e) { if ("beforeDatasetsDraw" !== e.drawTime) return; const i = n.getSortedVisibleDatasetMetas(); for (let s = i.length - 1; s >= 0; --s) { const o = i[s].$filler; Ws(o) && oi(n.ctx, o, n.chartArea) } }, beforeDatasetDraw(n, t, e) { const i = t.meta.$filler; !Ws(i) || "beforeDatasetDraw" !== e.drawTime || oi(n.ctx, i, n.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const Ks = (n, t) => { let { boxHeight: e = t, boxWidth: i = t } = n; return n.usePointStyle && (e = Math.min(e, t), i = n.pointStyleWidth || Math.min(i, t)), { boxWidth: i, boxHeight: e, itemHeight: Math.max(t, e) } }, Pr = (n, t) => null !== n && null !== t && n.datasetIndex === t.datasetIndex && n.index === t.index; class Gs extends et { constructor(t) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e, i) { this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const t = this.options.labels || {}; let e = E(t.generateLabels, [this.chart], this) || []; t.filter && (e = e.filter(i => t.filter(i, this.chart.data))), t.sort && (e = e.sort((i, s) => t.sort(i, s, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e } fit() { const { options: t, ctx: e } = this; if (!t.display) return void (this.width = this.height = 0); const i = t.labels, s = N(i.font), o = s.size, a = this._computeTitleHeight(), { boxWidth: r, itemHeight: l } = Ks(i, o); let c, h; e.font = s.string, this.isHorizontal() ? (c = this.maxWidth, h = this._fitRows(a, o, r, l) + 10) : (h = this.maxHeight, c = this._fitCols(a, s, r, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight) } _fitRows(t, e, i, s) { const { ctx: o, maxWidth: a, options: { labels: { padding: r } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], h = s + r; let d = t; o.textAlign = "left", o.textBaseline = "middle"; let u = -1, f = -h; return this.legendItems.forEach((g, p) => { const b = i + e / 2 + o.measureText(g.text).width; (0 === p || c[c.length - 1] + b + 2 * r > a) && (d += h, c[c.length - (p > 0 ? 0 : 1)] = 0, f += h, u++), l[p] = { left: 0, top: f, row: u, width: b, height: s }, c[c.length - 1] += b + r }), d } _fitCols(t, e, i, s) { const { ctx: o, maxHeight: a, options: { labels: { padding: r } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], h = a - t; let d = r, u = 0, f = 0, g = 0, p = 0; return this.legendItems.forEach((b, m) => { const { itemWidth: x, itemHeight: v } = Ar(i, e, o, b, s); m > 0 && f + v + 2 * r > h && (d += u + r, c.push({ width: u, height: f }), g += u + r, p++, u = f = 0), l[m] = { left: g, top: f, col: p, width: x, height: v }, u = Math.max(u, x), f += v + r }), d += u, c.push({ width: u, height: f }), d } adjustHitBoxes() { if (!this.options.display) return; const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: s }, rtl: o } } = this, a = Lt(o, this.left, this.width); if (this.isHorizontal()) { let r = 0, l = U(i, this.left + s, this.right - this.lineWidths[r]); for (const c of e) r !== c.row && (r = c.row, l = U(i, this.left + s, this.right - this.lineWidths[r])), c.top += this.top + t + s, c.left = a.leftForLtr(a.x(l), c.width), l += c.width + s } else { let r = 0, l = U(i, this.top + t + s, this.bottom - this.columnSizes[r].height); for (const c of e) c.col !== r && (r = c.col, l = U(i, this.top + t + s, this.bottom - this.columnSizes[r].height)), c.top = l, c.left += this.left + s, c.left = a.leftForLtr(a.x(c.left), c.width), l += c.height + s } } isHorizontal() { return "top" === this.options.position || "bottom" === this.options.position } draw() { if (this.options.display) { const t = this.ctx; ge(t, this), this._draw(), pe(t) } } _draw() { const { options: t, columnSizes: e, lineWidths: i, ctx: s } = this, { align: o, labels: a } = t, r = I.color, l = Lt(t.rtl, this.left, this.width), c = N(a.font), { padding: h } = a, d = c.size, u = d / 2; let f; this.drawTitle(), s.textAlign = l.textAlign("left"), s.textBaseline = "middle", s.lineWidth = .5, s.font = c.string; const { boxWidth: g, boxHeight: p, itemHeight: b } = Ks(a, d), v = this.isHorizontal(), y = this._computeTitleHeight(); f = v ? { x: U(o, this.left + h, this.right - i[0]), y: this.top + h + y, line: 0 } : { x: this.left + h, y: U(o, this.top + y + h, this.bottom - e[0].height), line: 0 }, Li(this.ctx, t.textDirection); const _ = b + h; this.legendItems.forEach((M, w) => { s.strokeStyle = M.fontColor, s.fillStyle = M.fontColor; const S = s.measureText(M.text).width, D = l.textAlign(M.textAlign || (M.textAlign = a.textAlign)), P = g + u + S; let A = f.x, L = f.y; l.setWidth(this.width), v ? w > 0 && A + P + h > this.right && (L = f.y += _, f.line++, A = f.x = U(o, this.left + h, this.right - i[f.line])) : w > 0 && L + _ > this.bottom && (A = f.x = A + e[f.line].width + h, f.line++, L = f.y = U(o, this.top + y + h, this.bottom - e[f.line].height)), function (M, w, S) { if (isNaN(g) || g <= 0 || isNaN(p) || p < 0) return; s.save(); const D = C(S.lineWidth, 1); if (s.fillStyle = C(S.fillStyle, r), s.lineCap = C(S.lineCap, "butt"), s.lineDashOffset = C(S.lineDashOffset, 0), s.lineJoin = C(S.lineJoin, "miter"), s.lineWidth = D, s.strokeStyle = C(S.strokeStyle, r), s.setLineDash(C(S.lineDash, [])), a.usePointStyle) { const P = { radius: p * Math.SQRT2 / 2, pointStyle: S.pointStyle, rotation: S.rotation, borderWidth: D }, A = l.xPlus(M, g / 2); Qn(s, P, A, w + u, a.pointStyleWidth && g) } else { const P = w + Math.max((d - p) / 2, 0), A = l.leftForLtr(M, g), L = kt(S.borderRadius); s.beginPath(), Object.values(L).some(H => 0 !== H) ? jt(s, { x: A, y: P, w: g, h: p, radius: L }) : s.rect(A, P, g, p), s.fill(), 0 !== D && s.stroke() } s.restore() }(l.x(A), L, M), A = Zn(D, A + g + u, v ? A + P : this.right, t.rtl), function (M, w, S) { vt(s, S.text, M, w + b / 2, c, { strikethrough: S.hidden, textAlign: l.textAlign(S.textAlign) }) }(l.x(A), L, M), v ? f.x += P + h : f.y += "string" != typeof M.text ? qs(M, c.lineHeight) : _ }), Oi(this.ctx, t.textDirection) } drawTitle() { const t = this.options, e = t.title, i = N(e.font), s = $(e.padding); if (!e.display) return; const o = Lt(t.rtl, this.left, this.width), a = this.ctx, r = e.position, c = s.top + i.size / 2; let h, d = this.left, u = this.width; if (this.isHorizontal()) u = Math.max(...this.lineWidths), h = this.top + c, d = U(t.align, d, this.right - u); else { const g = this.columnSizes.reduce((p, b) => Math.max(p, b.height), 0); h = c + U(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight()) } const f = U(r, d, d + u); a.textAlign = o.textAlign(Ne(r)), a.textBaseline = "middle", a.strokeStyle = e.color, a.fillStyle = e.color, a.font = i.string, vt(a, e.text, f, h, i) } _computeTitleHeight() { const t = this.options.title, e = N(t.font), i = $(t.padding); return t.display ? e.lineHeight + i.height : 0 } _getLegendItemAt(t, e) { let i, s, o; if (ut(t, this.left, this.right) && ut(e, this.top, this.bottom)) for (o = this.legendHitBoxes, i = 0; i < o.length; ++i)if (s = o[i], ut(t, s.left, s.left + s.width) && ut(e, s.top, s.top + s.height)) return this.legendItems[i]; return null } handleEvent(t) { const e = this.options; if (!Or(t.type, e)) return; const i = this._getLegendItemAt(t.x, t.y); if ("mousemove" === t.type || "mouseout" === t.type) { const s = this._hoveredItem, o = Pr(s, i); s && !o && E(e.onLeave, [t, s, this], this), this._hoveredItem = i, i && !o && E(e.onHover, [t, i, this], this) } else i && E(e.onClick, [t, i, this], this) } } function Ar(n, t, e, i, s) { return { itemWidth: Cr(i, n, t, e), itemHeight: Lr(s, i, t.lineHeight) } } function Cr(n, t, e, i) { let s = n.text; return s && "string" != typeof s && (s = s.reduce((o, a) => o.length > a.length ? o : a)), t + e.size / 2 + i.measureText(s).width } function Lr(n, t, e) { let i = n; return "string" != typeof t.text && (i = qs(t, e)), i } function qs(n, t) { return t * (n.text ? n.text.length + .5 : 0) } function Or(n, t) { return !(("mousemove" !== n && "mouseout" !== n || !t.onHover && !t.onLeave) && (!t.onClick || "click" !== n && "mouseup" !== n)) } var Js = { id: "legend", _element: Gs, start(n, t, e) { const i = n.legend = new Gs({ ctx: n.ctx, options: e, chart: n }); W.configure(n, i, e), W.addBox(n, i) }, stop(n) { W.removeBox(n, n.legend), delete n.legend }, beforeUpdate(n, t, e) { const i = n.legend; W.configure(n, i, e), i.options = e }, afterUpdate(n) { const t = n.legend; t.buildLabels(), t.adjustHitBoxes() }, afterEvent(n, t) { t.replay || n.legend.handleEvent(t.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(n, t, e) { const i = t.datasetIndex, s = e.chart; s.isDatasetVisible(i) ? (s.hide(i), t.hidden = !0) : (s.show(i), t.hidden = !1) }, onHover: null, onLeave: null, labels: { color: n => n.chart.options.color, boxWidth: 40, padding: 10, generateLabels(n) { const t = n.data.datasets, { labels: { usePointStyle: e, pointStyle: i, textAlign: s, color: o, useBorderRadius: a, borderRadius: r } } = n.legend.options; return n._getSortedDatasetMetas().map(l => { const c = l.controller.getStyle(e ? 0 : void 0), h = $(c.borderWidth); return { text: t[l.index].label, fillStyle: c.backgroundColor, fontColor: o, hidden: !l.visible, lineCap: c.borderCapStyle, lineDash: c.borderDash, lineDashOffset: c.borderDashOffset, lineJoin: c.borderJoinStyle, lineWidth: (h.width + h.height) / 4, strokeStyle: c.borderColor, pointStyle: i || c.pointStyle, rotation: c.rotation, textAlign: s || c.textAlign, borderRadius: a && (r || c.borderRadius), datasetIndex: l.index } }, this) } }, title: { color: n => n.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: n => !n.startsWith("on"), labels: { _scriptable: n => !["generateLabels", "filter", "sort"].includes(n) } } }; class ai extends et { constructor(t) { super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e) { const i = this.options; if (this.left = 0, this.top = 0, !i.display) return void (this.width = this.height = this.right = this.bottom = 0); this.width = this.right = t, this.height = this.bottom = e; const s = K(i.text) ? i.text.length : 1; this._padding = $(i.padding); const o = s * N(i.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = o : this.width = o } isHorizontal() { const t = this.options.position; return "top" === t || "bottom" === t } _drawArgs(t) { const { top: e, left: i, bottom: s, right: o, options: a } = this, r = a.align; let c, h, d, l = 0; return this.isHorizontal() ? (h = U(r, i, o), d = e + t, c = o - i) : ("left" === a.position ? (h = i + t, d = U(r, s, e), l = -.5 * rt) : (h = o - t, d = U(r, e, s), l = .5 * rt), c = s - e), { titleX: h, titleY: d, maxWidth: c, rotation: l } } draw() { const t = this.ctx, e = this.options; if (!e.display) return; const i = N(e.font), o = i.lineHeight / 2 + this._padding.top, { titleX: a, titleY: r, maxWidth: l, rotation: c } = this._drawArgs(o); vt(t, e.text, 0, 0, i, { color: e.color, maxWidth: l, rotation: c, textAlign: Ne(e.align), textBaseline: "middle", translation: [a, r] }) } } function Tr(n, t) { const e = new ai({ ctx: n.ctx, options: t, chart: n }); W.configure(n, e, t), W.addBox(n, e), n.titleBlock = e } var Zs = { id: "title", _element: ai, start(n, t, e) { Tr(n, e) }, stop(n) { W.removeBox(n, n.titleBlock), delete n.titleBlock }, beforeUpdate(n, t, e) { const i = n.titleBlock; W.configure(n, i, e), i.options = e }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Ce = new WeakMap; var Qs = { id: "subtitle", start(n, t, e) { const i = new ai({ ctx: n.ctx, options: e, chart: n }); W.configure(n, i, e), W.addBox(n, i), Ce.set(n, i) }, stop(n) { W.removeBox(n, Ce.get(n)), Ce.delete(n) }, beforeUpdate(n, t, e) { const i = Ce.get(n); W.configure(n, i, e), i.options = e }, defaults: { align: "center", display: !1, font: { weight: "normal" }, fullSize: !0, padding: 0, position: "top", text: "", weight: 1500 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const re = { average(n) { if (!n.length) return !1; let t, e, i = 0, s = 0, o = 0; for (t = 0, e = n.length; t < e; ++t) { const a = n[t].element; if (a && a.hasValue()) { const r = a.tooltipPosition(); i += r.x, s += r.y, ++o } } return { x: i / o, y: s / o } }, nearest(n, t) { if (!n.length) return !1; let o, a, r, e = t.x, i = t.y, s = Number.POSITIVE_INFINITY; for (o = 0, a = n.length; o < a; ++o) { const l = n[o].element; if (l && l.hasValue()) { const c = l.getCenterPoint(), h = to(t, c); h < s && (s = h, r = l) } } if (r) { const l = r.tooltipPosition(); e = l.x, i = l.y } return { x: e, y: i } } }; function at(n, t) { return t && (K(t) ? Array.prototype.push.apply(n, t) : n.push(t)), n } function ht(n) { return ("string" == typeof n || n instanceof String) && n.indexOf("\n") > -1 ? n.split("\n") : n } function Rr(n, t) { const { element: e, datasetIndex: i, index: s } = t, o = n.getDatasetMeta(i).controller, { label: a, value: r } = o.getLabelAndValue(s); return { chart: n, label: a, parsed: o.getParsed(s), raw: n.data.datasets[i].data[s], formattedValue: r, dataset: o.getDataset(), dataIndex: s, datasetIndex: i, element: e } } function tn(n, t) { const e = n.chart.ctx, { body: i, footer: s, title: o } = n, { boxWidth: a, boxHeight: r } = t, l = N(t.bodyFont), c = N(t.titleFont), h = N(t.footerFont), d = o.length, u = s.length, f = i.length, g = $(t.padding); let p = g.height, b = 0, m = i.reduce((y, _) => y + _.before.length + _.lines.length + _.after.length, 0); m += n.beforeBody.length + n.afterBody.length, d && (p += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), m && (p += f * (t.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (m - f) * l.lineHeight + (m - 1) * t.bodySpacing), u && (p += t.footerMarginTop + u * h.lineHeight + (u - 1) * t.footerSpacing); let x = 0; const v = function (y) { b = Math.max(b, e.measureText(y).width + x) }; return e.save(), e.font = c.string, T(n.title, v), e.font = l.string, T(n.beforeBody.concat(n.afterBody), v), x = t.displayColors ? a + 2 + t.boxPadding : 0, T(i, y => { T(y.before, v), T(y.lines, v), T(y.after, v) }), x = 0, e.font = h.string, T(n.footer, v), e.restore(), b += g.width, { width: b, height: p } } function Er(n, t) { const { y: e, height: i } = t; return e < i / 2 ? "top" : e > n.height - i / 2 ? "bottom" : "center" } function zr(n, t, e, i) { const { x: s, width: o } = i, a = e.caretSize + e.caretPadding; if ("left" === n && s + o + a > t.width || "right" === n && s - o - a < 0) return !0 } function Fr(n, t, e, i) { const { x: s, width: o } = e, { width: a, chartArea: { left: r, right: l } } = n; let c = "center"; return "center" === i ? c = s <= (r + l) / 2 ? "left" : "right" : s <= o / 2 ? c = "left" : s >= a - o / 2 && (c = "right"), zr(c, n, t, e) && (c = "center"), c } function en(n, t, e) { const i = e.yAlign || t.yAlign || Er(n, e); return { xAlign: e.xAlign || t.xAlign || Fr(n, t, e, i), yAlign: i } } function Ir(n, t) { let { x: e, width: i } = n; return "right" === t ? e -= i : "center" === t && (e -= i / 2), e } function Br(n, t, e) { let { y: i, height: s } = n; return "top" === t ? i += e : i -= "bottom" === t ? s + e : s / 2, i } function sn(n, t, e, i) { const { caretSize: s, caretPadding: o, cornerRadius: a } = n, { xAlign: r, yAlign: l } = e, c = s + o, { topLeft: h, topRight: d, bottomLeft: u, bottomRight: f } = kt(a); let g = Ir(t, r); const p = Br(t, l, c); return "center" === l ? "left" === r ? g += c : "right" === r && (g -= c) : "left" === r ? g -= Math.max(h, u) + s : "right" === r && (g += Math.max(d, f) + s), { x: X(g, 0, i.width - t.width), y: X(p, 0, i.height - t.height) } } function Le(n, t, e) { const i = $(e.padding); return "center" === t ? n.x + n.width / 2 : "right" === t ? n.x + n.width - i.right : n.x + i.left } function nn(n) { return at([], ht(n)) } function Vr(n, t, e) { return bt(n, { tooltip: t, tooltipItems: e, type: "tooltip" }) } function on(n, t) { const e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks; return e ? n.override(e) : n } const an = { beforeTitle: lt, title(n) { if (n.length > 0) { const t = n[0], e = t.chart.data.labels, i = e ? e.length : 0; if (this && this.options && "dataset" === this.options.mode) return t.dataset.label || ""; if (t.label) return t.label; if (i > 0 && t.dataIndex < i) return e[t.dataIndex] } return "" }, afterTitle: lt, beforeBody: lt, beforeLabel: lt, label(n) { if (this && this.options && "dataset" === this.options.mode) return n.label + ": " + n.formattedValue || n.formattedValue; let t = n.dataset.label || ""; t && (t += ": "); const e = n.formattedValue; return O(e) || (t += e), t }, labelColor(n) { const e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex); return { borderColor: e.borderColor, backgroundColor: e.backgroundColor, borderWidth: e.borderWidth, borderDash: e.borderDash, borderDashOffset: e.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(n) { const e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex); return { pointStyle: e.pointStyle, rotation: e.rotation } }, afterLabel: lt, afterBody: lt, beforeFooter: lt, footer: lt, afterFooter: lt }; function G(n, t, e, i) { const s = n[t].call(e, i); return void 0 === s ? an[t].call(e, i) : s } class ri extends et { constructor(t) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(t) { this.options = t, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const t = this._cachedAnimations; if (t) return t; const e = this.chart, i = this.options.setContext(this.getContext()), s = i.enabled && e.options.animation && i.animations, o = new je(this.chart, s); return s._cacheable && (this._cachedAnimations = Object.freeze(o)), o } getContext() { return this.$context || (this.$context = Vr(this.chart.getContext(), this, this._tooltipItems)) } getTitle(t, e) { const { callbacks: i } = e, s = G(i, "beforeTitle", this, t), o = G(i, "title", this, t), a = G(i, "afterTitle", this, t); let r = []; return r = at(r, ht(s)), r = at(r, ht(o)), r = at(r, ht(a)), r } getBeforeBody(t, e) { return nn(G(e.callbacks, "beforeBody", this, t)) } getBody(t, e) { const { callbacks: i } = e, s = []; return T(t, o => { const a = { before: [], lines: [], after: [] }, r = on(i, o); at(a.before, ht(G(r, "beforeLabel", this, o))), at(a.lines, G(r, "label", this, o)), at(a.after, ht(G(r, "afterLabel", this, o))), s.push(a) }), s } getAfterBody(t, e) { return nn(G(e.callbacks, "afterBody", this, t)) } getFooter(t, e) { const { callbacks: i } = e, s = G(i, "beforeFooter", this, t), o = G(i, "footer", this, t), a = G(i, "afterFooter", this, t); let r = []; return r = at(r, ht(s)), r = at(r, ht(o)), r = at(r, ht(a)), r } _createItems(t) { const e = this._active, i = this.chart.data, s = [], o = [], a = []; let l, c, r = []; for (l = 0, c = e.length; l < c; ++l)r.push(Rr(this.chart, e[l])); return t.filter && (r = r.filter((h, d, u) => t.filter(h, d, u, i))), t.itemSort && (r = r.sort((h, d) => t.itemSort(h, d, i))), T(r, h => { const d = on(t.callbacks, h); s.push(G(d, "labelColor", this, h)), o.push(G(d, "labelPointStyle", this, h)), a.push(G(d, "labelTextColor", this, h)) }), this.labelColors = s, this.labelPointStyles = o, this.labelTextColors = a, this.dataPoints = r, r } update(t, e) { const i = this.options.setContext(this.getContext()), s = this._active; let o, a = []; if (s.length) { const r = re[i.position].call(this, s, this._eventPosition); a = this._createItems(i), this.title = this.getTitle(a, i), this.beforeBody = this.getBeforeBody(a, i), this.body = this.getBody(a, i), this.afterBody = this.getAfterBody(a, i), this.footer = this.getFooter(a, i); const l = this._size = tn(this, i), c = Object.assign({}, r, l), h = en(this.chart, i, c), d = sn(i, c, h, this.chart); this.xAlign = h.xAlign, this.yAlign = h.yAlign, o = { opacity: 1, x: d.x, y: d.y, width: l.width, height: l.height, caretX: r.x, caretY: r.y } } else 0 !== this.opacity && (o = { opacity: 0 }); this._tooltipItems = a, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && i.external && i.external.call(this, { chart: this.chart, tooltip: this, replay: e }) } drawCaret(t, e, i, s) { const o = this.getCaretPosition(t, i, s); e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3) } getCaretPosition(t, e, i) { const { xAlign: s, yAlign: o } = this, { caretSize: a, cornerRadius: r } = i, { topLeft: l, topRight: c, bottomLeft: h, bottomRight: d } = kt(r), { x: u, y: f } = t, { width: g, height: p } = e; let b, m, x, v, y, _; return "center" === o ? (y = f + p / 2, "left" === s ? (b = u, m = b - a, v = y + a, _ = y - a) : (b = u + g, m = b + a, v = y - a, _ = y + a), x = b) : (m = "left" === s ? u + Math.max(l, h) + a : "right" === s ? u + g - Math.max(c, d) - a : this.caretX, "top" === o ? (v = f, y = v - a, b = m - a, x = m + a) : (v = f + p, y = v + a, b = m + a, x = m - a), _ = v), { x1: b, x2: m, x3: x, y1: v, y2: y, y3: _ } } drawTitle(t, e, i) { const s = this.title, o = s.length; let a, r, l; if (o) { const c = Lt(i.rtl, this.x, this.width); for (t.x = Le(this, i.titleAlign, i), e.textAlign = c.textAlign(i.titleAlign), e.textBaseline = "middle", a = N(i.titleFont), r = i.titleSpacing, e.fillStyle = i.titleColor, e.font = a.string, l = 0; l < o; ++l)e.fillText(s[l], c.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + r, l + 1 === o && (t.y += i.titleMarginBottom - r) } } _drawColorBox(t, e, i, s, o) { const a = this.labelColors[i], r = this.labelPointStyles[i], { boxHeight: l, boxWidth: c } = o, h = N(o.bodyFont), d = Le(this, "left", o), u = s.x(d), g = e.y + (l < h.lineHeight ? (h.lineHeight - l) / 2 : 0); if (o.usePointStyle) { const p = { radius: Math.min(c, l) / 2, pointStyle: r.pointStyle, rotation: r.rotation, borderWidth: 1 }, b = s.leftForLtr(u, c) + c / 2, m = g + l / 2; t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, He(t, p, b, m), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, He(t, p, b, m) } else { t.lineWidth = F(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0; const p = s.leftForLtr(u, c), b = s.leftForLtr(s.xPlus(u, 1), c - 2), m = kt(a.borderRadius); Object.values(m).some(x => 0 !== x) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, jt(t, { x: p, y: g, w: c, h: l, radius: m }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), jt(t, { x: b, y: g + 1, w: c - 2, h: l - 2, radius: m }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(p, g, c, l), t.strokeRect(p, g, c, l), t.fillStyle = a.backgroundColor, t.fillRect(b, g + 1, c - 2, l - 2)) } t.fillStyle = this.labelTextColors[i] } drawBody(t, e, i) { const { body: s } = this, { bodySpacing: o, bodyAlign: a, displayColors: r, boxHeight: l, boxWidth: c, boxPadding: h } = i, d = N(i.bodyFont); let u = d.lineHeight, f = 0; const g = Lt(i.rtl, this.x, this.width), p = function (S) { e.fillText(S, g.x(t.x + f), t.y + u / 2), t.y += u + o }, b = g.textAlign(a); let m, x, v, y, _, M, w; for (e.textAlign = a, e.textBaseline = "middle", e.font = d.string, t.x = Le(this, b, i), e.fillStyle = i.bodyColor, T(this.beforeBody, p), f = r && "right" !== b ? "center" === a ? c / 2 + h : c + 2 + h : 0, y = 0, M = s.length; y < M; ++y) { for (m = s[y], x = this.labelTextColors[y], e.fillStyle = x, T(m.before, p), v = m.lines, r && v.length && (this._drawColorBox(e, t, y, g, i), u = Math.max(d.lineHeight, l)), _ = 0, w = v.length; _ < w; ++_)p(v[_]), u = d.lineHeight; T(m.after, p) } f = 0, u = d.lineHeight, T(this.afterBody, p), t.y -= o } drawFooter(t, e, i) { const s = this.footer, o = s.length; let a, r; if (o) { const l = Lt(i.rtl, this.x, this.width); for (t.x = Le(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = l.textAlign(i.footerAlign), e.textBaseline = "middle", a = N(i.footerFont), e.fillStyle = i.footerColor, e.font = a.string, r = 0; r < o; ++r)e.fillText(s[r], l.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + i.footerSpacing } } drawBackground(t, e, i, s) { const { xAlign: o, yAlign: a } = this, { x: r, y: l } = t, { width: c, height: h } = i, { topLeft: d, topRight: u, bottomLeft: f, bottomRight: g } = kt(s.cornerRadius); e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(r + d, l), "top" === a && this.drawCaret(t, e, i, s), e.lineTo(r + c - u, l), e.quadraticCurveTo(r + c, l, r + c, l + u), "center" === a && "right" === o && this.drawCaret(t, e, i, s), e.lineTo(r + c, l + h - g), e.quadraticCurveTo(r + c, l + h, r + c - g, l + h), "bottom" === a && this.drawCaret(t, e, i, s), e.lineTo(r + f, l + h), e.quadraticCurveTo(r, l + h, r, l + h - f), "center" === a && "left" === o && this.drawCaret(t, e, i, s), e.lineTo(r, l + d), e.quadraticCurveTo(r, l, r + d, l), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke() } _updateAnimationTarget(t) { const e = this.chart, i = this.$animations, s = i && i.x, o = i && i.y; if (s || o) { const a = re[t.position].call(this, this._active, this._eventPosition); if (!a) return; const r = this._size = tn(this, t), l = Object.assign({}, a, this._size), c = en(e, t, l), h = sn(t, l, c, e); (s._to !== h.x || o._to !== h.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = r.width, this.height = r.height, this.caretX = a.x, this.caretY = a.y, this._resolveAnimations().update(this, h)) } } _willRender() { return !!this.opacity } draw(t) { const e = this.options.setContext(this.getContext()); let i = this.opacity; if (!i) return; this._updateAnimationTarget(e); const s = { width: this.width, height: this.height }, o = { x: this.x, y: this.y }; i = Math.abs(i) < .001 ? 0 : i; const a = $(e.padding); e.enabled && (this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length) && (t.save(), t.globalAlpha = i, this.drawBackground(o, t, s, e), Li(t, e.textDirection), o.y += a.top, this.drawTitle(o, t, e), this.drawBody(o, t, e), this.drawFooter(o, t, e), Oi(t, e.textDirection), t.restore()) } getActiveElements() { return this._active || [] } setActiveElements(t, e) { const i = this._active, s = t.map(({ datasetIndex: r, index: l }) => { const c = this.chart.getDatasetMeta(r); if (!c) throw new Error("Cannot find a dataset at index " + r); return { datasetIndex: r, element: c.data[l], index: l } }), o = !xe(i, s), a = this._positionChanged(s, e); (o || a) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(t, e, i = !0) { if (e && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const s = this.options, o = this._active || [], a = this._getActiveElements(t, o, e, i), r = this._positionChanged(a, t), l = e || !xe(a, o) || r; return l && (this._active = a, (s.enabled || s.external) && (this._eventPosition = { x: t.x, y: t.y }, this.update(!0, e))), l } _getActiveElements(t, e, i, s) { const o = this.options; if ("mouseout" === t.type) return []; if (!s) return e; const a = this.chart.getElementsAtEventForMode(t, o.mode, o, i); return o.reverse && a.reverse(), a } _positionChanged(t, e) { const { caretX: i, caretY: s, options: o } = this, a = re[o.position].call(this, t, e); return !1 !== a && (i !== a.x || s !== a.y) } } k(ri, "positioners", re); var rn = { id: "tooltip", _element: ri, positioners: re, afterInit(n, t, e) { e && (n.tooltip = new ri({ chart: n, options: e })) }, beforeUpdate(n, t, e) { n.tooltip && n.tooltip.initialize(e) }, reset(n, t, e) { n.tooltip && n.tooltip.initialize(e) }, afterDraw(n) { const t = n.tooltip; if (t && t._willRender()) { const e = { tooltip: t }; if (!1 === n.notifyPlugins("beforeTooltipDraw", de(he({}, e), { cancelable: !0 }))) return; t.draw(n.ctx), n.notifyPlugins("afterTooltipDraw", e) } }, afterEvent(n, t) { n.tooltip && n.tooltip.handleEvent(t.event, t.replay, t.inChartArea) && (t.changed = !0) }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (n, t) => t.bodyFont.size, boxWidth: (n, t) => t.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: an }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: n => "filter" !== n && "itemSort" !== n && "external" !== n, _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }, ln = Object.freeze({ __proto__: null, Colors: Fs, Decimation: Vs, Filler: Xs, Legend: Js, SubTitle: Qs, Title: Zs, Tooltip: rn }); const Nr = (n, t, e, i) => ("string" == typeof t ? (e = n.push(t) - 1, i.unshift({ index: e, label: t })) : isNaN(t) && (e = null), e); function Hr(n, t, e, i) { const s = n.indexOf(t); return -1 === s ? Nr(n, t, e, i) : s !== n.lastIndexOf(t) ? e : s } const Wr = (n, t) => null === n ? null : X(Math.round(n), 0, t); function cn(n) { const t = this.getLabels(); return n >= 0 && n < t.length ? t[n] : n } class Oe extends mt { constructor(t) { super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(t) { const e = this._addedLabels; if (e.length) { const i = this.getLabels(); for (const { index: s, label: o } of e) i[s] === o && i.splice(s, 1); this._addedLabels = [] } super.init(t) } parse(t, e) { if (O(t)) return null; const i = this.getLabels(); return e = isFinite(e) && i[e] === t ? e : Hr(i, t, C(e, t), this._addedLabels), Wr(e, i.length - 1) } determineDataLimits() { const { minDefined: t, maxDefined: e } = this.getUserBounds(); let { min: i, max: s } = this.getMinMax(!0); "ticks" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s } buildTicks() { const t = this.min, e = this.max, i = this.options.offset, s = []; let o = this.getLabels(); o = 0 === t && e === o.length - 1 ? o : o.slice(t, e + 1), this._valueRange = Math.max(o.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0); for (let a = t; a <= e; a++)s.push({ value: a }); return s } getLabelForValue(t) { return cn.call(this, t) } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(t) { return "number" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getPixelForTick(t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getValueForPixel(t) { return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange) } getBasePixel() { return this.bottom } } function jr(n, t) { const e = [], { bounds: s, step: o, min: a, max: r, precision: l, count: c, maxTicks: h, maxDigits: d, includeBounds: u } = n, f = o || 1, g = h - 1, { min: p, max: b } = t, m = !O(a), x = !O(r), v = !O(c), y = (b - p) / (d + 1); let M, w, S, D, _ = Ri((b - p) / g / f) * f; if (_ < 1e-14 && !m && !x) return [{ value: p }, { value: b }]; D = Math.ceil(b / _) - Math.floor(p / _), D > g && (_ = Ri(D * _ / g / f) * f), O(l) || (M = Math.pow(10, l), _ = Math.ceil(_ * M) / M), "ticks" === s ? (w = Math.floor(p / _) * _, S = Math.ceil(b / _) * _) : (w = p, S = b), m && x && o && eo((r - a) / o, _ / 1e3) ? (D = Math.round(Math.min((r - a) / _, h)), _ = (r - a) / D, w = a, S = r) : v ? (w = m ? a : w, S = x ? r : S, D = c - 1, _ = (S - w) / D) : (D = (S - w) / _, D = We(D, Math.round(D), _ / 1e3) ? Math.round(D) : Math.ceil(D)); const P = Math.max(Ei(_), Ei(w)); M = Math.pow(10, O(l) ? P : l), w = Math.round(w * M) / M, S = Math.round(S * M) / M; let A = 0; for (m && (u && w !== a ? (e.push({ value: a }), w < a && A++, We(Math.round((w + A * _) * M) / M, a, hn(a, y, n)) && A++) : w < a && A++); A < D; ++A) { const L = Math.round((w + A * _) * M) / M; if (x && L > r) break; e.push({ value: L }) } return x && u && S !== r ? e.length && We(e[e.length - 1].value, r, hn(r, y, n)) ? e[e.length - 1].value = r : e.push({ value: r }) : (!x || S === r) && e.push({ value: S }), e } function hn(n, t, { horizontal: e, minRotation: i }) { const s = st(i), o = (e ? Math.sin(s) : Math.cos(s)) || .001; return Math.min(t / o, .75 * t * ("" + n).length) } k(Oe, "id", "category"), k(Oe, "defaults", { ticks: { callback: cn } }); class Te extends mt { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(t, e) { return O(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t } handleTickRangeOptions() { const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds(); let { min: s, max: o } = this; const a = l => s = e ? s : l, r = l => o = i ? o : l; if (t) { const l = dt(s), c = dt(o); l < 0 && c < 0 ? r(0) : l > 0 && c > 0 && a(0) } if (s === o) { let l = 0 === o ? 1 : Math.abs(.05 * o); r(o + l), t || a(s - l) } this.min = s, this.max = o } getTickLimit() { const t = this.options.ticks; let s, { maxTicksLimit: e, stepSize: i } = t; return i ? (s = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, s > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${s} ticks. Limiting to 1000.`), s = 1e3)) : (s = this.computeTickLimit(), e = e || 11), e && (s = Math.min(e, s)), s } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const t = this.options, e = t.ticks; let i = this.getTickLimit(); i = Math.max(2, i); const a = jr({ maxTicks: i, bounds: t.bounds, min: t.min, max: t.max, precision: e.precision, step: e.stepSize, count: e.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: e.minRotation || 0, includeBounds: !1 !== e.includeBounds }, this._range || this); return "ticks" === t.bounds && Ti(a, this, "value"), t.reverse ? (a.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a } configure() { const t = this.ticks; let e = this.min, i = this.max; if (super.configure(), this.options.offset && t.length) { const s = (i - e) / Math.max(t.length - 1, 1) / 2; e -= s, i += s } this._startValue = e, this._endValue = i, this._valueRange = i - e } getLabelForValue(t) { return ue(t, this.chart.options.locale, this.options.ticks.format) } } class Re extends Te { determineDataLimits() { const { min: t, max: e } = this.getMinMax(!0); this.min = V(t) ? t : 0, this.max = V(e) ? e : 1, this.handleTickRangeOptions() } computeTickLimit() { const t = this.isHorizontal(), e = t ? this.width : this.height, i = st(this.options.ticks.minRotation), s = (t ? Math.sin(i) : Math.cos(i)) || .001, o = this._resolveTickFontOptions(0); return Math.ceil(e / Math.min(40, o.lineHeight / s)) } getPixelForValue(t) { return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getValueForPixel(t) { return this._startValue + this.getDecimalForPixel(t) * this._valueRange } } k(Re, "id", "linear"), k(Re, "defaults", { ticks: { callback: _e.formatters.numeric } }); const le = n => Math.floor(Ut(n)), wt = (n, t) => Math.pow(10, le(n) + t); function dn(n) { return n / Math.pow(10, le(n)) == 1 } function un(n, t, e) { const i = Math.pow(10, e), s = Math.floor(n / i); return Math.ceil(t / i) - s } function $r(n, t) { let i = le(t - n); for (; un(n, t, i) > 10;)i++; for (; un(n, t, i) < 10;)i--; return Math.min(i, le(n)) } function Ur(n, { min: t, max: e }) { t = Z(n.min, t); const i = [], s = le(t); let o = $r(t, e), a = o < 0 ? Math.pow(10, Math.abs(o)) : 1; const r = Math.pow(10, o), l = s > o ? Math.pow(10, s) : 0, c = Math.round((t - l) * a) / a, h = Math.floor((t - l) / r / 10) * r * 10; let d = Math.floor((c - h) / Math.pow(10, o)), u = Z(n.min, Math.round((l + h + d * Math.pow(10, o)) * a) / a); for (; u < e;)i.push({ value: u, major: dn(u), significand: d }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (o++, d = 2, a = o >= 0 ? 1 : a), u = Math.round((l + h + d * Math.pow(10, o)) * a) / a; const f = Z(n.max, u); return i.push({ value: f, major: dn(f), significand: d }), i } class Ee extends mt { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(t, e) { const i = Te.prototype.parse.apply(this, [t, e]); if (0 !== i) return V(i) && i > 0 ? i : null; this._zero = !0 } determineDataLimits() { const { min: t, max: e } = this.getMinMax(!0); this.min = V(t) ? Math.max(0, t) : null, this.max = V(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !V(this._userMin) && (this.min = t === wt(this.min, 0) ? wt(this.min, -1) : wt(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: t, maxDefined: e } = this.getUserBounds(); let i = this.min, s = this.max; const o = r => i = t ? i : r, a = r => s = e ? s : r; i === s && (i <= 0 ? (o(1), a(10)) : (o(wt(i, -1)), a(wt(s, 1)))), i <= 0 && o(wt(s, -1)), s <= 0 && a(wt(i, 1)), this.min = i, this.max = s } buildTicks() { const t = this.options, i = Ur({ min: this._userMin, max: this._userMax }, this); return "ticks" === t.bounds && Ti(i, this, "value"), t.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i } getLabelForValue(t) { return void 0 === t ? "0" : ue(t, this.chart.options.locale, this.options.ticks.format) } configure() { const t = this.min; super.configure(), this._startValue = Ut(t), this._valueRange = Ut(this.max) - Ut(t) } getPixelForValue(t) { return (void 0 === t || 0 === t) && (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Ut(t) - this._startValue) / this._valueRange) } getValueForPixel(t) { const e = this.getDecimalForPixel(t); return Math.pow(10, this._startValue + e * this._valueRange) } } function li(n) { const t = n.ticks; if (t.display && n.display) { const e = $(t.backdropPadding); return C(t.font && t.font.size, I.font.size) + e.height } return 0 } function Yr(n, t, e) { return e = K(e) ? e : [e], { w: io(n, t.string, e), h: e.length * t.lineHeight } } function fn(n, t, e, i, s) { return n === i || n === s ? { start: t - e / 2, end: t + e / 2 } : n < i || n > s ? { start: t - e, end: t } : { start: t, end: t + e } } function Xr(n) { const t = { l: n.left + n._padding.left, r: n.right - n._padding.right, t: n.top + n._padding.top, b: n.bottom - n._padding.bottom }, e = Object.assign({}, t), i = [], s = [], o = n._pointLabels.length, a = n.options.pointLabels, r = a.centerPointLabels ? rt / o : 0; for (let l = 0; l < o; l++) { const c = a.setContext(n.getPointLabelContext(l)); s[l] = c.padding; const h = n.getPointPosition(l, n.drawingArea + s[l], r), d = N(c.font), u = Yr(n.ctx, d, n._pointLabels[l]); i[l] = u; const f = $t(n.getIndexAngle(l) + r), g = Math.round(Ve(f)); Kr(e, t, f, fn(g, h.x, u.w, 0, 180), fn(g, h.y, u.h, 90, 270)) } n.setCenterPoint(t.l - e.l, e.r - t.r, t.t - e.t, e.b - t.b), n._pointLabelItems = Jr(n, i, s) } function Kr(n, t, e, i, s) { const o = Math.abs(Math.sin(e)), a = Math.abs(Math.cos(e)); let r = 0, l = 0; i.start < t.l ? (r = (t.l - i.start) / o, n.l = Math.min(n.l, t.l - r)) : i.end > t.r && (r = (i.end - t.r) / o, n.r = Math.max(n.r, t.r + r)), s.start < t.t ? (l = (t.t - s.start) / a, n.t = Math.min(n.t, t.t - l)) : s.end > t.b && (l = (s.end - t.b) / a, n.b = Math.max(n.b, t.b + l)) } function Gr(n, t, e) { const i = n.drawingArea, { extra: s, additionalAngle: o, padding: a, size: r } = e, l = n.getPointPosition(t, i + s + a, o), c = Math.round(Ve($t(l.angle + Q))), h = tl(l.y, r.h, c), d = Zr(c), u = Qr(l.x, r.w, d); return { visible: !0, x: l.x, y: h, textAlign: d, left: u, top: h, right: u + r.w, bottom: h + r.h } } function qr(n, t) { if (!t) return !0; const { left: e, top: i, right: s, bottom: o } = n; return !(_t({ x: e, y: i }, t) || _t({ x: e, y: o }, t) || _t({ x: s, y: i }, t) || _t({ x: s, y: o }, t)) } function Jr(n, t, e) { const i = [], s = n._pointLabels.length, o = n.options, { centerPointLabels: a, display: r } = o.pointLabels, l = { extra: li(o) / 2, additionalAngle: a ? rt / s : 0 }; let c; for (let h = 0; h < s; h++) { l.padding = e[h], l.size = t[h]; const d = Gr(n, h, l); i.push(d), "auto" === r && (d.visible = qr(d, c), d.visible && (c = d)) } return i } function Zr(n) { return 0 === n || 180 === n ? "center" : n < 180 ? "left" : "right" } function Qr(n, t, e) { return "right" === e ? n -= t : "center" === e && (n -= t / 2), n } function tl(n, t, e) { return 90 === e || 270 === e ? n -= t / 2 : (e > 270 || e < 90) && (n -= t), n } function el(n, t, e) { const { left: i, top: s, right: o, bottom: a } = e, { backdropColor: r } = t; if (!O(r)) { const l = kt(t.borderRadius), c = $(t.backdropPadding); n.fillStyle = r; const h = i - c.left, d = s - c.top, u = o - i + c.width, f = a - s + c.height; Object.values(l).some(g => 0 !== g) ? (n.beginPath(), jt(n, { x: h, y: d, w: u, h: f, radius: l }), n.fill()) : n.fillRect(h, d, u, f) } } function il(n, t) { const { ctx: e, options: { pointLabels: i } } = n; for (let s = t - 1; s >= 0; s--) { const o = n._pointLabelItems[s]; if (!o.visible) continue; const a = i.setContext(n.getPointLabelContext(s)); el(e, a, o); const r = N(a.font), { x: l, y: c, textAlign: h } = o; vt(e, n._pointLabels[s], l, c + r.lineHeight / 2, r, { color: a.color, textAlign: h, textBaseline: "middle" }) } } function gn(n, t, e, i) { const { ctx: s } = n; if (e) s.arc(n.xCenter, n.yCenter, t, 0, Y); else { let o = n.getPointPosition(0, t); s.moveTo(o.x, o.y); for (let a = 1; a < i; a++)o = n.getPointPosition(a, t), s.lineTo(o.x, o.y) } } function sl(n, t, e, i, s) { const o = n.ctx, a = t.circular, { color: r, lineWidth: l } = t; !a && !i || !r || !l || e < 0 || (o.save(), o.strokeStyle = r, o.lineWidth = l, o.setLineDash(s.dash), o.lineDashOffset = s.dashOffset, o.beginPath(), gn(n, e, a, i), o.closePath(), o.stroke(), o.restore()) } function nl(n, t, e) { return bt(n, { label: e, index: t, type: "pointLabel" }) } k(Ee, "id", "logarithmic"), k(Ee, "defaults", { ticks: { callback: _e.formatters.logarithmic, major: { enabled: !0 } } }); class Et extends Te { constructor(t) { super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const t = this._padding = $(li(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height; this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2) } determineDataLimits() { const { min: t, max: e } = this.getMinMax(!1); this.min = V(t) && !isNaN(t) ? t : 0, this.max = V(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / li(this.options)) } generateTickLabels(t) { Te.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, i) => { const s = E(this.options.pointLabels.callback, [e, i], this); return s || 0 === s ? s : "" }).filter((e, i) => this.chart.getDataVisibility(i)) } fit() { const t = this.options; t.display && t.pointLabels.display ? Xr(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(t, e, i, s) { this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s)) } getIndexAngle(t) { return $t(t * (Y / (this._pointLabels.length || 1)) + st(this.options.startAngle || 0)) } getDistanceFromCenterForValue(t) { if (O(t)) return NaN; const e = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - t) * e : (t - this.min) * e } getValueForDistanceFromCenter(t) { if (O(t)) return NaN; const e = t / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - e : this.min + e } getPointLabelContext(t) { const e = this._pointLabels || []; if (t >= 0 && t < e.length) { const i = e[t]; return nl(this.getContext(), t, i) } } getPointPosition(t, e, i = 0) { const s = this.getIndexAngle(t) - Q + i; return { x: Math.cos(s) * e + this.xCenter, y: Math.sin(s) * e + this.yCenter, angle: s } } getPointPositionForValue(t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) } getBasePosition(t) { return this.getPointPositionForValue(t || 0, this.getBaseValue()) } getPointLabelPosition(t) { const { left: e, top: i, right: s, bottom: o } = this._pointLabelItems[t]; return { left: e, top: i, right: s, bottom: o } } drawBackground() { const { backgroundColor: t, grid: { circular: e } } = this.options; if (t) { const i = this.ctx; i.save(), i.beginPath(), gn(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore() } } drawGrid() { const t = this.ctx, e = this.options, { angleLines: i, grid: s, border: o } = e, a = this._pointLabels.length; let r, l, c; if (e.pointLabels.display && il(this, a), s.display && this.ticks.forEach((h, d) => { if (0 !== d) { l = this.getDistanceFromCenterForValue(h.value); const u = this.getContext(d), f = s.setContext(u), g = o.setContext(u); sl(this, f, l, a, g) } }), i.display) { for (t.save(), r = a - 1; r >= 0; r--) { const h = i.setContext(this.getPointLabelContext(r)), { color: d, lineWidth: u } = h; !u || !d || (t.lineWidth = u, t.strokeStyle = d, t.setLineDash(h.borderDash), t.lineDashOffset = h.borderDashOffset, l = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), c = this.getPointPosition(r, l), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(c.x, c.y), t.stroke()) } t.restore() } } drawBorder() { } drawLabels() { const t = this.ctx, e = this.options, i = e.ticks; if (!i.display) return; const s = this.getIndexAngle(0); let o, a; t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((r, l) => { if (0 === l && !e.reverse) return; const c = i.setContext(this.getContext(l)), h = N(c.font); if (o = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) { t.font = h.string, a = t.measureText(r.label).width, t.fillStyle = c.backdropColor; const d = $(c.backdropPadding); t.fillRect(-a / 2 - d.left, -o - h.size / 2 - d.top, a + d.width, h.size + d.height) } vt(t, r.label, 0, -o, h, { color: c.color }) }), t.restore() } drawTitle() { } } k(Et, "id", "radialLinear"), k(Et, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: _e.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback: t => t, padding: 5, centerPointLabels: !1 } }), k(Et, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), k(Et, "descriptors", { angleLines: { _fallback: "grid" } }); const ze = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, q = Object.keys(ze); function ol(n, t) { return n - t } function pn(n, t) { if (O(t)) return null; const e = n._adapter, { parser: i, round: s, isoWeekday: o } = n._parseOpts; let a = t; return "function" == typeof i && (a = i(a)), V(a) || (a = "string" == typeof i ? e.parse(a, i) : e.parse(a)), null === a ? null : (s && (a = "week" !== s || !At(o) && !0 !== o ? e.startOf(a, s) : e.startOf(a, "isoWeek", o)), +a) } function mn(n, t, e, i) { const s = q.length; for (let o = q.indexOf(n); o < s - 1; ++o) { const a = ze[q[o]], r = a.steps ? a.steps : Number.MAX_SAFE_INTEGER; if (a.common && Math.ceil((e - t) / (r * a.size)) <= i) return q[o] } return q[s - 1] } function al(n, t, e, i, s) { for (let o = q.length - 1; o >= q.indexOf(e); o--) { const a = q[o]; if (ze[a].common && n._adapter.diff(s, i, a) >= t - 1) return a } return q[e ? q.indexOf(e) : 0] } function rl(n) { for (let t = q.indexOf(n) + 1, e = q.length; t < e; ++t)if (ze[q[t]].common) return q[t] } function bn(n, t, e) { if (e) { if (e.length) { const { lo: i, hi: s } = no(e, t); n[e[i] >= t ? e[i] : e[s]] = !0 } } else n[t] = !0 } function ll(n, t, e, i) { const s = n._adapter, o = +s.startOf(t[0].value, i), a = t[t.length - 1].value; let r, l; for (r = o; r <= a; r = +s.add(r, 1, i))l = e[r], l >= 0 && (t[l].major = !0); return t } function xn(n, t, e) { const i = [], s = {}, o = t.length; let a, r; for (a = 0; a < o; ++a)r = t[a], s[r] = a, i.push({ value: r, major: !1 }); return 0 !== o && e ? ll(n, i, s, e) : i } class zt extends mt { constructor(t) { super(t), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(t, e = {}) { const i = t.time || (t.time = {}), s = this._adapter = new Gi._date(t.adapters.date); s.init(e), be(i.displayFormats, s.formats()), this._parseOpts = { parser: i.parser, round: i.round, isoWeekday: i.isoWeekday }, super.init(t), this._normalized = e.normalized } parse(t, e) { return void 0 === t ? null : pn(this, t) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const t = this.options, e = this._adapter, i = t.time.unit || "day"; let { min: s, max: o, minDefined: a, maxDefined: r } = this.getUserBounds(); function l(c) { !a && !isNaN(c.min) && (s = Math.min(s, c.min)), !r && !isNaN(c.max) && (o = Math.max(o, c.max)) } (!a || !r) && (l(this._getLabelBounds()), ("ticks" !== t.bounds || "labels" !== t.ticks.source) && l(this.getMinMax(!1))), s = V(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), o = V(o) && !isNaN(o) ? o : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, o - 1), this.max = Math.max(s + 1, o) } _getLabelBounds() { const t = this.getLabelTimestamps(); let e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY; return t.length && (e = t[0], i = t[t.length - 1]), { min: e, max: i } } buildTicks() { const t = this.options, e = t.time, i = t.ticks, s = "labels" === i.source ? this.getLabelTimestamps() : this._generate(); "ticks" === t.bounds && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]); const o = this.min, r = so(s, o, this.max); return this._unit = e.unit || (i.autoSkip ? mn(e.minUnit, this.min, this.max, this._getLabelCapacity(o)) : al(this, r.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && "year" !== this._unit ? rl(this._unit) : void 0, this.initOffsets(s), t.reverse && r.reverse(), xn(this, r, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t => +t.value)) } initOffsets(t = []) { let s, o, e = 0, i = 0; this.options.offset && t.length && (s = this.getDecimalForValue(t[0]), e = 1 === t.length ? 1 - s : (this.getDecimalForValue(t[1]) - s) / 2, o = this.getDecimalForValue(t[t.length - 1]), i = 1 === t.length ? o : (o - this.getDecimalForValue(t[t.length - 2])) / 2); const a = t.length < 3 ? .5 : .25; e = X(e, 0, a), i = X(i, 0, a), this._offsets = { start: e, end: i, factor: 1 / (e + 1 + i) } } _generate() { const t = this._adapter, e = this.min, i = this.max, s = this.options, o = s.time, a = o.unit || mn(o.minUnit, e, i, this._getLabelCapacity(e)), r = C(s.ticks.stepSize, 1), l = "week" === a && o.isoWeekday, c = At(l) || !0 === l, h = {}; let u, f, d = e; if (c && (d = +t.startOf(d, "isoWeek", l)), d = +t.startOf(d, c ? "day" : a), t.diff(i, e, a) > 1e5 * r) throw new Error(e + " and " + i + " are too far apart with stepSize of " + r + " " + a); const g = "data" === s.ticks.source && this.getDataTimestamps(); for (u = d, f = 0; u < i; u = +t.add(u, r, a), f++)bn(h, u, g); return (u === i || "ticks" === s.bounds || 1 === f) && bn(h, u, g), Object.keys(h).sort((p, b) => p - b).map(p => +p) } getLabelForValue(t) { const i = this.options.time; return this._adapter.format(t, i.tooltipFormat ? i.tooltipFormat : i.displayFormats.datetime) } format(t, e) { return this._adapter.format(t, e || this.options.time.displayFormats[this._unit]) } _tickFormatFunction(t, e, i, s) { const o = this.options, a = o.ticks.callback; if (a) return E(a, [t, e, i], this); const r = o.time.displayFormats, l = this._unit, c = this._majorUnit, d = c && r[c], u = i[e]; return this._adapter.format(t, s || (c && d && u && u.major ? d : l && r[l])) } generateTickLabels(t) { let e, i, s; for (e = 0, i = t.length; e < i; ++e)s = t[e], s.label = this._tickFormatFunction(s.value, e, t) } getDecimalForValue(t) { return null === t ? NaN : (t - this.min) / (this.max - this.min) } getPixelForValue(t) { const e = this._offsets, i = this.getDecimalForValue(t); return this.getPixelForDecimal((e.start + i) * e.factor) } getValueForPixel(t) { const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end; return this.min + i * (this.max - this.min) } _getLabelSize(t) { const e = this.options.ticks, i = this.ctx.measureText(t).width, s = st(this.isHorizontal() ? e.maxRotation : e.minRotation), o = Math.cos(s), a = Math.sin(s), r = this._resolveTickFontOptions(0).size; return { w: i * o + r * a, h: i * a + r * o } } _getLabelCapacity(t) { const e = this.options.time, i = e.displayFormats, s = i[e.unit] || i.millisecond, o = this._tickFormatFunction(t, 0, xn(this, [t], this._majorUnit), s), a = this._getLabelSize(o), r = Math.floor(this.isHorizontal() ? this.width / a.w : this.height / a.h) - 1; return r > 0 ? r : 1 } getDataTimestamps() { let e, i, t = this._cache.data || []; if (t.length) return t; const s = this.getMatchingVisibleMetas(); if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this); for (e = 0, i = s.length; e < i; ++e)t = t.concat(s[e].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(t) } getLabelTimestamps() { const t = this._cache.labels || []; let e, i; if (t.length) return t; const s = this.getLabels(); for (e = 0, i = s.length; e < i; ++e)t.push(pn(this, s[e])); return this._cache.labels = this._normalized ? t : this.normalize(t) } normalize(t) { return gi(t.sort(ol)) } } function Fe(n, t, e) { let o, a, r, l, i = 0, s = n.length - 1; e ? (t >= n[i].pos && t <= n[s].pos && ({ lo: i, hi: s } = Wt(n, "pos", t)), ({ pos: o, time: r } = n[i]), ({ pos: a, time: l } = n[s])) : (t >= n[i].time && t <= n[s].time && ({ lo: i, hi: s } = Wt(n, "time", t)), ({ time: o, pos: r } = n[i]), ({ time: a, pos: l } = n[s])); const c = a - o; return c ? r + (l - r) * (t - o) / c : r } k(zt, "id", "time"), k(zt, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); class Ie extends zt { constructor(t) { super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t); this._minPos = Fe(e, this.min), this._tableRange = Fe(e, this.max) - this._minPos, super.initOffsets(t) } buildLookupTable(t) { const { min: e, max: i } = this, s = [], o = []; let a, r, l, c, h; for (a = 0, r = t.length; a < r; ++a)c = t[a], c >= e && c <= i && s.push(c); if (s.length < 2) return [{ time: e, pos: 0 }, { time: i, pos: 1 }]; for (a = 0, r = s.length; a < r; ++a)h = s[a + 1], l = s[a - 1], c = s[a], Math.round((h + l) / 2) !== c && o.push({ time: c, pos: a / (r - 1) }); return o } _getTimestampsForTable() { let t = this._cache.all || []; if (t.length) return t; const e = this.getDataTimestamps(), i = this.getLabelTimestamps(); return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t } getDecimalForValue(t) { return (Fe(this._table, t) - this._minPos) / this._tableRange } getValueForPixel(t) { const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end; return Fe(this._table, i * this._tableRange + this._minPos, !0) } } k(Ie, "id", "timeseries"), k(Ie, "defaults", zt.defaults); var _n = Object.freeze({ __proto__: null, CategoryScale: Oe, LinearScale: Re, LogarithmicScale: Ee, RadialLinearScale: Et, TimeScale: zt, TimeSeriesScale: Ie }); const cl = [Ki, Os, ln, _n]; export { Fi as Animation, je as Animations, Rt as ArcElement, Xt as BarController, ae as BarElement, Ge as BasePlatform, ss as BasicPlatform, Kt as BubbleController, Oe as CategoryScale, gt as Chart, Fs as Colors, tt as DatasetController, Vs as Decimation, ls as DomPlatform, ft as DoughnutController, et as Element, Xs as Filler, Ji as Interaction, Js as Legend, Gt as LineController, ct as LineElement, Re as LinearScale, Ee as LogarithmicScale, ye as PieController, oe as PointElement, Ot as PolarAreaController, qt as RadarController, Et as RadialLinearScale, mt as Scale, Jt as ScatterController, Qs as SubTitle, _e as Ticks, zt as TimeScale, Ie as TimeSeriesScale, Zs as Title, rn as Tooltip, Gi as _adapters, cs as _detectPlatform, ot as animator, Ki as controllers, I as defaults, Os as elements, W as layouts, ln as plugins, cl as registerables, nt as registry, _n as scales };
  </script>
  <script>
    var g7 = Object.defineProperty, m7 = Object.defineProperties, _7 = Object.getOwnPropertyDescriptors, sk = Object.getOwnPropertySymbols, y7 = Object.prototype.hasOwnProperty, w7 = Object.prototype.propertyIsEnumerable, Kp = (nt, Ie, Ye) => Ie in nt ? g7(nt, Ie, { enumerable: !0, configurable: !0, writable: !0, value: Ye }) : nt[Ie] = Ye, lc = (nt, Ie) => { for (var Ye in Ie || (Ie = {})) y7.call(Ie, Ye) && Kp(nt, Ye, Ie[Ye]); if (sk) for (var Ye of sk(Ie)) w7.call(Ie, Ye) && Kp(nt, Ye, Ie[Ye]); return nt }, uc = (nt, Ie) => m7(nt, _7(Ie)), I = (nt, Ie, Ye) => (Kp(nt, "symbol" != typeof Ie ? Ie + "" : Ie, Ye), Ye); (self.webpackChunktestChart2 = self.webpackChunktestChart2 || []).push([[179], { 997: (nt, Ie, Ye) => { "use strict"; function ge(t) { return "function" == typeof t } function rt(t) { const n = t(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const zi = rt(t => function (n) { t(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, i) => `${i + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function gl(t, e) { if (t) { const n = t.indexOf(e); 0 <= n && t.splice(n, 1) } } class _e { constructor(e) { this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let e; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const s of n) s.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (ge(r)) try { r() } catch (s) { e = s instanceof zi ? s.errors : [s] } const { _finalizers: i } = this; if (i) { this._finalizers = null; for (const s of i) try { _l(s) } catch (o) { e = null != e ? e : [], o instanceof zi ? e = [...e, ...o.errors] : e.push(o) } } if (e) throw new zi(e) } } add(e) { var n; if (e && e !== this) if (this.closed) _l(e); else { if (e instanceof _e) { if (e.closed || e._hasParent(this)) return; e._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(e) } } _hasParent(e) { const { _parentage: n } = this; return n === e || Array.isArray(n) && n.includes(e) } _addParent(e) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e } _removeParent(e) { const { _parentage: n } = this; n === e ? this._parentage = null : Array.isArray(n) && gl(n, e) } remove(e) { const { _finalizers: n } = this; n && gl(n, e), e instanceof _e && e._removeParent(this) } } _e.EMPTY = (() => { const t = new _e; return t.closed = !0, t })(); const po = _e.EMPTY; function ml(t) { return t instanceof _e || t && "closed" in t && ge(t.remove) && ge(t.add) && ge(t.unsubscribe) } function _l(t) { ge(t) ? t() : t.unsubscribe() } const At = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, Kt = { setTimeout(t, e, ...n) { const { delegate: r } = Kt; return (null == r ? void 0 : r.setTimeout) ? r.setTimeout(t, e, ...n) : setTimeout(t, e, ...n) }, clearTimeout(t) { const { delegate: e } = Kt; return ((null == e ? void 0 : e.clearTimeout) || clearTimeout)(t) }, delegate: void 0 }; function Wi(t) { Kt.setTimeout(() => { const { onUnhandledError: e } = At; if (!e) throw t; e(t) }) } function qi() { } const Sr = Pt("C", void 0, void 0); function Pt(t, e, n) { return { kind: t, value: e, error: n } } let jn = null; function Gi(t) { if (At.useDeprecatedSynchronousErrorHandling) { const e = !jn; if (e && (jn = { errorThrown: !1, error: null }), t(), e) { const { errorThrown: n, error: r } = jn; if (jn = null, n) throw r } } else t() } class oi extends _e { constructor(e) { super(), this.isStopped = !1, e ? (this.destination = e, ml(e) && e.add(this)) : this.destination = Ar } static create(e, n, r) { return new Hn(e, n, r) } next(e) { this.isStopped ? Ir(function yl(t) { return Pt("N", t, void 0) }(e), this) : this._next(e) } error(e) { this.isStopped ? Ir(function pn(t) { return Pt("E", void 0, t) }(e), this) : (this.isStopped = !0, this._error(e)) } complete() { this.isStopped ? Ir(Sr, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(e) { this.destination.next(e) } _error(e) { try { this.destination.error(e) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const go = Function.prototype.bind; function Yi(t, e) { return go.call(t, e) } class Xi { constructor(e) { this.partialObserver = e } next(e) { const { partialObserver: n } = this; if (n.next) try { n.next(e) } catch (r) { ai(r) } } error(e) { const { partialObserver: n } = this; if (n.error) try { n.error(e) } catch (r) { ai(r) } else ai(e) } complete() { const { partialObserver: e } = this; if (e.complete) try { e.complete() } catch (n) { ai(n) } } } class Hn extends oi { constructor(e, n, r) { let i; if (super(), ge(e) || !e) i = { next: null != e ? e : void 0, error: null != n ? n : void 0, complete: null != r ? r : void 0 }; else { let s; this && At.useDeprecatedNextContext ? (s = Object.create(e), s.unsubscribe = () => this.unsubscribe(), i = { next: e.next && Yi(e.next, s), error: e.error && Yi(e.error, s), complete: e.complete && Yi(e.complete, s) }) : i = e } this.destination = new Xi(i) } } function ai(t) { At.useDeprecatedSynchronousErrorHandling ? function Tt(t) { At.useDeprecatedSynchronousErrorHandling && jn && (jn.errorThrown = !0, jn.error = t) }(t) : Wi(t) } function Ir(t, e) { const { onStoppedNotification: n } = At; n && Kt.setTimeout(() => n(t, e)) } const Ar = { closed: !0, next: qi, error: function ar(t) { throw t }, complete: qi }, Pr = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Un(t) { return t } let Ve = (() => { class t { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new t; return r.source = this, r.operator = n, r } subscribe(n, r, i) { const s = function vl(t) { return t && t instanceof oi || function cc(t) { return t && ge(t.next) && ge(t.error) && ge(t.complete) }(t) && ml(t) }(n) ? n : new Hn(n, r, i); return Gi(() => { const { operator: o, source: a } = this; s.add(o ? o.call(s, a) : a ? this._subscribe(s) : this._trySubscribe(s)) }), s } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = _o(r))((i, s) => { const o = new Hn({ next: a => { try { n(a) } catch (l) { s(l), o.unsubscribe() } }, error: s, complete: i }); this.subscribe(o) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [Pr]() { return this } pipe(...n) { return function wl(t) { return 0 === t.length ? Un : 1 === t.length ? t[0] : function (n) { return t.reduce((r, i) => i(r), n) } }(n)(this) } toPromise(n) { return new (n = _o(n))((r, i) => { let s; this.subscribe(o => s = o, o => i(o), () => r(s)) }) } } return t.create = e => new t(e), t })(); function _o(t) { var e; return null !== (e = null != t ? t : At.Promise) && void 0 !== e ? e : Promise } const dc = rt(t => function () { t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let gn = (() => { class t extends Ve { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Or(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new dc } next(n) { Gi(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { Gi(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { Gi(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: i, observers: s } = this; return r || i ? po : (this.currentObservers = null, s.push(n), new _e(() => { this.currentObservers = null, gl(s, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: i, isStopped: s } = this; r ? n.error(i) : s && n.complete() } asObservable() { const n = new Ve; return n.source = this, n } } return t.create = (e, n) => new Or(e, n), t })(); class Or extends gn { constructor(e, n) { super(), this.destination = e, this.source = n } next(e) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, e) } error(e) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, e) } complete() { var e, n; null === (n = null === (e = this.destination) || void 0 === e ? void 0 : e.complete) || void 0 === n || n.call(e) } _subscribe(e) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(e)) && void 0 !== r ? r : po } } function bl(t) { return ge(null == t ? void 0 : t.lift) } function Be(t) { return e => { if (bl(e)) return e.lift(function (n) { try { return t(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Xe(t, e, n, r, i) { return new fc(t, e, n, r, i) } class fc extends oi { constructor(e, n, r, i, s, o) { super(e), this.onFinalize = s, this.shouldUnsubscribe = o, this._next = n ? function (a) { try { n(a) } catch (l) { e.error(l) } } : super._next, this._error = i ? function (a) { try { i(a) } catch (l) { e.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { e.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var e; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (e = this.onFinalize) || void 0 === e || e.call(this)) } } } function X(t, e) { return Be((n, r) => { let i = 0; n.subscribe(Xe(r, s => { r.next(t.call(e, s, i++)) })) }) } function yn(t) { return this instanceof yn ? (this.v = t, this) : new yn(t) } function vo(t, e, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var i, r = n.apply(t, e || []), s = []; return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function () { return this }, i; function o(f) { r[f] && (i[f] = function (h) { return new Promise(function (p, m) { s.push([f, h, p, m]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function l(f) { f.value instanceof yn ? Promise.resolve(f.value.v).then(u, c) : d(s[0][2], f) }(r[f](h)) } catch (p) { d(s[0][3], p) } } function u(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), s.shift(), s.length && a(s[0][0], s[0][1]) } } function ci(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, e = t[Symbol.asyncIterator]; return e ? e.call(t) : (t = function wo(t) { var e = "function" == typeof Symbol && Symbol.iterator, n = e && t[e], r = 0; if (n) return n.call(t); if (t && "number" == typeof t.length) return { next: function () { return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") }(t), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(s) { n[s] = t[s] && function (o) { return new Promise(function (a, l) { !function i(s, o, a, l) { Promise.resolve(l).then(function (u) { s({ value: u, done: a }) }, o) }(a, l, (o = t[s](o)).done, o.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const ns = t => t && "number" == typeof t.length && "function" != typeof t; function El(t) { return ge(null == t ? void 0 : t.then) } function Ml(t) { return ge(t[Pr]) } function Sl(t) { return Symbol.asyncIterator && ge(null == t ? void 0 : t[Symbol.asyncIterator]) } function To(t) { return new TypeError(`You provided ${null !== t && "object" == typeof t ? "an invalid object" : `'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Il = function Dc() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Al(t) { return ge(null == t ? void 0 : t[Il]) } function di(t) { return vo(this, arguments, function* () { const n = t.getReader(); try { for (; ;) { const { value: r, done: i } = yield yn(n.read()); if (i) return yield yn(void 0); yield yield yn(r) } } finally { n.releaseLock() } }) } function Pl(t) { return ge(null == t ? void 0 : t.getReader) } function Jt(t) { if (t instanceof Ve) return t; if (null != t) { if (Ml(t)) return function Ol(t) { return new Ve(e => { const n = t[Pr](); if (ge(n.subscribe)) return n.subscribe(e); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(t); if (ns(t)) return function ko(t) { return new Ve(e => { for (let n = 0; n < t.length && !e.closed; n++)e.next(t[n]); e.complete() }) }(t); if (El(t)) return function Cc(t) { return new Ve(e => { t.then(n => { e.closed || (e.next(n), e.complete()) }, n => e.error(n)).then(null, Wi) }) }(t); if (Sl(t)) return Fl(t); if (Al(t)) return function Rl(t) { return new Ve(e => { for (const n of t) if (e.next(n), e.closed) return; e.complete() }) }(t); if (Pl(t)) return function Nl(t) { return Fl(di(t)) }(t) } throw To(t) } function Fl(t) { return new Ve(e => { (function Ll(t, e) { var n, r, i, s; return function yo(t, e, n, r) { return new (n || (n = Promise))(function (s, o) { function a(c) { try { u(r.next(c)) } catch (d) { o(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { o(d) } } function u(c) { c.done ? s(c.value) : function i(s) { return s instanceof n ? s : new n(function (o) { o(s) }) }(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = ci(t); !(r = yield n.next()).done;)if (e.next(r.value), e.closed) return } catch (o) { i = { error: o } } finally { try { r && !r.done && (s = n.return) && (yield s.call(n)) } finally { if (i) throw i.error } } e.complete() }) })(t, e).catch(n => e.error(n)) }) } function en(t, e, n, r = 0, i = !1) { const s = e.schedule(function () { n(), i ? t.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (t.add(s), !i) return s } function Pe(t, e, n = 1 / 0) { return ge(e) ? Pe((r, i) => X((s, o) => e(r, s, i, o))(Jt(t(r, i))), n) : ("number" == typeof e && (n = e), Be((r, i) => function Zl(t, e, n, r, i, s, o, a) { const l = []; let u = 0, c = 0, d = !1; const f = () => { d && !l.length && !u && e.complete() }, h = m => u < r ? p(m) : l.push(m), p = m => { s && e.next(m), u++; let y = !1; Jt(n(m, c++)).subscribe(Xe(e, v => { null == i || i(v), s ? h(v) : e.next(v) }, () => { y = !0 }, void 0, () => { if (y) try { for (u--; l.length && u < r;) { const v = l.shift(); o ? en(e, o, () => p(v)) : p(v) } f() } catch (v) { e.error(v) } })) }; return t.subscribe(Xe(e, h, () => { d = !0, f() })), () => { null == a || a() } }(r, i, t, n))) } function Vt(t = 1 / 0) { return Pe(Un, t) } const kt = new Ve(t => t.complete()); function Co(t) { return t[t.length - 1] } function $n(t) { return function Do(t) { return t && ge(t.schedule) }(Co(t)) ? t.pop() : void 0 } function lr(t, e = 0) { return Be((n, r) => { n.subscribe(Xe(r, i => en(r, t, () => r.next(i), e), () => en(r, t, () => r.complete(), e), i => en(r, t, () => r.error(i), e))) }) } function wn(t, e = 0) { return Be((n, r) => { r.add(t.schedule(() => n.subscribe(r), e)) }) } function xo(t, e) { if (!t) throw new Error("Iterable cannot be null"); return new Ve(n => { en(n, e, () => { const r = t[Symbol.asyncIterator](); en(n, e, () => { r.next().then(i => { i.done ? n.complete() : n.next(i.value) }) }, 0, !0) }) }) } function ye(t, e) { return e ? function ss(t, e) { if (null != t) { if (Ml(t)) return function vn(t, e) { return Jt(t).pipe(wn(e), lr(e)) }(t, e); if (ns(t)) return function tn(t, e) { return new Ve(n => { let r = 0; return e.schedule(function () { r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule()) }) }) }(t, e); if (El(t)) return function fi(t, e) { return Jt(t).pipe(wn(e), lr(e)) }(t, e); if (Sl(t)) return xo(t, e); if (Al(t)) return function bn(t, e) { return new Ve(n => { let r; return en(n, e, () => { r = t[Il](), en(n, e, () => { let i, s; try { ({ value: i, done: s } = r.next()) } catch (o) { return void n.error(o) } s ? n.complete() : n.next(i) }, 0, !0) }), () => ge(null == r ? void 0 : r.return) && r.return() }) }(t, e); if (Pl(t)) return function Vl(t, e) { return xo(di(t), e) }(t, e) } throw To(t) }(t, e) : Jt(t) } function hi(t, e, ...n) { if (!0 === e) return void t(); if (!1 === e) return; const r = new Hn({ next: () => { r.unsubscribe(), t() } }); return e(...n).subscribe(r) } function pe(t) { for (let e in t) if (t[e] === pe) return e; throw Error("Could not find renamed property on target object.") } function ae(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(ae).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function Tn(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const Ec = pe({ __forward_ref__: pe }); function as(t) { return t.__forward_ref__ = as, t.toString = function () { return ae(this()) }, t } function j(t) { return function Mo(t) { return "function" == typeof t && t.hasOwnProperty(Ec) && t.__forward_ref__ === as }(t) ? t() : t } class le extends Error { constructor(e, n) { super(function g(t, e) { return `NG0${Math.abs(t)}${e ? ": " + e : ""}` }(e, n)), this.code = e } } function b(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : function _(t) { return "string" == typeof t ? t : null == t ? "" : String(t) }(t) } function G(t, e) { const n = e ? ` in ${e}` : ""; throw new le(-201, `No provider for ${b(t)} found${n}`) } function Bt(t, e) { null == t && function me(t, e, n, r) { throw new Error(`ASSERTION ERROR: ${t}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${e} <=Actual]`)) }(e, t, null, "!=") } function oe(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function Fr(t) { return { providers: t.providers || [], imports: t.imports || [] } } function Mc(t) { return eg(t, Bl) || eg(t, ng) } function eg(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function tg(t) { return t && (t.hasOwnProperty(Sc) || t.hasOwnProperty(ck)) ? t[Sc] : null } const Bl = pe({ \u0275prov: pe }), Sc = pe({ \u0275inj: pe }), ng = pe({ ngInjectableDef: pe }), ck = pe({ ngInjectorDef: pe }); var H = (() => ((H = H || {})[H.Default = 0] = "Default", H[H.Host = 1] = "Host", H[H.Self = 2] = "Self", H[H.SkipSelf = 4] = "SkipSelf", H[H.Optional = 8] = "Optional", H))(); let Ic; function Nr(t) { const e = Ic; return Ic = t, e } function rg(t, e, n) { const r = Mc(t); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & H.Optional ? null : void 0 !== e ? e : void G(ae(t), "Injector") } function Lr(t) { return { toString: t }.toString() } var Dn = (() => ((Dn = Dn || {})[Dn.OnPush = 0] = "OnPush", Dn[Dn.Default = 1] = "Default", Dn))(), zn = (() => { return (t = zn || (zn = {}))[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", zn; var t })(); const fk = "undefined" != typeof globalThis && globalThis, hk = "undefined" != typeof window && window, pk = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, we = fk || "undefined" != typeof global && global || hk || pk, ls = {}, be = [], jl = pe({ \u0275cmp: pe }), Ac = pe({ \u0275dir: pe }), Pc = pe({ \u0275pipe: pe }), ig = pe({ \u0275mod: pe }), cr = pe({ \u0275fac: pe }), So = pe({ __NG_ELEMENT_ID__: pe }); let gk = 0; function Io(t) { return Lr(() => { const n = {}, r = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: n, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === Dn.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || be, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || zn.Emulated, id: "c", styles: t.styles || be, _: null, setInput: null, schemas: t.schemas || null, tView: null }, i = t.directives, s = t.features, o = t.pipes; return r.id += gk++, r.inputs = lg(t.inputs, n), r.outputs = lg(t.outputs), s && s.forEach(a => a(r)), r.directiveDefs = i ? () => ("function" == typeof i ? i() : i).map(sg) : null, r.pipeDefs = o ? () => ("function" == typeof o ? o() : o).map(og) : null, r }) } function sg(t) { return ut(t) || function Zr(t) { return t[Ac] || null }(t) } function og(t) { return function mi(t) { return t[Pc] || null }(t) } const ag = {}; function gi(t) { return Lr(() => { const e = { type: t.type, bootstrap: t.bootstrap || be, declarations: t.declarations || be, imports: t.imports || be, exports: t.exports || be, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && (ag[t.id] = t.type), e }) } function lg(t, e) { if (null == t) return ls; const n = {}; for (const r in t) if (t.hasOwnProperty(r)) { let i = t[r], s = i; Array.isArray(i) && (s = i[1], i = i[0]), n[i] = r, e && (e[i] = s) } return n } const pt = Io; function ut(t) { return t[jl] || null } function nn(t, e) { const n = t[ig] || null; if (!n && !0 === e) throw new Error(`Type ${ae(t)} does not have '\u0275mod' property.`); return n } const Y = 11; function Wn(t) { return Array.isArray(t) && "object" == typeof t[1] } function xn(t) { return Array.isArray(t) && !0 === t[1] } function Fc(t) { return 0 != (8 & t.flags) } function zl(t) { return 2 == (2 & t.flags) } function Wl(t) { return 1 == (1 & t.flags) } function En(t) { return null !== t.template } function bk(t) { return 0 != (512 & t[2]) } function vi(t, e) { return t.hasOwnProperty(cr) ? t[cr] : null } class Dk { constructor(e, n, r) { this.previousValue = e, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function cg(t) { return t.type.prototype.ngOnChanges && (t.setInput = xk), Ck } function Ck() { const t = fg(this), e = null == t ? void 0 : t.current; if (e) { const n = t.previous; if (n === ls) t.previous = e; else for (let r in e) n[r] = e[r]; t.current = null, this.ngOnChanges(e) } } function xk(t, e, n, r) { const i = fg(t) || function Ek(t, e) { return t[dg] = e }(t, { previous: ls, current: null }), s = i.current || (i.current = {}), o = i.previous, a = this.declaredInputs[n], l = o[a]; s[a] = new Dk(l && l.currentValue, e, o === ls), t[r] = e } const dg = "__ngSimpleChanges__"; function fg(t) { return t[dg] || null } let Bc; function Re(t) { return !!t.listen } const hg = { createRenderer: (t, e) => function jc() { return void 0 !== Bc ? Bc : "undefined" != typeof document ? document : void 0 }() }; function ze(t) { for (; Array.isArray(t);)t = t[0]; return t } function Ht(t, e) { return ze(e[t.index]) } function Hc(t, e) { return t.data[e] } function Ut(t, e) { const n = e[t]; return Wn(n) ? n : n[0] } function pg(t) { return 4 == (4 & t[2]) } function Uc(t) { return 128 == (128 & t[2]) } function Vr(t, e) { return null == e ? null : t[e] } function gg(t) { t[18] = 0 } function $c(t, e) { t[5] += e; let n = t, r = t[3]; for (; null !== r && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)r[5] += e, n = r, r = r[3] } const U = { lFrame: Dg(null), bindingsEnabled: !0 }; function _g() { return U.bindingsEnabled } function x() { return U.lFrame.lView } function ue() { return U.lFrame.tView } function Qe() { let t = yg(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function yg() { return U.lFrame.currentTNode } function qn(t, e) { const n = U.lFrame; n.currentTNode = t, n.isParent = e } function zc() { return U.lFrame.isParent } function zk(t, e) { const n = U.lFrame; n.bindingIndex = n.bindingRootIndex = t, qc(e) } function qc(t) { U.lFrame.currentDirectiveIndex = t } function bg() { return U.lFrame.currentQueryIndex } function Yc(t) { U.lFrame.currentQueryIndex = t } function qk(t) { const e = t[1]; return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null } function Tg(t, e, n) { if (n & H.SkipSelf) { let i = e, s = t; for (; !(i = i.parent, null !== i || n & H.Host || (i = qk(s), null === i || (s = s[15], 10 & i.type)));); if (null === i) return !1; e = i, t = s } const r = U.lFrame = kg(); return r.currentTNode = e, r.lView = t, !0 } function Yl(t) { const e = kg(), n = t[1]; U.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1 } function kg() { const t = U.lFrame, e = null === t ? null : t.child; return null === e ? Dg(t) : e } function Dg(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = e), e } function Cg() { const t = U.lFrame; return U.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const xg = Cg; function Xl() { const t = Cg(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function xt() { return U.lFrame.selectedIndex } function Br(t) { U.lFrame.selectedIndex = t } function Ql(t, e) { for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) { const s = t.data[n].type.prototype, { ngAfterContentInit: o, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: u, ngOnDestroy: c } = s; o && (t.contentHooks || (t.contentHooks = [])).push(-n, o), a && ((t.contentHooks || (t.contentHooks = [])).push(n, a), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, a)), l && (t.viewHooks || (t.viewHooks = [])).push(-n, l), u && ((t.viewHooks || (t.viewHooks = [])).push(n, u), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, u)), null != c && (t.destroyHooks || (t.destroyHooks = [])).push(n, c) } } function Kl(t, e, n) { Eg(t, e, 3, n) } function Jl(t, e, n, r) { (3 & t[2]) === n && Eg(t, e, n, r) } function Xc(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function Eg(t, e, n, r) { const s = null != r ? r : -1, o = e.length - 1; let a = 0; for (let l = void 0 !== r ? 65535 & t[18] : 0; l < o; l++)if ("number" == typeof e[l + 1]) { if (a = e[l], null != r && a >= r) break } else e[l] < 0 && (t[18] += 65536), (a < s || -1 == s) && (nD(t, n, e, l), t[18] = (4294901760 & t[18]) + l + 2), l++ } function nD(t, e, n, r) { const i = n[r] < 0, s = n[r + 1], a = t[i ? -n[r] : n[r]]; if (i) { if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) { t[2] += 2048; try { s.call(a) } finally { } } } else try { s.call(a) } finally { } } class Fo { constructor(e, n, r) { this.factory = e, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function eu(t, e, n) { const r = Re(t); let i = 0; for (; i < n.length;) { const s = n[i]; if ("number" == typeof s) { if (0 !== s) break; i++; const o = n[i++], a = n[i++], l = n[i++]; r ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l) } else { const o = s, a = n[++i]; Kc(o) ? r && t.setProperty(e, o, a) : r ? t.setAttribute(e, o, a) : e.setAttribute(o, a), i++ } } return i } function Mg(t) { return 3 === t || 4 === t || 6 === t } function Kc(t) { return 64 === t.charCodeAt(0) } function tu(t, e) { if (null !== e && 0 !== e.length) if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let r = 0; r < e.length; r++) { const i = e[r]; "number" == typeof i ? n = i : 0 === n || Sg(t, n, i, null, -1 === n || 2 === n ? e[++r] : null) } } return t } function Sg(t, e, n, r, i) { let s = 0, o = t.length; if (-1 === e) o = -1; else for (; s < t.length;) { const a = t[s++]; if ("number" == typeof a) { if (a === e) { o = -1; break } if (a > e) { o = s - 1; break } } } for (; s < t.length;) { const a = t[s]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== i && (t[s + 1] = i)); if (r === t[s + 1]) return void (t[s + 2] = i) } s++, null !== r && s++, null !== i && s++ } -1 !== o && (t.splice(o, 0, e), s = o + 1), t.splice(s++, 0, n), null !== r && t.splice(s++, 0, r), null !== i && t.splice(s++, 0, i) } function Ig(t) { return -1 !== t } function gs(t) { return 32767 & t } function ms(t, e) { let n = function aD(t) { return t >> 16 }(t), r = e; for (; n > 0;)r = r[15], n--; return r } let Jc = !0; function nu(t) { const e = Jc; return Jc = t, e } let lD = 0; function Lo(t, e) { const n = td(t, e); if (-1 !== n) return n; const r = e[1]; r.firstCreatePass && (t.injectorIndex = e.length, ed(r.data, t), ed(e, null), ed(r.blueprint, null)); const i = ru(t, e), s = t.injectorIndex; if (Ig(i)) { const o = gs(i), a = ms(i, e), l = a[1].data; for (let u = 0; u < 8; u++)e[s + u] = a[o + u] | l[o + u] } return e[s + 8] = i, s } function ed(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function td(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function ru(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = 0, r = null, i = e; for (; null !== i;) { const s = i[1], o = s.type; if (r = 2 === o ? s.declTNode : 1 === o ? i[6] : null, null === r) return -1; if (n++, i = i[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return -1 } function iu(t, e, n) { !function uD(t, e, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(So) && (r = n[So]), null == r && (r = n[So] = lD++); const i = 255 & r; e.data[t + (i >> 5)] |= 1 << i }(t, e, n) } function Og(t, e, n) { if (n & H.Optional) return t; G(e, "NodeInjector") } function Rg(t, e, n, r) { if (n & H.Optional && void 0 === r && (r = null), 0 == (n & (H.Self | H.Host))) { const i = t[9], s = Nr(void 0); try { return i ? i.get(e, r, n & H.Optional) : rg(e, r, n & H.Optional) } finally { Nr(s) } } return Og(r, e, n) } function Fg(t, e, n, r = H.Default, i) { if (null !== t) { const s = function hD(t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(So) ? t[So] : void 0; return "number" == typeof e ? e >= 0 ? 255 & e : dD : e }(n); if ("function" == typeof s) { if (!Tg(e, t, r)) return r & H.Host ? Og(i, n, r) : Rg(e, n, r, i); try { const o = s(r); if (null != o || r & H.Optional) return o; G(n) } finally { xg() } } else if ("number" == typeof s) { let o = null, a = td(t, e), l = -1, u = r & H.Host ? e[16][6] : null; for ((-1 === a || r & H.SkipSelf) && (l = -1 === a ? ru(t, e) : e[a + 8], -1 !== l && Zg(r, !1) ? (o = e[1], a = gs(l), e = ms(l, e)) : a = -1); -1 !== a;) { const c = e[1]; if (Lg(s, a, c.data)) { const d = fD(a, e, n, o, r, u); if (d !== Ng) return d } l = e[a + 8], -1 !== l && Zg(r, e[1].data[a + 8] === u) && Lg(s, a, e) ? (o = c, a = gs(l), e = ms(l, e)) : a = -1 } } } return Rg(e, n, r, i) } const Ng = {}; function dD() { return new _s(Qe(), x()) } function fD(t, e, n, r, i, s) { const o = e[1], a = o.data[t + 8], c = su(a, o, n, null == r ? zl(a) && Jc : r != o && 0 != (3 & a.type), i & H.Host && s === a); return null !== c ? Zo(e, o, c, a) : Ng } function su(t, e, n, r, i) { const s = t.providerIndexes, o = e.data, a = 1048575 & s, l = t.directiveStart, c = s >> 20, f = i ? a + c : t.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = o[h]; if (h < l && n === p || h >= l && p.type === n) return h } if (i) { const h = o[l]; if (h && En(h) && h.type === n) return l } return null } function Zo(t, e, n, r) { let i = t[n]; const s = e.data; if (function rD(t) { return t instanceof Fo }(i)) { const o = i; o.resolving && function k(t, e) { const n = e ? `. Dependency path: ${e.join(" > ")} > ${t}` : ""; throw new le(-200, `Circular dependency in DI detected for ${t}${n}`) }(b(s[n])); const a = nu(o.canSeeViewProviders); o.resolving = !0; const l = o.injectImpl ? Nr(o.injectImpl) : null; Tg(t, r, H.Default); try { i = t[n] = o.factory(void 0, s, t, r), e.firstCreatePass && n >= r.directiveStart && function tD(t, e, n) { const { ngOnChanges: r, ngOnInit: i, ngDoCheck: s } = e.type.prototype; if (r) { const o = cg(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, o), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, o) } i && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, i), s && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, s)) }(n, s[n], e) } finally { null !== l && Nr(l), nu(a), o.resolving = !1, xg() } } return i } function Lg(t, e, n) { return !!(n[e + (t >> 5)] & 1 << t) } function Zg(t, e) { return !(t & H.Self || t & H.Host && e) } class _s { constructor(e, n) { this._tNode = e, this._lView = n } get(e, n, r) { return Fg(this._tNode, this._lView, e, r, n) } } const ws = "__parameters__"; function bs(t, e, n) { return Lr(() => { const r = function rd(t) { return function (...n) { if (t) { const r = t(...n); for (const i in r) this[i] = r[i] } } }(e); function i(...s) { if (this instanceof i) return r.apply(this, s), this; const o = new i(...s); return a.annotation = o, a; function a(l, u, c) { const d = l.hasOwnProperty(ws) ? l[ws] : Object.defineProperty(l, ws, { value: [] })[ws]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(o), l } } return n && (i.prototype = Object.create(n.prototype)), i.prototype.ngMetadataName = t, i.annotationCls = i, i }) } class ce { constructor(e, n) { this._desc = e, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = oe({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } toString() { return `InjectionToken ${this._desc}` } } const mD = new ce("AnalyzeForEntryComponents"); function on(t, e) { void 0 === e && (e = t); for (let n = 0; n < t.length; n++) { let r = t[n]; Array.isArray(r) ? (e === t && (e = t.slice(0, n)), on(r, e)) : e !== t && e.push(r) } return e } function Gn(t, e) { t.forEach(n => Array.isArray(n) ? Gn(n, e) : e(n)) } function Bg(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function ou(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } const Uo = {}, ad = "__NG_DI_FLAG__", lu = "ngTempTokenPath", xD = /\n/gm, zg = "__source", MD = pe({ provide: String, useValue: pe }); let $o; function Wg(t) { const e = $o; return $o = t, e } function SD(t, e = H.Default) { if (void 0 === $o) throw new le(203, ""); return null === $o ? rg(t, void 0, e) : $o.get(t, e & H.Optional ? null : void 0, e) } function V(t, e = H.Default) { return (function dk() { return Ic }() || SD)(j(t), e) } const ID = V; function ld(t) { const e = []; for (let n = 0; n < t.length; n++) { const r = j(t[n]); if (Array.isArray(r)) { if (0 === r.length) throw new le(900, ""); let i, s = H.Default; for (let o = 0; o < r.length; o++) { const a = r[o], l = AD(a); "number" == typeof l ? -1 === l ? i = a.token : s |= l : i = a } e.push(V(i, s)) } else e.push(V(r)) } return e } function zo(t, e) { return t[ad] = e, t.prototype[ad] = e, t } function AD(t) { return t[ad] } const uu = zo(bs("Inject", t => ({ token: t })), -1), Hr = zo(bs("Optional"), 8), Wo = zo(bs("SkipSelf"), 4); var zt = (() => ((zt = zt || {})[zt.Important = 1] = "Important", zt[zt.DashCase = 2] = "DashCase", zt))(); const em = "__ngContext__"; function mt(t, e) { t[em] = e } function dd(t) { const e = function Go(t) { return t[em] || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function hd(t, e) { return undefined(t, e) } function Yo(t) { const e = t[3]; return xn(e) ? e[3] : e } function pd(t) { return am(t[13]) } function gd(t) { return am(t[4]) } function am(t) { for (; null !== t && !xn(t);)t = t[4]; return t } function Ds(t, e, n, r, i) { if (null != r) { let s, o = !1; xn(r) ? s = r : Wn(r) && (o = !0, r = r[0]); const a = ze(r); 0 === t && null !== n ? null == i ? hm(e, n, a) : Ti(e, n, a, i || null, !0) : 1 === t && null !== n ? Ti(e, n, a, i || null, !0) : 2 === t ? function Td(t, e, n) { const r = du(t, e); r && function lC(t, e, n, r) { Re(t) ? t.removeChild(e, n, r) : e.removeChild(n) }(t, r, e, n) }(e, a, o) : 3 === t && e.destroyNode(a), null != s && function dC(t, e, n, r, i) { const s = n[7]; s !== ze(n) && Ds(e, t, r, s, i); for (let a = 10; a < n.length; a++) { const l = n[a]; Xo(l[1], l, t, e, r, s) } }(e, t, s, n, i) } } function _d(t, e, n) { if (Re(t)) return t.createElement(e, n); { const r = null !== n ? function Ak(t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(n) : null; return null === r ? t.createElement(e) : t.createElementNS(r, e) } } function um(t, e) { const n = t[9], r = n.indexOf(e), i = e[3]; 1024 & e[2] && (e[2] &= -1025, $c(i, -1)), n.splice(r, 1) } function yd(t, e) { if (t.length <= 10) return; const n = 10 + e, r = t[n]; if (r) { const i = r[17]; null !== i && i !== t && um(i, r), e > 0 && (t[n - 1][4] = r[4]); const s = ou(t, 10 + e); !function eC(t, e) { Xo(t, e, e[Y], 2, null, null), e[0] = null, e[6] = null }(r[1], r); const o = s[19]; null !== o && o.detachView(s[1]), r[3] = null, r[4] = null, r[2] &= -129 } return r } function cm(t, e) { if (!(256 & e[2])) { const n = e[Y]; Re(n) && n.destroyNode && Xo(t, e, n, 3, null, null), function rC(t) { let e = t[13]; if (!e) return wd(t[1], t); for (; e;) { let n = null; if (Wn(e)) n = e[13]; else { const r = e[10]; r && (n = r) } if (!n) { for (; e && !e[4] && e !== t;)Wn(e) && wd(e[1], e), e = e[3]; null === e && (e = t), Wn(e) && wd(e[1], e), n = e && e[4] } e = n } }(e) } } function wd(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function aC(t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const i = e[n[r]]; if (!(i instanceof Fo)) { const s = n[r + 1]; if (Array.isArray(s)) for (let o = 0; o < s.length; o += 2) { const a = i[s[o]], l = s[o + 1]; try { l.call(a) } finally { } } else try { s.call(i) } finally { } } } }(t, e), function oC(t, e) { const n = t.cleanup, r = e[7]; let i = -1; if (null !== n) for (let s = 0; s < n.length - 1; s += 2)if ("string" == typeof n[s]) { const o = n[s + 1], a = "function" == typeof o ? o(e) : ze(e[o]), l = r[i = n[s + 2]], u = n[s + 3]; "boolean" == typeof u ? a.removeEventListener(n[s], l, u) : u >= 0 ? r[i = u]() : r[i = -u].unsubscribe(), s += 2 } else { const o = r[i = n[s + 1]]; n[s].call(o) } if (null !== r) { for (let s = i + 1; s < r.length; s++)r[s](); e[7] = null } }(t, e), 1 === e[1].type && Re(e[Y]) && e[Y].destroy(); const n = e[17]; if (null !== n && xn(e[3])) { n !== e[3] && um(n, e); const r = e[19]; null !== r && r.detachView(t) } } } function dm(t, e, n) { return function fm(t, e, n) { let r = e; for (; null !== r && 40 & r.type;)r = (e = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const i = t.data[r.directiveStart].encapsulation; if (i === zn.None || i === zn.Emulated) return null } return Ht(r, n) }(t, e.parent, n) } function Ti(t, e, n, r, i) { Re(t) ? t.insertBefore(e, n, r, i) : e.insertBefore(n, r, i) } function hm(t, e, n) { Re(t) ? t.appendChild(e, n) : e.appendChild(n) } function pm(t, e, n, r, i) { null !== r ? Ti(t, e, n, r, i) : hm(t, e, n) } function du(t, e) { return Re(t) ? t.parentNode(e) : e.parentNode } let _m = function mm(t, e, n) { return 40 & t.type ? Ht(t, n) : null }; function fu(t, e, n, r) { const i = dm(t, r, e), s = e[Y], a = function gm(t, e, n) { return _m(t, e, n) }(r.parent || e[6], r, e); if (null != i) if (Array.isArray(n)) for (let l = 0; l < n.length; l++)pm(s, i, n[l], a, !1); else pm(s, i, n, a, !1) } function hu(t, e) { if (null !== e) { const n = e.type; if (3 & n) return Ht(e, t); if (4 & n) return bd(-1, t[e.index]); if (8 & n) { const r = e.child; if (null !== r) return hu(t, r); { const i = t[e.index]; return xn(i) ? bd(-1, i) : ze(i) } } if (32 & n) return hd(e, t)() || ze(t[e.index]); { const r = wm(t, e); return null !== r ? Array.isArray(r) ? r[0] : hu(Yo(t[16]), r) : hu(t, e.next) } } return null } function wm(t, e) { return null !== e ? t[16][6].projection[e.projection] : null } function bd(t, e) { const n = 10 + t + 1; if (n < e.length) { const r = e[n], i = r[1].firstChild; if (null !== i) return hu(r, i) } return e[7] } function kd(t, e, n, r, i, s, o) { for (; null != n;) { const a = r[n.index], l = n.type; if (o && 0 === e && (a && mt(ze(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & l) kd(t, e, n.child, r, i, s, !1), Ds(e, t, i, a, s); else if (32 & l) { const u = hd(n, r); let c; for (; c = u();)Ds(e, t, i, c, s); Ds(e, t, i, a, s) } else 16 & l ? vm(t, e, r, n, i, s) : Ds(e, t, i, a, s); n = o ? n.projectionNext : n.next } } function Xo(t, e, n, r, i, s) { kd(n, r, t.firstChild, e, i, s, !1) } function vm(t, e, n, r, i, s) { const o = n[16], l = o[6].projection[r.projection]; if (Array.isArray(l)) for (let u = 0; u < l.length; u++)Ds(e, t, i, l[u], s); else kd(t, e, l, o[3], i, s, !0) } function bm(t, e, n) { Re(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function Dd(t, e, n) { Re(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } function Od(t) { return t.ngOriginalError } function UC(t, ...e) { t.error(...e) } class ea { constructor() { this._console = console } handleError(e) { const n = this._findOriginalError(e), r = function HC(t) { return t && t.ngErrorLogger || UC }(e); r(this._console, "ERROR", e), n && r(this._console, "ORIGINAL ERROR", n) } _findOriginalError(e) { let n = e && Od(e); for (; n && Od(n);)n = Od(n); return n || null } } const XC = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(we))(); function Xn(t) { return t instanceof Function ? t() : t } function Fm(t, e, n) { let r = t.length; for (; ;) { const i = t.indexOf(e, n); if (-1 === i) return i; if (0 === i || t.charCodeAt(i - 1) <= 32) { const s = e.length; if (i + s === r || t.charCodeAt(i + s) <= 32) return i } n = i + 1 } } const Nm = "ng-template"; function ex(t, e, n) { let r = 0; for (; r < t.length;) { let i = t[r++]; if (n && "class" === i) { if (i = t[r], -1 !== Fm(i.toLowerCase(), e, 0)) return !0 } else if (1 === i) { for (; r < t.length && "string" == typeof (i = t[r++]);)if (i.toLowerCase() === e) return !0; return !1 } } return !1 } function Lm(t) { return 4 === t.type && t.value !== Nm } function tx(t, e, n) { return e === (4 !== t.type || n ? t.value : Nm) } function nx(t, e, n) { let r = 4; const i = t.attrs || [], s = function sx(t) { for (let e = 0; e < t.length; e++)if (Mg(t[e])) return e; return t.length }(i); let o = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!o) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !tx(t, l, n) || "" === l && 1 === e.length) { if (Mn(r)) return !1; o = !0 } } else { const u = 8 & r ? l : e[++a]; if (8 & r && null !== t.attrs) { if (!ex(t.attrs, u, n)) { if (Mn(r)) return !1; o = !0 } continue } const d = rx(8 & r ? "class" : l, i, Lm(t), n); if (-1 === d) { if (Mn(r)) return !1; o = !0; continue } if ("" !== u) { let f; f = d > s ? "" : i[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Fm(h, u, 0) || 2 & r && u !== f) { if (Mn(r)) return !1; o = !0 } } } } else { if (!o && !Mn(r) && !Mn(l)) return !1; if (o && Mn(l)) continue; o = !1, r = l | 1 & r } } return Mn(r) || o } function Mn(t) { return 0 == (1 & t) } function rx(t, e, n, r) { if (null === e) return -1; let i = 0; if (r || !n) { let s = !1; for (; i < e.length;) { const o = e[i]; if (o === t) return i; if (3 === o || 6 === o) s = !0; else { if (1 === o || 2 === o) { let a = e[++i]; for (; "string" == typeof a;)a = e[++i]; continue } if (4 === o) break; if (0 === o) { i += 4; continue } } i += s ? 1 : 2 } return -1 } return function ox(t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const r = t[n]; if ("number" == typeof r) return -1; if (r === e) return n; n++ } return -1 }(e, t) } function Zm(t, e, n = !1) { for (let r = 0; r < e.length; r++)if (nx(t, e[r], n)) return !0; return !1 } function Vm(t, e) { return t ? ":not(" + e.trim() + ")" : e } function lx(t) { let e = t[0], n = 1, r = 2, i = "", s = !1; for (; n < t.length;) { let o = t[n]; if ("string" == typeof o) if (2 & r) { const a = t[++n]; i += "[" + o + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? i += "." + o : 4 & r && (i += " " + o); else "" !== i && !Mn(o) && (e += Vm(s, i), i = ""), r = o, s = s || !Mn(r); n++ } return "" !== i && (e += Vm(s, i)), e } const $ = {}; function jm(t, e, n, r) { if (!r) if (3 == (3 & e[2])) { const s = t.preOrderCheckHooks; null !== s && Kl(e, s, n) } else { const s = t.preOrderHooks; null !== s && Jl(e, s, 0, n) } Br(n) } function Km(t, e) { const n = t.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r], s = n[r + 1]; if (-1 !== s) { const o = t.data[s]; Yc(i), o.contentQueries(2, e[s], s) } } } function ta(t, e, n, r, i, s, o, a, l, u) { const c = e.blueprint.slice(); return c[0] = i, c[2] = 140 | r, gg(c), c[3] = c[15] = t, c[8] = n, c[10] = o || t && t[10], c[Y] = a || t && t[Y], c[12] = l || t && t[12] || null, c[9] = u || t && t[9] || null, c[6] = s, c[16] = 2 == e.type ? t[16] : c, c } function xs(t, e, n, r, i) { let s = t.data[e]; if (null === s) s = function zd(t, e, n, r, i) { const s = yg(), o = zc(), l = t.data[e] = function xx(t, e, n, r, i, s) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: i, attrs: s, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? s : s && s.parent, n, e, r, i); return null === t.firstChild && (t.firstChild = l), null !== s && (o ? null == s.child && null !== l.parent && (s.child = l) : null === s.next && (s.next = l)), l }(t, e, n, r, i), function $k() { return U.lFrame.inI18n }() && (s.flags |= 64); else if (64 & s.type) { s.type = n, s.value = r, s.attrs = i; const o = function Ro() { const t = U.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent }(); s.injectorIndex = null === o ? -1 : o.injectorIndex } return qn(s, !0), s } function Es(t, e, n, r) { if (0 === n) return -1; const i = e.length; for (let s = 0; s < n; s++)e.push(r), t.blueprint.push(r), t.data.push(null); return i } function na(t, e, n) { Yl(e); try { const r = t.viewQuery; null !== r && ef(1, r, n); const i = t.template; null !== i && Jm(t, e, i, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && Km(t, e), t.staticViewQueries && ef(2, t.viewQuery, n); const s = t.components; null !== s && function kx(t, e) { for (let n = 0; n < e.length; n++)$x(t, e[n]) }(e, s) } catch (r) { throw t.firstCreatePass && (t.incompleteFirstPass = !0, t.firstCreatePass = !1), r } finally { e[2] &= -5, Xl() } } function Ms(t, e, n, r) { const i = e[2]; if (256 != (256 & i)) { Yl(e); try { gg(e), function wg(t) { return U.lFrame.bindingIndex = t }(t.bindingStartIndex), null !== n && Jm(t, e, n, 2, r); const o = 3 == (3 & i); if (o) { const u = t.preOrderCheckHooks; null !== u && Kl(e, u, null) } else { const u = t.preOrderHooks; null !== u && Jl(e, u, 0, null), Xc(e, 0) } if (function Hx(t) { for (let e = pd(t); null !== e; e = gd(e)) { if (!e[2]) continue; const n = e[9]; for (let r = 0; r < n.length; r++) { const i = n[r], s = i[3]; 0 == (1024 & i[2]) && $c(s, 1), i[2] |= 1024 } } }(e), function jx(t) { for (let e = pd(t); null !== e; e = gd(e))for (let n = 10; n < e.length; n++) { const r = e[n], i = r[1]; Uc(r) && Ms(i, r, i.template, r[8]) } }(e), null !== t.contentQueries && Km(t, e), o) { const u = t.contentCheckHooks; null !== u && Kl(e, u) } else { const u = t.contentHooks; null !== u && Jl(e, u, 1), Xc(e, 1) } !function bx(t, e) { const n = t.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const i = n[r]; if (i < 0) Br(~i); else { const s = i, o = n[++r], a = n[++r]; zk(o, s), a(2, e[s]) } } } finally { Br(-1) } }(t, e); const a = t.components; null !== a && function Tx(t, e) { for (let n = 0; n < e.length; n++)Ux(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && ef(2, l, r), o) { const u = t.viewCheckHooks; null !== u && Kl(e, u) } else { const u = t.viewHooks; null !== u && Jl(e, u, 2), Xc(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), e[2] &= -73, 1024 & e[2] && (e[2] &= -1025, $c(e[3], -1)) } finally { Xl() } } } function Dx(t, e, n, r) { const i = e[10], o = pg(e); try { !o && i.begin && i.begin(), o && na(t, e, r), Ms(t, e, n, r) } finally { !o && i.end && i.end() } } function Jm(t, e, n, r, i) { const s = xt(), o = 2 & r; try { Br(-1), o && e.length > 20 && jm(t, e, 20, !1), n(r, i) } finally { Br(s) } } function t_(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = bu(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function bu(t, e, n, r, i, s, o, a, l, u) { const c = 20 + r, d = c + i, f = function Cx(t, e) { const n = []; for (let r = 0; r < e; r++)n.push(r < t ? null : $); return n }(c, d), h = "function" == typeof u ? u() : u; return f[1] = { type: t, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: e, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof s ? s() : s, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: h, incompleteFirstPass: !1 } } function i_(t, e, n, r) { const i = p_(e); null === n ? i.push(r) : (i.push(n), t.firstCreatePass && g_(t).push(r, i.length - 1)) } function s_(t, e, n) { for (let r in t) if (t.hasOwnProperty(r)) { const i = t[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(e, i) : n[r] = [e, i] } return n } function a_(t, e, n, r, i, s) { const o = s.hostBindings; if (o) { let a = t.hostBindingOpCodes; null === a && (a = t.hostBindingOpCodes = []); const l = ~e.index; (function Px(t) { let e = t.length; for (; e > 0;) { const n = t[--e]; if ("number" == typeof n && n < 0) return n } return 0 })(a) != l && a.push(l), a.push(r, i, o) } } function l_(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function u_(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function Lx(t, e, n) { if (n) { if (e.exportAs) for (let r = 0; r < e.exportAs.length; r++)n[e.exportAs[r]] = t; En(e) && (n[""] = t) } } function c_(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function d_(t, e, n, r, i) { t.data[r] = i; const s = i.factory || (i.factory = vi(i.type)), o = new Fo(s, En(i), null); t.blueprint[r] = o, n[r] = o, a_(t, e, 0, r, Es(t, n, i.hostVars, $), i) } function Zx(t, e, n) { const r = Ht(e, t), i = t_(n), s = t[10], o = Tu(t, ta(t, i, null, n.onPush ? 64 : 16, r, e, s, s.createRenderer(r, n), null, null)); t[e.index] = o } function Vx(t, e, n, r, i, s) { const o = s[e]; if (null !== o) { const a = r.setInput; for (let l = 0; l < o.length;) { const u = o[l++], c = o[l++], d = o[l++]; null !== a ? r.setInput(n, d, u, c) : n[c] = d } } } function Bx(t, e) { let n = null, r = 0; for (; r < e.length;) { const i = e[r]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; t.hasOwnProperty(i) && (null === n && (n = []), n.push(i, t[i], e[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function Ux(t, e) { const n = Ut(e, t); if (Uc(n)) { const r = n[1]; 80 & n[2] ? Ms(r, n, r.template, n[8]) : n[5] > 0 && Xd(n) } } function Xd(t) { for (let r = pd(t); null !== r; r = gd(r))for (let i = 10; i < r.length; i++) { const s = r[i]; if (1024 & s[2]) { const o = s[1]; Ms(o, s, o.template, s[8]) } else s[5] > 0 && Xd(s) } const n = t[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const i = Ut(n[r], t); Uc(i) && i[5] > 0 && Xd(i) } } function $x(t, e) { const n = Ut(e, t), r = n[1]; (function zx(t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) })(r, n), na(r, n, n[8]) } function Tu(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function Qd(t) { for (; t;) { t[2] |= 64; const e = Yo(t); if (bk(t) && !e) return t; t = e } return null } function h_(t) { !function Kd(t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], r = dd(n), i = r[1]; Dx(i, r, i.template, n) } }(t[8]) } function ef(t, e, n) { Yc(0), e(t, n) } const qx = (() => Promise.resolve(null))(); function p_(t) { return t[7] || (t[7] = []) } function g_(t) { return t.cleanup || (t.cleanup = []) } function __(t, e) { const n = t[9], r = n ? n.get(ea, null) : null; r && r.handleError(e) } function y_(t, e, n, r, i) { for (let s = 0; s < n.length;) { const o = n[s++], a = n[s++], l = e[o], u = t.data[o]; null !== u.setInput ? u.setInput(l, i, r, a) : l[a] = i } } function ku(t, e, n) { let r = n ? t.styles : null, i = n ? t.classes : null, s = 0; if (null !== e) for (let o = 0; o < e.length; o++) { const a = e[o]; "number" == typeof a ? s = a : 1 == s ? i = Tn(i, a) : 2 == s && (r = Tn(r, a + ": " + e[++o] + ";")) } n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = i : t.classesWithoutHost = i } const tf = new ce("INJECTOR", -1); class w_ { get(e, n = Uo) { if (n === Uo) { const r = new Error(`NullInjectorError: No provider for ${ae(e)}!`); throw r.name = "NullInjectorError", r } return n } } const nf = new ce("Set Injector scope."), ra = {}, Xx = {}; let rf; function v_() { return void 0 === rf && (rf = new w_), rf } function b_(t, e = null, n = null, r) { const i = T_(t, e, n, r); return i._resolveInjectorDefTypes(), i } function T_(t, e = null, n = null, r) { return new Qx(t, n, e || v_(), r) } class Qx { constructor(e, n, r, i = null) { this.parent = r, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = []; n && Gn(n, a => this.processProvider(a, e, n)), Gn([e], a => this.processInjectorType(a, [], s)), this.records.set(tf, Ss(void 0, this)); const o = this.records.get(nf); this.scope = null != o ? o.value : null, this.source = i || ("object" == typeof e ? null : ae(e)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(e => e.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(e, n = Uo, r = H.Default) { this.assertNotDestroyed(); const i = Wg(this), s = Nr(void 0); try { if (!(r & H.SkipSelf)) { let a = this.records.get(e); if (void 0 === a) { const l = function sE(t) { return "function" == typeof t || "object" == typeof t && t instanceof ce }(e) && Mc(e); a = l && this.injectableDefInScope(l) ? Ss(sf(e), ra) : null, this.records.set(e, a) } if (null != a) return this.hydrate(e, a) } return (r & H.Self ? v_() : this.parent).get(e, n = r & H.Optional && n === Uo ? null : n) } catch (o) { if ("NullInjectorError" === o.name) { if ((o[lu] = o[lu] || []).unshift(ae(e)), i) throw o; return function PD(t, e, n, r) { const i = t[lu]; throw e[zg] && i.unshift(e[zg]), t.message = function OD(t, e, n, r = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let i = ae(e); if (Array.isArray(e)) i = e.map(ae).join(" -> "); else if ("object" == typeof e) { let s = []; for (let o in e) if (e.hasOwnProperty(o)) { let a = e[o]; s.push(o + ":" + ("string" == typeof a ? JSON.stringify(a) : ae(a))) } i = `{${s.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${i}]: ${t.replace(xD, "\n  ")}` }("\n" + t.message, i, n, r), t.ngTokenPath = i, t[lu] = null, t }(o, e, "R3InjectorError", this.source) } throw o } finally { Nr(s), Wg(i) } } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(e => this.get(e)) } toString() { const e = []; return this.records.forEach((r, i) => e.push(ae(i))), `R3Injector[${e.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new le(205, !1) } processInjectorType(e, n, r) { if (!(e = j(e))) return !1; let i = tg(e); const s = null == i && e.ngModule || void 0, o = void 0 === s ? e : s, a = -1 !== r.indexOf(o); if (void 0 !== s && (i = tg(s)), null == i) return !1; if (null != i.imports && !a) { let c; r.push(o); try { Gn(i.imports, d => { this.processInjectorType(d, n, r) && (void 0 === c && (c = []), c.push(d)) }) } finally { } if (void 0 !== c) for (let d = 0; d < c.length; d++) { const { ngModule: f, providers: h } = c[d]; Gn(h, p => this.processProvider(p, f, h || be)) } } this.injectorDefTypes.add(o); const l = vi(o) || (() => new o); this.records.set(o, Ss(l, ra)); const u = i.providers; if (null != u && !a) { const c = e; Gn(u, d => this.processProvider(d, c, u)) } return void 0 !== s && void 0 !== e.providers } processProvider(e, n, r) { let i = Is(e = j(e)) ? e : j(e && e.provide); const s = function Jx(t, e, n) { return D_(t) ? Ss(void 0, t.useValue) : Ss(function k_(t, e, n) { let r; if (Is(t)) { const i = j(t); return vi(i) || sf(i) } if (D_(t)) r = () => j(t.useValue); else if (function tE(t) { return !(!t || !t.useFactory) }(t)) r = () => t.useFactory(...ld(t.deps || [])); else if (function eE(t) { return !(!t || !t.useExisting) }(t)) r = () => V(j(t.useExisting)); else { const i = j(t && (t.useClass || t.provide)); if (!function rE(t) { return !!t.deps }(t)) return vi(i) || sf(i); r = () => new i(...ld(t.deps)) } return r }(t), ra) }(e); if (Is(e) || !0 !== e.multi) this.records.get(i); else { let o = this.records.get(i); o || (o = Ss(void 0, ra, !0), o.factory = () => ld(o.multi), this.records.set(i, o)), i = e, o.multi.push(e) } this.records.set(i, s) } hydrate(e, n) { return n.value === ra && (n.value = Xx, n.value = n.factory()), "object" == typeof n.value && n.value && function iE(t) { return null !== t && "object" == typeof t && "function" == typeof t.ngOnDestroy }(n.value) && this.onDestroy.add(n.value), n.value } injectableDefInScope(e) { if (!e.providedIn) return !1; const n = j(e.providedIn); return "string" == typeof n ? "any" === n || n === this.scope : this.injectorDefTypes.has(n) } } function sf(t) { const e = Mc(t), n = null !== e ? e.factory : vi(t); if (null !== n) return n; if (t instanceof ce) throw new le(204, !1); if (t instanceof Function) return function Kx(t) { const e = t.length; if (e > 0) throw function Ho(t, e) { const n = []; for (let r = 0; r < t; r++)n.push(e); return n }(e, "?"), new le(204, !1); const n = function lk(t) { const e = t && (t[Bl] || t[ng]); if (e) { const n = function uk(t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new le(204, !1) } function Ss(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function D_(t) { return null !== t && "object" == typeof t && MD in t } function Is(t) { return "function" == typeof t } let qt = (() => { class t { static create(n, r) { var i; if (Array.isArray(n)) return b_({ name: "" }, r, n, ""); { const s = null !== (i = n.name) && void 0 !== i ? i : ""; return b_({ name: s }, n.parent, n.providers, s) } } } return t.THROW_IF_NOT_FOUND = Uo, t.NULL = new w_, t.\u0275prov = oe({ token: t, providedIn: "any", factory: () => V(tf) }), t.__NG_ELEMENT_ID__ = -1, t })(); function hE(t, e) { Ql(dd(t)[1], Qe()) } let Du = null; function As() { if (!Du) { const t = we.Symbol; if (t && t.iterator) Du = t.iterator; else { const e = Object.getOwnPropertyNames(Map.prototype); for (let n = 0; n < e.length; ++n) { const r = e[n]; "entries" !== r && "size" !== r && Map.prototype[r] === Map.prototype.entries && (Du = r) } } } return Du } function N(t, e = H.Default) { const n = x(); return null === n ? V(t, e) : Fg(Qe(), n, j(t), e) } function gf() { throw new Error("invalid") } function Eu(t, e, n) { const r = x(); return function _t(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) }(r, function ps() { return U.lFrame.bindingIndex++ }(), e) && function Wt(t, e, n, r, i, s, o, a) { const l = Ht(e, n); let c, u = e.inputs; !a && null != u && (c = u[r]) ? (y_(t, n, c, r, i), zl(e) && function Sx(t, e) { const n = Ut(e, t); 16 & n[2] || (n[2] |= 64) }(n, e.index)) : 3 & e.type && (r = function Mx(t) { return "class" === t ? "className" : "for" === t ? "htmlFor" : "formaction" === t ? "formAction" : "innerHtml" === t ? "innerHTML" : "readonly" === t ? "readOnly" : "tabindex" === t ? "tabIndex" : t }(r), i = null != o ? o(i, e.value || "", r) : i, Re(s) ? s.setProperty(l, r, i) : Kc(r) || (l.setProperty ? l.setProperty(r, i) : l[r] = i)) }(ue(), function Me() { const t = U.lFrame; return Hc(t.tView, t.selectedIndex) }(), r, t, e, r[Y], n, !1), Eu } function mf(t, e, n, r, i) { const o = i ? "class" : "style"; y_(t, n, e.inputs[o], o, r) } function oa(t, e, n, r) { const i = x(), s = ue(), o = 20 + t, a = i[Y], l = i[o] = _d(a, e, function eD() { return U.lFrame.currentNamespace }()), u = s.firstCreatePass ? function qE(t, e, n, r, i, s, o) { const a = e.consts, u = xs(e, t, 2, i, Vr(a, s)); return function Gd(t, e, n, r) { let i = !1; if (_g()) { const s = function Fx(t, e, n) { const r = t.directiveRegistry; let i = null; if (r) for (let s = 0; s < r.length; s++) { const o = r[s]; Zm(n, o.selectors, !1) && (i || (i = []), iu(Lo(n, e), t, o.type), En(o) ? (u_(t, n), i.unshift(o)) : i.push(o)) } return i }(t, e, n), o = null === r ? null : { "": -1 }; if (null !== s) { i = !0, c_(n, t.data.length, s.length); for (let c = 0; c < s.length; c++) { const d = s[c]; d.providersResolver && d.providersResolver(d) } let a = !1, l = !1, u = Es(t, e, s.length, null); for (let c = 0; c < s.length; c++) { const d = s[c]; n.mergedAttrs = tu(n.mergedAttrs, d.hostAttrs), d_(t, n, e, u, d), Lx(u, d, o), null !== d.contentQueries && (n.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (n.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index), a = !0), !l && (f.ngOnChanges || f.ngDoCheck) && ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index), l = !0), u++ } !function Ex(t, e) { const r = e.directiveEnd, i = t.data, s = e.attrs, o = []; let a = null, l = null; for (let u = e.directiveStart; u < r; u++) { const c = i[u], d = c.inputs, f = null === s || Lm(e) ? null : Bx(d, s); o.push(f), a = s_(d, u, a), l = s_(c.outputs, u, l) } null !== a && (a.hasOwnProperty("class") && (e.flags |= 16), a.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = o, e.inputs = a, e.outputs = l }(t, n) } o && function Nx(t, e, n) { if (e) { const r = t.localNames = []; for (let i = 0; i < e.length; i += 2) { const s = n[e[i + 1]]; if (null == s) throw new le(-301, !1); r.push(e[i], s) } } }(n, r, o) } return n.mergedAttrs = tu(n.mergedAttrs, n.attrs), i }(e, n, u, Vr(a, o)), null !== u.attrs && ku(u, u.attrs, !1), null !== u.mergedAttrs && ku(u, u.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, u), u }(o, s, i, 0, e, n, r) : s.data[o]; qn(u, !0); const c = u.mergedAttrs; null !== c && eu(a, l, c); const d = u.classes; null !== d && Dd(a, l, d); const f = u.styles; return null !== f && bm(a, l, f), 64 != (64 & u.flags) && fu(s, i, l, u), 0 === function Lk() { return U.lFrame.elementDepthCount }() && mt(l, i), function Zk() { U.lFrame.elementDepthCount++ }(), Wl(u) && (function Wd(t, e, n) { !_g() || (function Ox(t, e, n, r) { const i = n.directiveStart, s = n.directiveEnd; t.firstCreatePass || Lo(n, e), mt(r, e); const o = n.initialInputs; for (let a = i; a < s; a++) { const l = t.data[a], u = En(l); u && Zx(e, n, l); const c = Zo(e, t, a, n); mt(c, e), null !== o && Vx(0, a - i, c, l, 0, o), u && (Ut(n.index, e)[8] = c) } }(t, e, n, Ht(n, e)), 128 == (128 & n.flags) && function Rx(t, e, n) { const r = n.directiveStart, i = n.directiveEnd, o = n.index, a = function Wk() { return U.lFrame.currentDirectiveIndex }(); try { Br(o); for (let l = r; l < i; l++) { const u = t.data[l], c = e[l]; qc(l), (null !== u.hostBindings || 0 !== u.hostVars || null !== u.hostAttrs) && l_(u, c) } } finally { Br(-1), qc(a) } }(t, e, n)) }(s, i, u), function e_(t, e, n) { if (Fc(e)) { const i = e.directiveEnd; for (let s = e.directiveStart; s < i; s++) { const o = t.data[s]; o.contentQueries && o.contentQueries(1, n[s], s) } } }(s, u, i)), null !== r && function qd(t, e, n = Ht) { const r = e.localNames; if (null !== r) { let i = e.index + 1; for (let s = 0; s < r.length; s += 2) { const o = r[s + 1], a = -1 === o ? n(e, t) : t[o]; t[i++] = a } } }(i, u), oa } function Mu() { let t = Qe(); zc() ? function Wc() { U.lFrame.isParent = !1 }() : (t = t.parent, qn(t, !1)); const e = t; !function Vk() { U.lFrame.elementDepthCount-- }(); const n = ue(); return n.firstCreatePass && (Ql(n, t), Fc(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function sD(t) { return 0 != (16 & t.flags) }(e) && mf(n, e, x(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function oD(t) { return 0 != (32 & t.flags) }(e) && mf(n, e, x(), e.stylesWithoutHost, !1), Mu } function aa(t, e, n, r) { return oa(t, e, n, r), Mu(), aa } function Su(t) { return !!t && "function" == typeof t.then } const s2 = function i2(t) { return !!t && "function" == typeof t.subscribe }; function la(t, e, n, r) { const i = x(), s = ue(), o = Qe(); return function a2(t, e, n, r, i, s, o, a) { const l = Wl(r), c = t.firstCreatePass && g_(t), d = e[8], f = p_(e); let h = !0; if (3 & r.type || a) { const y = Ht(r, e), v = a ? a(y) : y, w = f.length, T = a ? C => a(ze(C[r.index])) : r.index; if (Re(n)) { let C = null; if (!a && l && (C = function XE(t, e, n, r) { const i = t.cleanup; if (null != i) for (let s = 0; s < i.length - 1; s += 2) { const o = i[s]; if (o === n && i[s + 1] === r) { const a = e[7], l = i[s + 2]; return a.length > l ? a[l] : null } "string" == typeof o && (s += 2) } return null }(t, e, i, r.index)), null !== C) (C.__ngLastListenerFn__ || C).__ngNextListenerFn__ = s, C.__ngLastListenerFn__ = s, h = !1; else { s = wf(r, e, d, s, !1); const D = n.listen(v, i, s); f.push(s, D), c && c.push(i, T, w, w + 1) } } else s = wf(r, e, d, s, !0), v.addEventListener(i, s, o), f.push(s), c && c.push(i, T, w, o) } else s = wf(r, e, d, s, !1); const p = r.outputs; let m; if (h && null !== p && (m = p[i])) { const y = m.length; if (y) for (let v = 0; v < y; v += 2) { const M = e[m[v]][m[v + 1]].subscribe(s), S = f.length; f.push(s, M), c && c.push(i, r.index, S, -(S + 1)) } } }(s, i, i[Y], o, t, e, !!n, r), la } function l2(t, e, n, r) { try { return !1 !== n(r) } catch (i) { return __(t, i), !1 } } function wf(t, e, n, r, i) { return function s(o) { if (o === Function) return r; const a = 2 & t.flags ? Ut(t.index, e) : e; 0 == (32 & e[2]) && Qd(a); let l = l2(e, 0, r, o), u = s.__ngNextListenerFn__; for (; u;)l = l2(e, 0, u, o) && l, u = u.__ngNextListenerFn__; return i && !1 === l && (o.preventDefault(), o.returnValue = !1), l } } function O2(t, e = "") { const n = x(), r = ue(), i = t + 20, s = r.firstCreatePass ? xs(r, i, 1, e, null) : r.data[i], o = n[i] = function md(t, e) { return Re(t) ? t.createText(e) : t.createTextNode(e) }(n[Y], e); fu(r, n, o, s), qn(s, !1) } const Au = "en-US"; let n1 = Au; class E1 { } class jS { resolveComponentFactory(e) { throw function BS(t) { const e = Error(`No component factory found for ${ae(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(e) } } let pa = (() => { class t { } return t.NULL = new jS, t })(); function HS() { return zs(Qe(), x()) } function zs(t, e) { return new Wr(Ht(t, e)) } let Wr = (() => { class t { constructor(n) { this.nativeElement = n } } return t.__NG_ELEMENT_ID__ = HS, t })(); function US(t) { return t instanceof Wr ? t.nativeElement : t } class S1 { } let WS = (() => { class t { } return t.\u0275prov = oe({ token: t, providedIn: "root", factory: () => null }), t })(); class Lu { constructor(e) { this.full = e, this.major = e.split(".")[0], this.minor = e.split(".")[1], this.patch = e.split(".").slice(2).join(".") } } const qS = new Lu("13.3.12"), Sf = {}; function Zu(t, e, n, r, i = !1) { for (; null !== n;) { const s = e[n.index]; if (null !== s && r.push(ze(s)), xn(s)) for (let a = 10; a < s.length; a++) { const l = s[a], u = l[1].firstChild; null !== u && Zu(l[1], l, u, r) } const o = n.type; if (8 & o) Zu(t, e, n.child, r); else if (32 & o) { const a = hd(n, e); let l; for (; l = a();)r.push(l) } else if (16 & o) { const a = wm(e, n); if (Array.isArray(a)) r.push(...a); else { const l = Yo(e[16]); Zu(l[1], l, a, r, !0) } } n = i ? n.projectionNext : n.next } return r } class ga { constructor(e, n) { this._lView = e, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const e = this._lView, n = e[1]; return Zu(n, e, n.firstChild, []) } get context() { return this._lView[8] } set context(e) { this._lView[8] = e } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const e = this._lView[3]; if (xn(e)) { const n = e[8], r = n ? n.indexOf(this) : -1; r > -1 && (yd(e, r), ou(n, r)) } this._attachedToViewContainer = !1 } cm(this._lView[1], this._lView) } onDestroy(e) { i_(this._lView[1], this._lView, null, e) } markForCheck() { Qd(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { !function Jd(t, e, n) { const r = e[10]; r.begin && r.begin(); try { Ms(t, e, t.template, n) } catch (i) { throw __(e, i), i } finally { r.end && r.end() } }(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new le(902, ""); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function nC(t, e) { Xo(t, e, e[Y], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(e) { if (this._attachedToViewContainer) throw new le(902, ""); this._appRef = e } } class GS extends ga { constructor(e) { super(e), this._view = e } detectChanges() { h_(this._view) } checkNoChanges() { } get context() { return null } } class I1 extends pa { constructor(e) { super(), this.ngModule = e } resolveComponentFactory(e) { const n = ut(e); return new If(n, this.ngModule) } } function A1(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } class If extends E1 { constructor(e, n) { super(), this.componentDef = e, this.ngModule = n, this.componentType = e.type, this.selector = function ux(t) { return t.map(lx).join(",") }(e.selectors), this.ngContentSelectors = e.ngContentSelectors ? e.ngContentSelectors : [], this.isBoundToModule = !!n } get inputs() { return A1(this.componentDef.inputs) } get outputs() { return A1(this.componentDef.outputs) } create(e, n, r, i) { const s = (i = i || this.ngModule) ? function XS(t, e) { return { get: (n, r, i) => { const s = t.get(n, Sf, i); return s !== Sf || r === Sf ? s : e.get(n, r, i) } } }(e, i.injector) : e, o = s.get(S1, hg), a = s.get(WS, null), l = o.createRenderer(null, this.componentDef), u = this.componentDef.selectors[0][0] || "div", c = r ? function r_(t, e, n) { if (Re(t)) return t.selectRootElement(e, n === zn.ShadowDom); let r = "string" == typeof e ? t.querySelector(e) : e; return r.textContent = "", r }(l, r, this.componentDef.encapsulation) : _d(o.createRenderer(null, this.componentDef), u, function YS(t) { const e = t.toLowerCase(); return "svg" === e ? "svg" : "math" === e ? "math" : null }(u)), d = this.componentDef.onPush ? 576 : 528, f = function F_(t, e) { return { components: [], scheduler: t || XC, clean: qx, playerHandler: e || null, flags: 0 } }(), h = bu(0, null, null, 1, 0, null, null, null, null, null), p = ta(null, h, f, d, null, null, o, l, a, s); let m, y; Yl(p); try { const v = function O_(t, e, n, r, i, s) { const o = n[1]; n[20] = t; const l = xs(o, 20, 2, "#host", null), u = l.mergedAttrs = e.hostAttrs; null !== u && (ku(l, u, !0), null !== t && (eu(i, t, u), null !== l.classes && Dd(i, t, l.classes), null !== l.styles && bm(i, t, l.styles))); const c = r.createRenderer(t, e), d = ta(n, t_(e), null, e.onPush ? 64 : 16, n[20], l, r, c, s || null, null); return o.firstCreatePass && (iu(Lo(l, n), o, e.type), u_(o, l), c_(l, n.length, 1)), Tu(n, d), n[20] = d }(c, this.componentDef, p, o, l); if (c) if (r) eu(l, c, ["ng-version", qS.full]); else { const { attrs: w, classes: T } = function cx(t) { const e = [], n = []; let r = 1, i = 2; for (; r < t.length;) { let s = t[r]; if ("string" == typeof s) 2 === i ? "" !== s && e.push(s, t[++r]) : 8 === i && n.push(s); else { if (!Mn(i)) break; i = s } r++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); w && eu(l, c, w), T && T.length > 0 && Dd(l, c, T.join(" ")) } if (y = Hc(h, 20), void 0 !== n) { const w = y.projection = []; for (let T = 0; T < this.ngContentSelectors.length; T++) { const C = n[T]; w.push(null != C ? Array.from(C) : null) } } m = function R_(t, e, n, r, i) { const s = n[1], o = function Ax(t, e, n) { const r = Qe(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), d_(t, r, e, Es(t, e, 1, null), n)); const i = Zo(e, t, r.directiveStart, r); mt(i, e); const s = Ht(r, e); return s && mt(s, e), i }(s, n, e); if (r.components.push(o), t[8] = o, i && i.forEach(l => l(o, e)), e.contentQueries) { const l = Qe(); e.contentQueries(1, o, l.directiveStart) } const a = Qe(); return !s.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (Br(a.index), a_(n[1], a, 0, a.directiveStart, a.directiveEnd, e), l_(e, o)), o }(v, this.componentDef, p, f, [hE]), na(h, p, null) } finally { Xl() } return new KS(this.componentType, m, zs(y, p), p, y) } } class KS extends class VS { }{ constructor(e, n, r, i, s) { super(), this.location = r, this._rootLView = i, this._tNode = s, this.instance = n, this.hostView = this.changeDetectorRef = new GS(i), this.componentType = e } get injector() { return new _s(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(e) { this.hostView.onDestroy(e) } } class gr { } class P1 { } const Ws = new Map; class F1 extends gr { constructor(e, n) { super(), this._parent = n, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new I1(this); const r = nn(e); this._bootstrapComponents = Xn(r.bootstrap), this._r3Injector = T_(e, n, [{ provide: gr, useValue: this }, { provide: pa, useValue: this.componentFactoryResolver }], ae(e)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(e) } get(e, n = qt.THROW_IF_NOT_FOUND, r = H.Default) { return e === qt || e === gr || e === tf ? this : this._r3Injector.get(e, n, r) } destroy() { const e = this._r3Injector; !e.destroyed && e.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(e) { this.destroyCbs.push(e) } } class Af extends P1 { constructor(e) { super(), this.moduleType = e, null !== nn(e) && function eI(t) { const e = new Set; !function n(r) { const i = nn(r, !0), s = i.id; null !== s && (function O1(t, e, n) { if (e && e !== n) throw new Error(`Duplicate module registered for ${t} - ${ae(e)} vs ${ae(e.name)}`) }(s, Ws.get(s), r), Ws.set(s, r)); const o = Xn(i.imports); for (const a of o) e.has(a) || (e.add(a), n(a)) }(t) }(e) } create(e) { return new F1(this.moduleType, e) } } function Pf(t) { return e => { setTimeout(t, void 0, e) } } const St = class yI extends gn { constructor(e = !1) { super(), this.__isAsync = e } emit(e) { super.next(e) } subscribe(e, n, r) { var i, s, o; let a = e, l = n || (() => null), u = r; if (e && "object" == typeof e) { const d = e; a = null === (i = d.next) || void 0 === i ? void 0 : i.bind(d), l = null === (s = d.error) || void 0 === s ? void 0 : s.bind(d), u = null === (o = d.complete) || void 0 === o ? void 0 : o.bind(d) } this.__isAsync && (l = Pf(l), a && (a = Pf(a)), u && (u = Pf(u))); const c = super.subscribe({ next: a, error: l, complete: u }); return e instanceof _e && e.add(c), c } }; function wI() { return this._results[As()]() } class Of { constructor(e = !1) { this._emitDistinctChangesOnly = e, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const n = As(), r = Of.prototype; r[n] || (r[n] = wI) } get changes() { return this._changes || (this._changes = new St) } get(e) { return this._results[e] } map(e) { return this._results.map(e) } filter(e) { return this._results.filter(e) } find(e) { return this._results.find(e) } reduce(e, n) { return this._results.reduce(e, n) } forEach(e) { this._results.forEach(e) } some(e) { return this._results.some(e) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(e, n) { const r = this; r.dirty = !1; const i = on(e); (this._changesDetected = !function _D(t, e, n) { if (t.length !== e.length) return !1; for (let r = 0; r < t.length; r++) { let i = t[r], s = e[r]; if (n && (i = n(i), s = n(s)), s !== i) return !1 } return !0 }(r._results, i, n)) && (r._results = i, r.length = i.length, r.last = i[this.length - 1], r.first = i[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } Symbol; let mr = (() => { class t { } return t.__NG_ELEMENT_ID__ = TI, t })(); const vI = mr, bI = class extends vI { constructor(e, n, r) { super(), this._declarationLView = e, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(e) { const n = this._declarationTContainer.tViews, r = ta(this._declarationLView, n, e, 16, null, n.declTNode, null, null, null, null); r[17] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[19]; return null !== s && (r[19] = s.createEmbeddedView(n)), na(n, r, e), new ga(r) } }; function TI() { return Vu(Qe(), x()) } function Vu(t, e) { return 4 & t.type ? new bI(e, t, zs(t, e)) : null } let On = (() => { class t { } return t.__NG_ELEMENT_ID__ = kI, t })(); function kI() { return U1(Qe(), x()) } const DI = On, j1 = class extends DI { constructor(e, n, r) { super(), this._lContainer = e, this._hostTNode = n, this._hostLView = r } get element() { return zs(this._hostTNode, this._hostLView) } get injector() { return new _s(this._hostTNode, this._hostLView) } get parentInjector() { const e = ru(this._hostTNode, this._hostLView); if (Ig(e)) { const n = ms(e, this._hostLView), r = gs(e); return new _s(n[1].data[r + 8], n) } return new _s(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(e) { const n = H1(this._lContainer); return null !== n && n[e] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(e, n, r) { const i = e.createEmbeddedView(n || {}); return this.insert(i, r), i } createComponent(e, n, r, i, s) { const o = e && !function jo(t) { return "function" == typeof t }(e); let a; if (o) a = n; else { const d = n || {}; a = d.index, r = d.injector, i = d.projectableNodes, s = d.ngModuleRef } const l = o ? e : new If(ut(e)), u = r || this.parentInjector; if (!s && null == l.ngModule) { const f = (o ? u : this.parentInjector).get(gr, null); f && (s = f) } const c = l.create(u, i, void 0, s); return this.insert(c.hostView, a), c } insert(e, n) { const r = e._lView, i = r[1]; if (function Nk(t) { return xn(t[3]) }(r)) { const c = this.indexOf(e); if (-1 !== c) this.detach(c); else { const d = r[3], f = new j1(d, d[6], d[3]); f.detach(f.indexOf(e)) } } const s = this._adjustIndex(n), o = this._lContainer; !function iC(t, e, n, r) { const i = 10 + r, s = n.length; r > 0 && (n[i - 1][4] = e), r < s - 10 ? (e[4] = n[i], Bg(n, 10 + r, e)) : (n.push(e), e[4] = null), e[3] = n; const o = e[17]; null !== o && n !== o && function sC(t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(o, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 128 }(i, r, o, s); const a = bd(s, o), l = r[Y], u = du(l, o[7]); return null !== u && function tC(t, e, n, r, i, s) { r[0] = i, r[6] = e, Xo(t, r, n, 1, i, s) }(i, o[6], l, r, u, a), e.attachToViewContainerRef(), Bg(Rf(o), s, e), e } move(e, n) { return this.insert(e, n) } indexOf(e) { const n = H1(this._lContainer); return null !== n ? n.indexOf(e) : -1 } remove(e) { const n = this._adjustIndex(e, -1), r = yd(this._lContainer, n); r && (ou(Rf(this._lContainer), n), cm(r[1], r)) } detach(e) { const n = this._adjustIndex(e, -1), r = yd(this._lContainer, n); return r && null != ou(Rf(this._lContainer), n) ? new ga(r) : null } _adjustIndex(e, n = 0) { return null == e ? this.length + n : e } }; function H1(t) { return t[8] } function Rf(t) { return t[8] || (t[8] = []) } function U1(t, e) { let n; const r = e[t.index]; if (xn(r)) n = r; else { let i; if (8 & t.type) i = ze(r); else { const s = e[Y]; i = s.createComment(""); const o = Ht(t, e); Ti(s, du(s, o), i, function uC(t, e) { return Re(t) ? t.nextSibling(e) : e.nextSibling }(s, o), !1) } e[t.index] = n = function f_(t, e, n, r) { return new Array(t, !0, !1, e, null, 0, r, n, null, null) }(r, e, i, t), Tu(e, n) } return new j1(n, t, e) } class Ff { constructor(e) { this.queryList = e, this.matches = null } clone() { return new Ff(this.queryList) } setDirty() { this.queryList.setDirty() } } class Nf { constructor(e = []) { this.queries = e } createEmbeddedView(e) { const n = e.queries; if (null !== n) { const r = null !== e.contentQueries ? e.contentQueries[0] : n.length, i = []; for (let s = 0; s < r; s++) { const o = n.getByIndex(s); i.push(this.queries[o.indexInDeclarationView].clone()) } return new Nf(i) } return null } insertView(e) { this.dirtyQueriesWithMatches(e) } detachView(e) { this.dirtyQueriesWithMatches(e) } dirtyQueriesWithMatches(e) { for (let n = 0; n < this.queries.length; n++)null !== Y1(e, n).matches && this.queries[n].setDirty() } } class $1 { constructor(e, n, r = null) { this.predicate = e, this.flags = n, this.read = r } } class Lf { constructor(e = []) { this.queries = e } elementStart(e, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].elementStart(e, n) } elementEnd(e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementEnd(e) } embeddedTView(e) { let n = null; for (let r = 0; r < this.length; r++) { const i = null !== n ? n.length : 0, s = this.getByIndex(r).embeddedTView(e, i); s && (s.indexInDeclarationView = r, null !== n ? n.push(s) : n = [s]) } return null !== n ? new Lf(n) : null } template(e, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].template(e, n) } getByIndex(e) { return this.queries[e] } get length() { return this.queries.length } track(e) { this.queries.push(e) } } class Zf { constructor(e, n = -1) { this.metadata = e, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = n } elementStart(e, n) { this.isApplyingToNode(n) && this.matchTNode(e, n) } elementEnd(e) { this._declarationNodeIndex === e.index && (this._appliesToNextNode = !1) } template(e, n) { this.elementStart(e, n) } embeddedTView(e, n) { return this.isApplyingToNode(e) ? (this.crossesNgTemplate = !0, this.addMatch(-e.index, n), new Zf(this.metadata)) : null } isApplyingToNode(e) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const n = this._declarationNodeIndex; let r = e.parent; for (; null !== r && 8 & r.type && r.index !== n;)r = r.parent; return n === (null !== r ? r.index : -1) } return this._appliesToNextNode } matchTNode(e, n) { const r = this.metadata.predicate; if (Array.isArray(r)) for (let i = 0; i < r.length; i++) { const s = r[i]; this.matchTNodeWithReadOption(e, n, EI(n, s)), this.matchTNodeWithReadOption(e, n, su(n, e, s, !1, !1)) } else r === mr ? 4 & n.type && this.matchTNodeWithReadOption(e, n, -1) : this.matchTNodeWithReadOption(e, n, su(n, e, r, !1, !1)) } matchTNodeWithReadOption(e, n, r) { if (null !== r) { const i = this.metadata.read; if (null !== i) if (i === Wr || i === On || i === mr && 4 & n.type) this.addMatch(n.index, -2); else { const s = su(n, e, i, !1, !1); null !== s && this.addMatch(n.index, s) } else this.addMatch(n.index, r) } } addMatch(e, n) { null === this.matches ? this.matches = [e, n] : this.matches.push(e, n) } } function EI(t, e) { const n = t.localNames; if (null !== n) for (let r = 0; r < n.length; r += 2)if (n[r] === e) return n[r + 1]; return null } function SI(t, e, n, r) { return -1 === n ? function MI(t, e) { return 11 & t.type ? zs(t, e) : 4 & t.type ? Vu(t, e) : null }(e, t) : -2 === n ? function II(t, e, n) { return n === Wr ? zs(e, t) : n === mr ? Vu(e, t) : n === On ? U1(e, t) : void 0 }(t, e, r) : Zo(t, t[1], n, e) } function z1(t, e, n, r) { const i = e[19].queries[r]; if (null === i.matches) { const s = t.data, o = n.matches, a = []; for (let l = 0; l < o.length; l += 2) { const u = o[l]; a.push(u < 0 ? null : SI(e, s[u], o[l + 1], n.metadata.read)) } i.matches = a } return i.matches } function Vf(t, e, n, r) { const i = t.queries.getByIndex(n), s = i.matches; if (null !== s) { const o = z1(t, e, i, n); for (let a = 0; a < s.length; a += 2) { const l = s[a]; if (l > 0) r.push(o[a / 2]); else { const u = s[a + 1], c = e[-l]; for (let d = 10; d < c.length; d++) { const f = c[d]; f[17] === f[3] && Vf(f[1], f, u, r) } if (null !== c[9]) { const d = c[9]; for (let f = 0; f < d.length; f++) { const h = d[f]; Vf(h[1], h, u, r) } } } } } return r } function Bu(t) { const e = x(), n = ue(), r = bg(); Yc(r + 1); const i = Y1(n, r); if (t.dirty && pg(e) === (2 == (2 & i.metadata.flags))) { if (null === i.matches) t.reset([]); else { const s = i.crossesNgTemplate ? Vf(n, e, r, []) : z1(n, e, i, r); t.reset(s, US), t.notifyOnChanges() } return !0 } return !1 } function W1(t, e, n) { const r = ue(); r.firstCreatePass && (function G1(t, e, n) { null === t.queries && (t.queries = new Lf), t.queries.track(new Zf(e, n)) }(r, new $1(t, e, n), -1), 2 == (2 & e) && (r.staticViewQueries = !0)), function q1(t, e, n) { const r = new Of(4 == (4 & n)); i_(t, e, r, r.destroy), null === e[19] && (e[19] = new Nf), e[19].queries.push(new Ff(r)) }(r, x(), e) } function Y1(t, e) { return t.queries.getByIndex(e) } function $u(...t) { } const Wf = new ce("Application Initializer"); let qf = (() => { class t { constructor(n) { this.appInits = n, this.resolve = $u, this.reject = $u, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, i) => { this.resolve = r, this.reject = i }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let i = 0; i < this.appInits.length; i++) { const s = this.appInits[i](); if (Su(s)) n.push(s); else if (s2(s)) { const o = new Promise((a, l) => { s.subscribe({ complete: a, error: l }) }); n.push(o) } } Promise.all(n).then(() => { r() }).catch(i => { this.reject(i) }), 0 === n.length && r(), this.initialized = !0 } } return t.\u0275fac = function (n) { return new (n || t)(V(Wf, 8)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const wa = new ce("AppId", { providedIn: "root", factory: function fy() { return `${Gf()}${Gf()}${Gf()}` } }); function Gf() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const hy = new ce("Platform Initializer"), py = new ce("Platform ID", { providedIn: "platform", factory: () => "unknown" }), gy = new ce("appBootstrapListener"); let XI = (() => { class t { log(n) { console.log(n) } warn(n) { console.warn(n) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(); const qr = new ce("LocaleId", { providedIn: "root", factory: () => ID(qr, H.Optional | H.SkipSelf) || function QI() { return "undefined" != typeof $localize && $localize.locale || Au }() }); class JI { constructor(e, n) { this.ngModuleFactory = e, this.componentFactories = n } } let my = (() => { class t { compileModuleSync(n) { return new Af(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { const r = this.compileModuleSync(n), s = Xn(nn(n).declarations).reduce((o, a) => { const l = ut(a); return l && o.push(new If(l)), o }, []); return new JI(r, s) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const tA = (() => Promise.resolve(0))(); function Yf(t) { "undefined" == typeof Zone ? tA.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class ct { constructor({ enableLongStackTrace: e = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new St(!1), this.onMicrotaskEmpty = new St(!1), this.onStable = new St(!1), this.onError = new St(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const i = this; i._nesting = 0, i._outer = i._inner = Zone.current, Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)), e && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)), i.shouldCoalesceEventChangeDetection = !r && n, i.shouldCoalesceRunChangeDetection = r, i.lastRequestAnimationFrameId = -1, i.nativeRequestAnimationFrame = function nA() { let t = we.requestAnimationFrame, e = we.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const r = e[Zone.__symbol__("OriginalDelegate")]; r && (e = r) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function sA(t) { const e = () => { !function iA(t) { t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(we, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, Qf(t), t.isCheckStableRunning = !0, Xf(t), t.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), Qf(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, i, s, o, a) => { try { return _y(t), n.invokeTask(i, s, o, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === s.type || t.shouldCoalesceRunChangeDetection) && e(), yy(t) } }, onInvoke: (n, r, i, s, o, a, l) => { try { return _y(t), n.invoke(i, s, o, a, l) } finally { t.shouldCoalesceRunChangeDetection && e(), yy(t) } }, onHasTask: (n, r, i, s) => { n.hasTask(i, s), r === i && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, Qf(t), Xf(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (n, r, i, s) => (n.handleError(i, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) }(i) } static isInAngularZone() { return "undefined" != typeof Zone && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!ct.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (ct.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(e, n, r) { return this._inner.run(e, n, r) } runTask(e, n, r, i) { const s = this._inner, o = s.scheduleEventTask("NgZoneEvent: " + i, e, rA, $u, $u); try { return s.runTask(o, n, r) } finally { s.cancelTask(o) } } runGuarded(e, n, r) { return this._inner.runGuarded(e, n, r) } runOutsideAngular(e) { return this._outer.run(e) } } const rA = {}; function Xf(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function Qf(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function _y(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function yy(t) { t._nesting--, Xf(t) } class oA { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new St, this.onMicrotaskEmpty = new St, this.onStable = new St, this.onError = new St } run(e, n, r) { return e.apply(n, r) } runGuarded(e, n, r) { return e.apply(n, r) } runOutsideAngular(e) { return e() } runTask(e, n, r, i) { return e.apply(n, r) } } let Kf = (() => { class t { constructor(n) { this._ngZone = n, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { ct.assertNotInAngularZone(), Yf(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Yf(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, i) { let s = -1; r && r > 0 && (s = setTimeout(() => { this._callbacks = this._callbacks.filter(o => o.timeoutId !== s), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: s, updateCb: i }) } whenStable(n, r, i) { if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, i), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(n, r, i) { return [] } } return t.\u0275fac = function (n) { return new (n || t)(V(ct)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(), aA = (() => { class t { constructor() { this._applications = new Map, Jf.addToWindow(this) } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return Jf.findTestabilityInTree(this, n, r) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(); class lA { addToWindow(e) { } findTestabilityInTree(e, n, r) { return null } } let Jf = new lA, xi = null; const wy = new ce("AllowMultipleToken"), vy = new ce("PlatformOnDestroy"); class by { constructor(e, n) { this.name = e, this.token = n } } function Ty(t, e, n = []) { const r = `Platform: ${e}`, i = new ce(r); return (s = []) => { let o = eh(); if (!o || o.injector.get(wy, !1)) { const a = [...n, ...s, { provide: i, useValue: !0 }]; t ? t(a) : function fA(t) { if (xi && !xi.get(wy, !1)) throw new le(400, ""); xi = t; const e = t.get(ky), n = t.get(hy, null); n && n.forEach(r => r()) }(function pA(t = [], e) { return qt.create({ name: e, providers: [{ provide: nf, useValue: "platform" }, { provide: vy, useValue: () => xi = null }, ...t] }) }(a, r)) } return function hA(t) { const e = eh(); if (!e) throw new le(401, ""); return e }() } } function eh() { var t; return null !== (t = null == xi ? void 0 : xi.get(ky)) && void 0 !== t ? t : null } let ky = (() => { class t { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const a = function gA(t, e) { let n; return n = "noop" === t ? new oA : ("zone.js" === t ? void 0 : t) || new ct({ enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !!(null == e ? void 0 : e.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == e ? void 0 : e.ngZoneRunCoalescing) }), n }(r ? r.ngZone : void 0, { ngZoneEventCoalescing: r && r.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: r && r.ngZoneRunCoalescing || !1 }), l = [{ provide: ct, useValue: a }]; return a.run(() => { const u = qt.create({ providers: l, parent: this.injector, name: n.moduleType.name }), c = n.create(u), d = c.injector.get(ea, null); if (!d) throw new le(402, ""); return a.runOutsideAngular(() => { const f = a.onError.subscribe({ next: h => { d.handleError(h) } }); c.onDestroy(() => { nh(this._modules, c), f.unsubscribe() }) }), function mA(t, e, n) { try { const r = n(); return Su(r) ? r.catch(i => { throw e.runOutsideAngular(() => t.handleError(i)), i }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } }(d, a, () => { const f = c.injector.get(qf); return f.runInitializers(), f.donePromise.then(() => (function UM(t) { Bt(t, "Expected localeId to be defined"), "string" == typeof t && (n1 = t.toLowerCase().replace(/_/g, "-")) }(c.injector.get(qr, Au) || Au), this._moduleDoBootstrap(c), c)) }) }) } bootstrapModule(n, r = []) { const i = Dy({}, r); return function cA(t, e, n) { const r = new Af(n); return Promise.resolve(r) }(0, 0, n).then(s => this.bootstrapModuleFactory(s, i)) } _moduleDoBootstrap(n) { const r = n.injector.get(th); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(i => r.bootstrap(i)); else { if (!n.instance.ngDoBootstrap) throw new le(403, ""); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new le(404, ""); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(vy, null); null == n || n(), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (n) { return new (n || t)(V(qt)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(); function Dy(t, e) { return Array.isArray(e) ? e.reduce(Dy, t) : Object.assign(Object.assign({}, t), e) } let th = (() => { class t { constructor(n, r, i, s) { this._zone = n, this._injector = r, this._exceptionHandler = i, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const o = new Ve(l => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { l.next(this._stable), l.complete() }) }), a = new Ve(l => { let u; this._zone.runOutsideAngular(() => { u = this._zone.onStable.subscribe(() => { ct.assertNotInAngularZone(), Yf(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, l.next(!0)) }) }) }); const c = this._zone.onUnstable.subscribe(() => { ct.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { l.next(!1) })) }); return () => { u.unsubscribe(), c.unsubscribe() } }); this.isStable = function os(...t) { const e = $n(t), n = function Ot(t, e) { return "number" == typeof Co(t) ? t.pop() : e }(t, 1 / 0), r = t; return r.length ? 1 === r.length ? Jt(r[0]) : Vt(n)(ye(r, e)) : kt }(o, a.pipe(function Eo(t = {}) { const { connector: e = (() => new gn), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: i = !0 } = t; return s => { let o, a, l, u = 0, c = !1, d = !1; const f = () => { null == a || a.unsubscribe(), a = void 0 }, h = () => { f(), o = l = void 0, c = d = !1 }, p = () => { const m = o; h(), null == m || m.unsubscribe() }; return Be((m, y) => { u++, !d && !c && f(); const v = l = null != l ? l : e(); y.add(() => { u--, 0 === u && !d && !c && (a = hi(p, i)) }), v.subscribe(y), !o && u > 0 && (o = new Hn({ next: w => v.next(w), error: w => { d = !0, f(), a = hi(h, n, w), v.error(w) }, complete: () => { c = !0, f(), a = hi(h, r), v.complete() } }), Jt(m).subscribe(o)) })(s) } }())) } bootstrap(n, r) { if (!this._initStatus.done) throw new le(405, ""); let i; i = n instanceof E1 ? n : this._injector.get(pa).resolveComponentFactory(n), this.componentTypes.push(i.componentType); const s = function dA(t) { return t.isBoundToModule }(i) ? void 0 : this._injector.get(gr), a = i.create(qt.NULL, [], r || i.selector, s), l = a.location.nativeElement, u = a.injector.get(Kf, null), c = u && a.injector.get(aA); return u && c && c.registerApplication(l, u), a.onDestroy(() => { this.detachView(a.hostView), nh(this.components, a), c && c.unregisterApplication(l) }), this._loadComponent(a), a } tick() { if (this._runningTick) throw new le(101, ""); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; nh(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(gy, []).concat(this._bootstrapListeners).forEach(i => i(n)) } ngOnDestroy() { this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return t.\u0275fac = function (n) { return new (n || t)(V(ct), V(qt), V(ea), V(qf)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function nh(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } let xy = !0, rh = (() => { class t { } return t.__NG_ELEMENT_ID__ = wA, t })(); function wA(t) { return function vA(t, e, n) { if (zl(t) && !n) { const r = Ut(t.index, e); return new ga(r, r) } return 47 & t.type ? new ga(e[16], e) : null }(Qe(), x(), 16 == (16 & t)) } const OA = Ty(null, "core", []); let RA = (() => { class t { constructor(n) { } } return t.\u0275fac = function (n) { return new (n || t)(V(th)) }, t.\u0275mod = gi({ type: t }), t.\u0275inj = Fr({}), t })(), Gu = null; function Gr() { return Gu } const ln = new ce("DocumentToken"); let Mi = (() => { class t { historyGo(n) { throw new Error("Not implemented") } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = oe({ token: t, factory: function () { return function ZA() { return V(Ly) }() }, providedIn: "platform" }), t })(); const VA = new ce("Location Initialized"); let Ly = (() => { class t extends Mi { constructor(n) { super(), this._doc = n, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Gr().getBaseHref(this._doc) } onPopState(n) { const r = Gr().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { const r = Gr().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(n) { this.location.pathname = n } pushState(n, r, i) { Zy() ? this._history.pushState(n, r, i) : this.location.hash = i } replaceState(n, r, i) { Zy() ? this._history.replaceState(n, r, i) : this.location.hash = i } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } } return t.\u0275fac = function (n) { return new (n || t)(V(ln)) }, t.\u0275prov = oe({ token: t, factory: function () { return function BA() { return new Ly(V(ln)) }() }, providedIn: "platform" }), t })(); function Zy() { return !!window.history.pushState } function lh(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } function Vy(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } function _r(t) { return t && "?" !== t[0] ? "?" + t : t } let Gs = (() => { class t { historyGo(n) { throw new Error("Not implemented") } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = oe({ token: t, factory: function () { return function jA(t) { const e = V(ln).location; return new By(V(Mi), e && e.origin || "") }() }, providedIn: "root" }), t })(); const uh = new ce("appBaseHref"); let By = (() => { class t extends Gs { constructor(n, r) { if (super(), this._platformLocation = n, this._removeListenerFns = [], null == r && (r = this._platformLocation.getBaseHrefFromDOM()), null == r) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = r } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return lh(this._baseHref, n) } path(n = !1) { const r = this._platformLocation.pathname + _r(this._platformLocation.search), i = this._platformLocation.hash; return i && n ? `${r}${i}` : r } pushState(n, r, i, s) { const o = this.prepareExternalUrl(i + _r(s)); this._platformLocation.pushState(n, r, o) } replaceState(n, r, i, s) { const o = this.prepareExternalUrl(i + _r(s)); this._platformLocation.replaceState(n, r, o) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(n = 0) { var r, i; null === (i = (r = this._platformLocation).historyGo) || void 0 === i || i.call(r, n) } } return t.\u0275fac = function (n) { return new (n || t)(V(Mi), V(uh, 8)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(), HA = (() => { class t extends Gs { constructor(n, r) { super(), this._platformLocation = n, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } path(n = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(n) { const r = lh(this._baseHref, n); return r.length > 0 ? "#" + r : r } pushState(n, r, i, s) { let o = this.prepareExternalUrl(i + _r(s)); 0 == o.length && (o = this._platformLocation.pathname), this._platformLocation.pushState(n, r, o) } replaceState(n, r, i, s) { let o = this.prepareExternalUrl(i + _r(s)); 0 == o.length && (o = this._platformLocation.pathname), this._platformLocation.replaceState(n, r, o) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(n = 0) { var r, i; null === (i = (r = this._platformLocation).historyGo) || void 0 === i || i.call(r, n) } } return t.\u0275fac = function (n) { return new (n || t)(V(Mi), V(uh, 8)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(), ch = (() => { class t { constructor(n, r) { this._subject = new St, this._urlChangeListeners = [], this._platformStrategy = n; const i = this._platformStrategy.getBaseHref(); this._platformLocation = r, this._baseHref = Vy(jy(i)), this._platformStrategy.onPopState(s => { this._subject.emit({ url: this.path(!0), pop: !0, state: s.state, type: s.type }) }) } path(n = !1) { return this.normalize(this._platformStrategy.path(n)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + _r(r)) } normalize(n) { return t.stripTrailingSlash(function $A(t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, jy(n))) } prepareExternalUrl(n) { return n && "/" !== n[0] && (n = "/" + n), this._platformStrategy.prepareExternalUrl(n) } go(n, r = "", i = null) { this._platformStrategy.pushState(i, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + _r(r)), i) } replaceState(n, r = "", i = null) { this._platformStrategy.replaceState(i, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + _r(r)), i) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(n = 0) { var r, i; null === (i = (r = this._platformStrategy).historyGo) || void 0 === i || i.call(r, n) } onUrlChange(n) { this._urlChangeListeners.push(n), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })) } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(i => i(n, r)) } subscribe(n, r, i) { return this._subject.subscribe({ next: n, error: r, complete: i }) } } return t.normalizeQueryParams = _r, t.joinWithSlash = lh, t.stripTrailingSlash = Vy, t.\u0275fac = function (n) { return new (n || t)(V(Gs), V(Mi)) }, t.\u0275prov = oe({ token: t, factory: function () { return function UA() { return new ch(V(Gs), V(Mi)) }() }, providedIn: "root" }), t })(); function jy(t) { return t.replace(/\/index.html$/, "") } let oP = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = gi({ type: t }), t.\u0275inj = Fr({}), t })(); let cP = (() => { class t { } return t.\u0275prov = oe({ token: t, providedIn: "root", factory: () => new dP(V(ln), window) }), t })(); class dP { constructor(e, n) { this.document = e, this.window = n, this.offset = () => [0, 0] } setOffset(e) { this.offset = Array.isArray(e) ? () => e : e } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(e) { this.supportsScrolling() && this.window.scrollTo(e[0], e[1]) } scrollToAnchor(e) { if (!this.supportsScrolling()) return; const n = function fP(t, e) { const n = t.getElementById(e) || t.getElementsByName(e)[0]; if (n) return n; if ("function" == typeof t.createTreeWalker && t.body && (t.body.createShadowRoot || t.body.attachShadow)) { const r = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT); let i = r.currentNode; for (; i;) { const s = i.shadowRoot; if (s) { const o = s.getElementById(e) || s.querySelector(`[name="${e}"]`); if (o) return o } i = r.nextNode() } } return null }(this.document, e); n && (this.scrollToElement(n), n.focus()) } setHistoryScrollRestoration(e) { if (this.supportScrollRestoration()) { const n = this.window.history; n && n.scrollRestoration && (n.scrollRestoration = e) } } scrollToElement(e) { const n = e.getBoundingClientRect(), r = n.left + this.window.pageXOffset, i = n.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(r - s[0], i - s[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const e = tw(this.window.history) || tw(Object.getPrototypeOf(this.window.history)); return !(!e || !e.writable && !e.set) } catch (e) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (e) { return !1 } } } function tw(t) { return Object.getOwnPropertyDescriptor(t, "scrollRestoration") } class Dh extends class pP extends class LA { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function NA(t) { Gu || (Gu = t) }(new Dh) } onAndCancel(e, n, r) { return e.addEventListener(n, r, !1), () => { e.removeEventListener(n, r, !1) } } dispatchEvent(e, n) { e.dispatchEvent(n) } remove(e) { e.parentNode && e.parentNode.removeChild(e) } createElement(e, n) { return (n = n || this.getDefaultDocument()).createElement(e) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(e) { return e.nodeType === Node.ELEMENT_NODE } isShadowRoot(e) { return e instanceof DocumentFragment } getGlobalEventTarget(e, n) { return "window" === n ? window : "document" === n ? e : "body" === n ? e.body : null } getBaseHref(e) { const n = function gP() { return ka = ka || document.querySelector("base"), ka ? ka.getAttribute("href") : null }(); return null == n ? null : function mP(t) { s0 = s0 || document.createElement("a"), s0.setAttribute("href", t); const e = s0.pathname; return "/" === e.charAt(0) ? e : `/${e}` }(n) } resetBaseElement() { ka = null } getUserAgent() { return window.navigator.userAgent } getCookie(e) { return function E3(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const r = n.indexOf("="), [i, s] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (i.trim() === e) return decodeURIComponent(s) } return null }(document.cookie, e) } } let s0, ka = null; const nw = new ce("TRANSITION_ID"), yP = [{ provide: Wf, useFactory: function _P(t, e, n) { return () => { n.get(qf).donePromise.then(() => { const r = Gr(), i = e.querySelectorAll(`style[ng-transition="${t}"]`); for (let s = 0; s < i.length; s++)r.remove(i[s]) }) } }, deps: [nw, ln, qt], multi: !0 }]; class Ch { static init() { !function uA(t) { Jf = t }(new Ch) } addToWindow(e) { we.getAngularTestability = (r, i = !0) => { const s = e.findTestabilityInTree(r, i); if (null == s) throw new Error("Could not find testability for element."); return s }, we.getAllAngularTestabilities = () => e.getAllTestabilities(), we.getAllAngularRootElements = () => e.getAllRootElements(), we.frameworkStabilizers || (we.frameworkStabilizers = []), we.frameworkStabilizers.push(r => { const i = we.getAllAngularTestabilities(); let s = i.length, o = !1; const a = function (l) { o = o || l, s--, 0 == s && r(o) }; i.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(e, n, r) { if (null == n) return null; const i = e.getTestability(n); return null != i ? i : r ? Gr().isShadowRoot(n) ? this.findTestabilityInTree(e, n.host, !0) : this.findTestabilityInTree(e, n.parentElement, !0) : null } } let wP = (() => { class t { build() { return new XMLHttpRequest } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(); const o0 = new ce("EventManagerPlugins"); let a0 = (() => { class t { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(i => i.manager = this), this._plugins = n.slice().reverse() } addEventListener(n, r, i) { return this._findPluginFor(r).addEventListener(n, r, i) } addGlobalEventListener(n, r, i) { return this._findPluginFor(r).addGlobalEventListener(n, r, i) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const i = this._plugins; for (let s = 0; s < i.length; s++) { const o = i[s]; if (o.supports(n)) return this._eventNameToPlugin.set(n, o), o } throw new Error(`No event manager plugin found for event ${n}`) } } return t.\u0275fac = function (n) { return new (n || t)(V(o0), V(ct)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(); class rw { constructor(e) { this._doc = e } addGlobalEventListener(e, n, r) { const i = Gr().getGlobalEventTarget(this._doc, e); if (!i) throw new Error(`Unsupported event target ${i} for event ${n}`); return this.addEventListener(i, n, r) } } let iw = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(n) { const r = new Set; n.forEach(i => { this._stylesSet.has(i) || (this._stylesSet.add(i), r.add(i)) }), this.onStylesAdded(r) } onStylesAdded(n) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(), Da = (() => { class t extends iw { constructor(n) { super(), this._doc = n, this._hostNodes = new Map, this._hostNodes.set(n.head, []) } _addStylesToHost(n, r, i) { n.forEach(s => { const o = this._doc.createElement("style"); o.textContent = s, i.push(r.appendChild(o)) }) } addHost(n) { const r = []; this._addStylesToHost(this._stylesSet, n, r), this._hostNodes.set(n, r) } removeHost(n) { const r = this._hostNodes.get(n); r && r.forEach(sw), this._hostNodes.delete(n) } onStylesAdded(n) { this._hostNodes.forEach((r, i) => { this._addStylesToHost(n, i, r) }) } ngOnDestroy() { this._hostNodes.forEach(n => n.forEach(sw)) } } return t.\u0275fac = function (n) { return new (n || t)(V(ln)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(); function sw(t) { Gr().remove(t) } const xh = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Eh = /%COMP%/g; function l0(t, e, n) { for (let r = 0; r < e.length; r++) { let i = e[r]; Array.isArray(i) ? l0(t, i, n) : (i = i.replace(Eh, t), n.push(i)) } return n } function lw(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let Mh = (() => { class t { constructor(n, r, i) { this.eventManager = n, this.sharedStylesHost = r, this.appId = i, this.rendererByCompId = new Map, this.defaultRenderer = new Sh(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; switch (r.encapsulation) { case zn.Emulated: { let i = this.rendererByCompId.get(r.id); return i || (i = new CP(this.eventManager, this.sharedStylesHost, r, this.appId), this.rendererByCompId.set(r.id, i)), i.applyToHost(n), i } case 1: case zn.ShadowDom: return new xP(this.eventManager, this.sharedStylesHost, n, r); default: if (!this.rendererByCompId.has(r.id)) { const i = l0(r.id, r.styles, []); this.sharedStylesHost.addStyles(i), this.rendererByCompId.set(r.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (n) { return new (n || t)(V(a0), V(Da), V(wa)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(); class Sh { constructor(e) { this.eventManager = e, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(e, n) { return n ? document.createElementNS(xh[n] || n, e) : document.createElement(e) } createComment(e) { return document.createComment(e) } createText(e) { return document.createTextNode(e) } appendChild(e, n) { e.appendChild(n) } insertBefore(e, n, r) { e && e.insertBefore(n, r) } removeChild(e, n) { e && e.removeChild(n) } selectRootElement(e, n) { let r = "string" == typeof e ? document.querySelector(e) : e; if (!r) throw new Error(`The selector "${e}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(e) { return e.parentNode } nextSibling(e) { return e.nextSibling } setAttribute(e, n, r, i) { if (i) { n = i + ":" + n; const s = xh[i]; s ? e.setAttributeNS(s, n, r) : e.setAttribute(n, r) } else e.setAttribute(n, r) } removeAttribute(e, n, r) { if (r) { const i = xh[r]; i ? e.removeAttributeNS(i, n) : e.removeAttribute(`${r}:${n}`) } else e.removeAttribute(n) } addClass(e, n) { e.classList.add(n) } removeClass(e, n) { e.classList.remove(n) } setStyle(e, n, r, i) { i & (zt.DashCase | zt.Important) ? e.style.setProperty(n, r, i & zt.Important ? "important" : "") : e.style[n] = r } removeStyle(e, n, r) { r & zt.DashCase ? e.style.removeProperty(n) : e.style[n] = "" } setProperty(e, n, r) { e[n] = r } setValue(e, n) { e.nodeValue = n } listen(e, n, r) { return "string" == typeof e ? this.eventManager.addGlobalEventListener(e, n, lw(r)) : this.eventManager.addEventListener(e, n, lw(r)) } } class CP extends Sh { constructor(e, n, r, i) { super(e), this.component = r; const s = l0(i + "-" + r.id, r.styles, []); n.addStyles(s), this.contentAttr = function TP(t) { return "_ngcontent-%COMP%".replace(Eh, t) }(i + "-" + r.id), this.hostAttr = function kP(t) { return "_nghost-%COMP%".replace(Eh, t) }(i + "-" + r.id) } applyToHost(e) { super.setAttribute(e, this.hostAttr, "") } createElement(e, n) { const r = super.createElement(e, n); return super.setAttribute(r, this.contentAttr, ""), r } } class xP extends Sh { constructor(e, n, r, i) { super(e), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const s = l0(i.id, i.styles, []); for (let o = 0; o < s.length; o++) { const a = document.createElement("style"); a.textContent = s[o], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(e) { return e === this.hostEl ? this.shadowRoot : e } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(e, n) { return super.appendChild(this.nodeOrShadowRoot(e), n) } insertBefore(e, n, r) { return super.insertBefore(this.nodeOrShadowRoot(e), n, r) } removeChild(e, n) { return super.removeChild(this.nodeOrShadowRoot(e), n) } parentNode(e) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e))) } } let EP = (() => { class t extends rw { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, i) { return n.addEventListener(r, i, !1), () => this.removeEventListener(n, r, i) } removeEventListener(n, r, i) { return n.removeEventListener(r, i) } } return t.\u0275fac = function (n) { return new (n || t)(V(ln)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(); const cw = ["alt", "control", "meta", "shift"], SP = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, dw = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, IP = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let AP = (() => { class t extends rw { constructor(n) { super(n) } supports(n) { return null != t.parseEventName(n) } addEventListener(n, r, i) { const s = t.parseEventName(r), o = t.eventCallback(s.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Gr().onAndCancel(n, s.domEventName, o)) } static parseEventName(n) { const r = n.toLowerCase().split("."), i = r.shift(); if (0 === r.length || "keydown" !== i && "keyup" !== i) return null; const s = t._normalizeKey(r.pop()); let o = ""; if (cw.forEach(l => { const u = r.indexOf(l); u > -1 && (r.splice(u, 1), o += l + ".") }), o += s, 0 != r.length || 0 === s.length) return null; const a = {}; return a.domEventName = i, a.fullKey = o, a } static getEventFullKey(n) { let r = "", i = function PP(t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && dw.hasOwnProperty(e) && (e = dw[e])) } return SP[e] || e }(n); return i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), cw.forEach(s => { s != i && IP[s](n) && (r += s + ".") }), r += i, r } static eventCallback(n, r, i) { return s => { t.getEventFullKey(s) === n && i.runGuarded(() => r(s)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return t.\u0275fac = function (n) { return new (n || t)(V(ln)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(); const NP = Ty(OA, "browser", [{ provide: py, useValue: "browser" }, { provide: hy, useValue: function OP() { Dh.makeCurrent(), Ch.init() }, multi: !0 }, { provide: ln, useFactory: function FP() { return function Pk(t) { Bc = t }(document), document }, deps: [] }]), LP = [{ provide: nf, useValue: "root" }, { provide: ea, useFactory: function RP() { return new ea }, deps: [] }, { provide: o0, useClass: EP, multi: !0, deps: [ln, ct, py] }, { provide: o0, useClass: AP, multi: !0, deps: [ln] }, { provide: Mh, useClass: Mh, deps: [a0, Da, wa] }, { provide: S1, useExisting: Mh }, { provide: iw, useExisting: Da }, { provide: Da, useClass: Da, deps: [ln] }, { provide: Kf, useClass: Kf, deps: [ct] }, { provide: a0, useClass: a0, deps: [o0, ct] }, { provide: class hP { }, useClass: wP, deps: [] }]; let ZP = (() => { class t { constructor(n) { if (n) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(n) { return { ngModule: t, providers: [{ provide: wa, useValue: n.appId }, { provide: nw, useExisting: wa }, yP] } } } return t.\u0275fac = function (n) { return new (n || t)(V(t, 12)) }, t.\u0275mod = gi({ type: t }), t.\u0275inj = Fr({ providers: LP, imports: [oP, RA] }), t })(); function K(...t) { return ye(t, $n(t)) } "undefined" != typeof window && window; class Nn extends gn { constructor(e) { super(), this._value = e } get value() { return this.getValue() } _subscribe(e) { const n = super._subscribe(e); return !n.closed && e.next(this._value), n } getValue() { const { hasError: e, thrownError: n, _value: r } = this; if (e) throw n; return this._throwIfClosed(), r } next(e) { super.next(this._value = e) } } const { isArray: YP } = Array, { getPrototypeOf: XP, prototype: QP, keys: KP } = Object; const { isArray: tO } = Array; function sO(...t) { const e = $n(t), n = function xc(t) { return ge(Co(t)) ? t.pop() : void 0 }(t), { args: r, keys: i } = function JP(t) { if (1 === t.length) { const e = t[0]; if (YP(e)) return { args: e, keys: null }; if (function eO(t) { return t && "object" == typeof t && XP(t) === QP }(e)) { const n = KP(e); return { args: n.map(r => e[r]), keys: n } } } return { args: t, keys: null } }(t); if (0 === r.length) return ye([], e); const s = new Ve(function oO(t, e, n = Un) { return r => { pw(e, () => { const { length: i } = t, s = new Array(i); let o = i, a = i; for (let l = 0; l < i; l++)pw(e, () => { const u = ye(t[l], e); let c = !1; u.subscribe(Xe(r, d => { s[l] = d, c || (c = !0, a--), a || r.next(n(s.slice())) }, () => { --o || r.complete() })) }, r) }, r) } }(r, e, i ? o => function iO(t, e) { return t.reduce((n, r, i) => (n[r] = e[i], n), {}) }(i, o) : Un)); return n ? s.pipe(function rO(t) { return X(e => function nO(t, e) { return tO(e) ? t(...e) : t(e) }(t, e)) }(n)) : s } function pw(t, e, n) { t ? en(n, t, e) : e() } function u0(t, e) { const n = ge(t) ? t : () => t, r = i => i.error(n()); return new Ve(e ? i => e.schedule(r, 0, i) : r) } const c0 = rt(t => function () { t(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function Ah(...t) { return function aO() { return Vt(1) }()(ye(t, $n(t))) } function gw(t) { return new Ve(e => { Jt(t()).subscribe(e) }) } function mw() { return Be((t, e) => { let n = null; t._refCount++; const r = Xe(e, void 0, void 0, void 0, () => { if (!t || t._refCount <= 0 || 0 < --t._refCount) return void (n = null); const i = t._connection, s = n; n = null, i && (!s || i === s) && i.unsubscribe(), e.unsubscribe() }); t.subscribe(r), r.closed || (n = t.connect()) }) } class lO extends Ve { constructor(e, n) { super(), this.source = e, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, bl(e) && (this.lift = e.lift) } _subscribe(e) { return this.getSubject().subscribe(e) } getSubject() { const e = this._subject; return (!e || e.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: e } = this; this._subject = this._connection = null, null == e || e.unsubscribe() } connect() { let e = this._connection; if (!e) { e = this._connection = new _e; const n = this.getSubject(); e.add(this.source.subscribe(Xe(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), e.closed && (this._connection = null, e = _e.EMPTY) } return e } refCount() { return mw()(this) } } function Si(t, e) { return Be((n, r) => { let i = null, s = 0, o = !1; const a = () => o && !i && r.complete(); n.subscribe(Xe(r, l => { null == i || i.unsubscribe(); let u = 0; const c = s++; Jt(t(l, c)).subscribe(i = Xe(r, d => r.next(e ? e(l, d, c, u++) : d), () => { i = null, a() })) }, () => { o = !0, a() })) }) } function Ph(t) { return t <= 0 ? () => kt : Be((e, n) => { let r = 0; e.subscribe(Xe(n, i => { ++r <= t && (n.next(i), t <= r && n.complete()) })) }) } function cO(t, e, n, r, i) { return (s, o) => { let a = n, l = e, u = 0; s.subscribe(Xe(o, c => { const d = u++; l = a ? t(l, c, d) : (a = !0, c), r && o.next(l) }, i && (() => { a && o.next(l), o.complete() }))) } } function _w(t, e) { return Be(cO(t, e, arguments.length >= 2, !0)) } function Ys(t, e) { return Be((n, r) => { let i = 0; n.subscribe(Xe(r, s => t.call(e, s, i++) && r.next(s))) }) } function Xr(t) { return Be((e, n) => { let s, r = null, i = !1; r = e.subscribe(Xe(n, void 0, void 0, o => { s = Jt(t(o, Xr(t)(e))), r ? (r.unsubscribe(), r = null, s.subscribe(n)) : i = !0 })), i && (r.unsubscribe(), r = null, s.subscribe(n)) }) } function Ca(t, e) { return ge(e) ? Pe(t, e, 1) : Pe(t, 1) } function Oh(t) { return t <= 0 ? () => kt : Be((e, n) => { let r = []; e.subscribe(Xe(n, i => { r.push(i), t < r.length && r.shift() }, () => { for (const i of r) n.next(i); n.complete() }, void 0, () => { r = null })) }) } function yw(t = dO) { return Be((e, n) => { let r = !1; e.subscribe(Xe(n, i => { r = !0, n.next(i) }, () => r ? n.complete() : n.error(t()))) }) } function dO() { return new c0 } function ww(t) { return Be((e, n) => { let r = !1; e.subscribe(Xe(n, i => { r = !0, n.next(i) }, () => { r || n.next(t), n.complete() })) }) } function Xs(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? Ys((i, s) => t(i, s, r)) : Un, Ph(1), n ? ww(e) : yw(() => new c0)) } function Gt(t, e, n) { const r = ge(t) || e || n ? { next: t, error: e, complete: n } : t; return r ? Be((i, s) => { var o; null === (o = r.subscribe) || void 0 === o || o.call(r); let a = !0; i.subscribe(Xe(s, l => { var u; null === (u = r.next) || void 0 === u || u.call(r, l), s.next(l) }, () => { var l; a = !1, null === (l = r.complete) || void 0 === l || l.call(r), s.complete() }, l => { var u; a = !1, null === (u = r.error) || void 0 === u || u.call(r, l), s.error(l) }, () => { var l, u; a && (null === (l = r.unsubscribe) || void 0 === l || l.call(r)), null === (u = r.finalize) || void 0 === u || u.call(r) })) }) : Un } class wr { constructor(e, n) { this.id = e, this.url = n } } class Rh extends wr { constructor(e, n, r = "imperative", i = null) { super(e, n), this.navigationTrigger = r, this.restoredState = i } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class xa extends wr { constructor(e, n, r) { super(e, n), this.urlAfterRedirects = r } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class vw extends wr { constructor(e, n, r) { super(e, n), this.reason = r } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class pO extends wr { constructor(e, n, r) { super(e, n), this.error = r } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class gO extends wr { constructor(e, n, r, i) { super(e, n), this.urlAfterRedirects = r, this.state = i } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class mO extends wr { constructor(e, n, r, i) { super(e, n), this.urlAfterRedirects = r, this.state = i } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class _O extends wr { constructor(e, n, r, i, s) { super(e, n), this.urlAfterRedirects = r, this.state = i, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class yO extends wr { constructor(e, n, r, i) { super(e, n), this.urlAfterRedirects = r, this.state = i } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class wO extends wr { constructor(e, n, r, i) { super(e, n), this.urlAfterRedirects = r, this.state = i } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class bw { constructor(e) { this.route = e } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Tw { constructor(e) { this.route = e } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class vO { constructor(e) { this.snapshot = e } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class bO { constructor(e) { this.snapshot = e } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class TO { constructor(e) { this.snapshot = e } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class kO { constructor(e) { this.snapshot = e } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class kw { constructor(e, n, r) { this.routerEvent = e, this.position = n, this.anchor = r } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const ee = "primary"; class DO { constructor(e) { this.params = e || {} } has(e) { return Object.prototype.hasOwnProperty.call(this.params, e) } get(e) { if (this.has(e)) { const n = this.params[e]; return Array.isArray(n) ? n[0] : n } return null } getAll(e) { if (this.has(e)) { const n = this.params[e]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } } function Qs(t) { return new DO(t) } const Dw = "ngNavigationCancelingError"; function Fh(t) { const e = Error("NavigationCancelingError: " + t); return e[Dw] = !0, e } function xO(t, e, n) { const r = n.path.split("/"); if (r.length > t.length || "full" === n.pathMatch && (e.hasChildren() || r.length < t.length)) return null; const i = {}; for (let s = 0; s < r.length; s++) { const o = r[s], a = t[s]; if (o.startsWith(":")) i[o.substring(1)] = a; else if (o !== a.path) return null } return { consumed: t.slice(0, r.length), posParams: i } } function tr(t, e) { const n = t ? Object.keys(t) : void 0, r = e ? Object.keys(e) : void 0; if (!n || !r || n.length != r.length) return !1; let i; for (let s = 0; s < n.length; s++)if (i = n[s], !Cw(t[i], e[i])) return !1; return !0 } function Cw(t, e) { if (Array.isArray(t) && Array.isArray(e)) { if (t.length !== e.length) return !1; const n = [...t].sort(), r = [...e].sort(); return n.every((i, s) => r[s] === i) } return t === e } function xw(t) { return Array.prototype.concat.apply([], t) } function Ew(t) { return t.length > 0 ? t[t.length - 1] : null } function dt(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function nr(t) { return s2(t) ? t : Su(t) ? ye(Promise.resolve(t)) : K(t) } const SO = { exact: function Iw(t, e, n) { if (!Ai(t.segments, e.segments) || !d0(t.segments, e.segments, n) || t.numberOfChildren !== e.numberOfChildren) return !1; for (const r in e.children) if (!t.children[r] || !Iw(t.children[r], e.children[r], n)) return !1; return !0 }, subset: Aw }, Mw = { exact: function IO(t, e) { return tr(t, e) }, subset: function AO(t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => Cw(t[n], e[n])) }, ignored: () => !0 }; function Sw(t, e, n) { return SO[n.paths](t.root, e.root, n.matrixParams) && Mw[n.queryParams](t.queryParams, e.queryParams) && !("exact" === n.fragment && t.fragment !== e.fragment) } function Aw(t, e, n) { return Pw(t, e, e.segments, n) } function Pw(t, e, n, r) { if (t.segments.length > n.length) { const i = t.segments.slice(0, n.length); return !(!Ai(i, n) || e.hasChildren() || !d0(i, n, r)) } if (t.segments.length === n.length) { if (!Ai(t.segments, n) || !d0(t.segments, n, r)) return !1; for (const i in e.children) if (!t.children[i] || !Aw(t.children[i], e.children[i], r)) return !1; return !0 } { const i = n.slice(0, t.segments.length), s = n.slice(t.segments.length); return !!(Ai(t.segments, i) && d0(t.segments, i, r) && t.children[ee]) && Pw(t.children[ee], e, s, r) } } function d0(t, e, n) { return e.every((r, i) => Mw[n](t[i].parameters, r.parameters)) } class Ii { constructor(e, n, r) { this.root = e, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Qs(this.queryParams)), this._queryParamMap } toString() { return RO.serialize(this) } } class ie { constructor(e, n) { this.segments = e, this.children = n, this.parent = null, dt(n, (r, i) => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return f0(this) } } class Ea { constructor(e, n) { this.path = e, this.parameters = n } get parameterMap() { return this._parameterMap || (this._parameterMap = Qs(this.parameters)), this._parameterMap } toString() { return Lw(this) } } function Ai(t, e) { return t.length === e.length && t.every((n, r) => n.path === e[r].path) } class Ow { } class Rw { parse(e) { const n = new UO(e); return new Ii(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(e) { const n = `/${Ma(e.root, !0)}`, r = function LO(t) { const e = Object.keys(t).map(n => { const r = t[n]; return Array.isArray(r) ? r.map(i => `${h0(n)}=${h0(i)}`).join("&") : `${h0(n)}=${h0(r)}` }).filter(n => !!n); return e.length ? `?${e.join("&")}` : "" }(e.queryParams); return `${n}${r}${"string" == typeof e.fragment ? `#${function FO(t) { return encodeURI(t) }(e.fragment)}` : ""}` } } const RO = new Rw; function f0(t) { return t.segments.map(e => Lw(e)).join("/") } function Ma(t, e) { if (!t.hasChildren()) return f0(t); if (e) { const n = t.children[ee] ? Ma(t.children[ee], !1) : "", r = []; return dt(t.children, (i, s) => { s !== ee && r.push(`${s}:${Ma(i, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = function OO(t, e) { let n = []; return dt(t.children, (r, i) => { i === ee && (n = n.concat(e(r, i))) }), dt(t.children, (r, i) => { i !== ee && (n = n.concat(e(r, i))) }), n }(t, (r, i) => i === ee ? [Ma(t.children[ee], !1)] : [`${i}:${Ma(r, !1)}`]); return 1 === Object.keys(t.children).length && null != t.children[ee] ? `${f0(t)}/${n[0]}` : `${f0(t)}/(${n.join("//")})` } } function Fw(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function h0(t) { return Fw(t).replace(/%3B/gi, ";") } function Nh(t) { return Fw(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function p0(t) { return decodeURIComponent(t) } function Nw(t) { return p0(t.replace(/\+/g, "%20")) } function Lw(t) { return `${Nh(t.path)}${function NO(t) { return Object.keys(t).map(e => `;${Nh(e)}=${Nh(t[e])}`).join("") }(t.parameters)}` } const ZO = /^[^\/()?;=#]+/; function g0(t) { const e = t.match(ZO); return e ? e[0] : "" } const VO = /^[^=?&#]+/, jO = /^[^&#]+/; class UO { constructor(e) { this.url = e, this.remaining = e } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new ie([], {}) : new ie([], this.parseChildren()) } parseQueryParams() { const e = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(e) } while (this.consumeOptional("&")); return e } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const e = []; for (this.peekStartsWith("(") || e.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), e.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (e.length > 0 || Object.keys(n).length > 0) && (r[ee] = new ie(e, n)), r } parseSegment() { const e = g0(this.remaining); if ("" === e && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(e), new Ea(p0(e), this.parseMatrixParams()) } parseMatrixParams() { const e = {}; for (; this.consumeOptional(";");)this.parseParam(e); return e } parseParam(e) { const n = g0(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const i = g0(this.remaining); i && (r = i, this.capture(r)) } e[p0(n)] = p0(r) } parseQueryParam(e) { const n = function BO(t) { const e = t.match(VO); return e ? e[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const o = function HO(t) { const e = t.match(jO); return e ? e[0] : "" }(this.remaining); o && (r = o, this.capture(r)) } const i = Nw(n), s = Nw(r); if (e.hasOwnProperty(i)) { let o = e[i]; Array.isArray(o) || (o = [o], e[i] = o), o.push(s) } else e[i] = s } parseParens(e) { const n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = g0(this.remaining), i = this.remaining[r.length]; if ("/" !== i && ")" !== i && ";" !== i) throw new Error(`Cannot parse url '${this.url}'`); let s; r.indexOf(":") > -1 ? (s = r.substr(0, r.indexOf(":")), this.capture(s), this.capture(":")) : e && (s = ee); const o = this.parseChildren(); n[s] = 1 === Object.keys(o).length ? o[ee] : new ie([], o), this.consumeOptional("//") } return n } peekStartsWith(e) { return this.remaining.startsWith(e) } consumeOptional(e) { return !!this.peekStartsWith(e) && (this.remaining = this.remaining.substring(e.length), !0) } capture(e) { if (!this.consumeOptional(e)) throw new Error(`Expected "${e}".`) } } class Zw { constructor(e) { this._root = e } get root() { return this._root.value } parent(e) { const n = this.pathFromRoot(e); return n.length > 1 ? n[n.length - 2] : null } children(e) { const n = Lh(e, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(e) { const n = Lh(e, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(e) { const n = Zh(e, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(i => i.value).filter(i => i !== e) } pathFromRoot(e) { return Zh(e, this._root).map(n => n.value) } } function Lh(t, e) { if (t === e.value) return e; for (const n of e.children) { const r = Lh(t, n); if (r) return r } return null } function Zh(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const r = Zh(t, n); if (r.length) return r.unshift(e), r } return [] } class vr { constructor(e, n) { this.value = e, this.children = n } toString() { return `TreeNode(${this.value})` } } function Ks(t) { const e = {}; return t && t.children.forEach(n => e[n.value.outlet] = n), e } class Vw extends Zw { constructor(e, n) { super(e), this.snapshot = n, Vh(this, e) } toString() { return this.snapshot.toString() } } function Bw(t, e) { const n = function $O(t, e) { const o = new m0([], {}, {}, "", {}, ee, e, null, t.root, -1, {}); return new Hw("", new vr(o, [])) }(t, e), r = new Nn([new Ea("", {})]), i = new Nn({}), s = new Nn({}), o = new Nn({}), a = new Nn(""), l = new Js(r, i, o, a, s, ee, e, n.root); return l.snapshot = n.root, new Vw(new vr(l, []), n) } class Js { constructor(e, n, r, i, s, o, a, l) { this.url = e, this.params = n, this.queryParams = r, this.fragment = i, this.data = s, this.outlet = o, this.component = a, this._futureSnapshot = l } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(X(e => Qs(e)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(X(e => Qs(e)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function jw(t, e = "emptyOnly") { const n = t.pathFromRoot; let r = 0; if ("always" !== e) for (r = n.length - 1; r >= 1;) { const i = n[r], s = n[r - 1]; if (i.routeConfig && "" === i.routeConfig.path) r--; else { if (s.component) break; r-- } } return function zO(t) { return t.reduce((e, n) => ({ params: Object.assign(Object.assign({}, e.params), n.params), data: Object.assign(Object.assign({}, e.data), n.data), resolve: Object.assign(Object.assign({}, e.resolve), n._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class m0 { constructor(e, n, r, i, s, o, a, l, u, c, d) { this.url = e, this.params = n, this.queryParams = r, this.fragment = i, this.data = s, this.outlet = o, this.component = a, this.routeConfig = l, this._urlSegment = u, this._lastPathIndex = c, this._resolve = d } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Qs(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Qs(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Hw extends Zw { constructor(e, n) { super(n), this.url = e, Vh(this, n) } toString() { return Uw(this._root) } } function Vh(t, e) { e.value._routerState = t, e.children.forEach(n => Vh(t, n)) } function Uw(t) { const e = t.children.length > 0 ? ` { ${t.children.map(Uw).join(", ")} } ` : ""; return `${t.value}${e}` } function Bh(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, tr(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), tr(e.params, n.params) || t.params.next(n.params), function EO(t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!tr(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), tr(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function jh(t, e) { const n = tr(t.params, e.params) && function PO(t, e) { return Ai(t, e) && t.every((n, r) => tr(n.parameters, e[r].parameters)) }(t.url, e.url); return n && !(!t.parent != !e.parent) && (!t.parent || jh(t.parent, e.parent)) } function Sa(t, e, n) { if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = e.value; const i = function qO(t, e, n) { return e.children.map(r => { for (const i of n.children) if (t.shouldReuseRoute(r.value, i.value.snapshot)) return Sa(t, r, i); return Sa(t, r) }) }(t, e, n); return new vr(r, i) } { if (t.shouldAttach(e.value)) { const s = t.retrieve(e.value); if (null !== s) { const o = s.route; return o.value._futureSnapshot = e.value, o.children = e.children.map(a => Sa(t, a)), o } } const r = function GO(t) { return new Js(new Nn(t.url), new Nn(t.params), new Nn(t.queryParams), new Nn(t.fragment), new Nn(t.data), t.outlet, t.component, t) }(e.value), i = e.children.map(s => Sa(t, s)); return new vr(r, i) } } function _0(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function Ia(t) { return "object" == typeof t && null != t && t.outlets } function Hh(t, e, n, r, i) { let s = {}; if (r && dt(r, (a, l) => { s[l] = Array.isArray(a) ? a.map(u => `${u}`) : `${a}` }), t === e) return new Ii(n, s, i); const o = $w(t, e, n); return new Ii(o, s, i) } function $w(t, e, n) { const r = {}; return dt(t.children, (i, s) => { r[s] = i === e ? n : $w(i, e, n) }), new ie(t.segments, r) } class zw { constructor(e, n, r) { if (this.isAbsolute = e, this.numberOfDoubleDots = n, this.commands = r, e && r.length > 0 && _0(r[0])) throw new Error("Root segment cannot have matrix parameters"); const i = r.find(Ia); if (i && i !== Ew(r)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Uh { constructor(e, n, r) { this.segmentGroup = e, this.processChildren = n, this.index = r } } function Ww(t, e, n) { if (t || (t = new ie([], {})), 0 === t.segments.length && t.hasChildren()) return y0(t, e, n); const r = function eR(t, e, n) { let r = 0, i = e; const s = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; i < t.segments.length;) { if (r >= n.length) return s; const o = t.segments[i], a = n[r]; if (Ia(a)) break; const l = `${a}`, u = r < n.length - 1 ? n[r + 1] : null; if (i > 0 && void 0 === l) break; if (l && u && "object" == typeof u && void 0 === u.outlets) { if (!Gw(l, u, o)) return s; r += 2 } else { if (!Gw(l, {}, o)) return s; r++ } i++ } return { match: !0, pathIndex: i, commandIndex: r } }(t, e, n), i = n.slice(r.commandIndex); if (r.match && r.pathIndex < t.segments.length) { const s = new ie(t.segments.slice(0, r.pathIndex), {}); return s.children[ee] = new ie(t.segments.slice(r.pathIndex), t.children), y0(s, 0, i) } return r.match && 0 === i.length ? new ie(t.segments, {}) : r.match && !t.hasChildren() ? $h(t, e, n) : r.match ? y0(t, 0, i) : $h(t, e, n) } function y0(t, e, n) { if (0 === n.length) return new ie(t.segments, {}); { const r = function JO(t) { return Ia(t[0]) ? t[0].outlets : { [ee]: t } }(n), i = {}; return dt(r, (s, o) => { "string" == typeof s && (s = [s]), null !== s && (i[o] = Ww(t.children[o], e, s)) }), dt(t.children, (s, o) => { void 0 === r[o] && (i[o] = s) }), new ie(t.segments, i) } } function $h(t, e, n) { const r = t.segments.slice(0, e); let i = 0; for (; i < n.length;) { const s = n[i]; if (Ia(s)) { const l = tR(s.outlets); return new ie(r, l) } if (0 === i && _0(n[0])) { r.push(new Ea(t.segments[e].path, qw(n[0]))), i++; continue } const o = Ia(s) ? s.outlets[ee] : `${s}`, a = i < n.length - 1 ? n[i + 1] : null; o && a && _0(a) ? (r.push(new Ea(o, qw(a))), i += 2) : (r.push(new Ea(o, {})), i++) } return new ie(r, {}) } function tR(t) { const e = {}; return dt(t, (n, r) => { "string" == typeof n && (n = [n]), null !== n && (e[r] = $h(new ie([], {}), 0, n)) }), e } function qw(t) { const e = {}; return dt(t, (n, r) => e[r] = `${n}`), e } function Gw(t, e, n) { return t == n.path && tr(e, n.parameters) } class rR { constructor(e, n, r, i) { this.routeReuseStrategy = e, this.futureState = n, this.currState = r, this.forwardEvent = i } activate(e) { const n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, e), Bh(this.futureState.root), this.activateChildRoutes(n, r, e) } deactivateChildRoutes(e, n, r) { const i = Ks(n); e.children.forEach(s => { const o = s.value.outlet; this.deactivateRoutes(s, i[o], r), delete i[o] }), dt(i, (s, o) => { this.deactivateRouteAndItsChildren(s, r) }) } deactivateRoutes(e, n, r) { const i = e.value, s = n ? n.value : null; if (i === s) if (i.component) { const o = r.getContext(i.outlet); o && this.deactivateChildRoutes(e, n, o.children) } else this.deactivateChildRoutes(e, n, r); else s && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(e, n) { e.value.component && this.routeReuseStrategy.shouldDetach(e.value.snapshot) ? this.detachAndStoreRouteSubtree(e, n) : this.deactivateRouteAndOutlet(e, n) } detachAndStoreRouteSubtree(e, n) { const r = n.getContext(e.value.outlet), i = r && e.value.component ? r.children : n, s = Ks(e); for (const o of Object.keys(s)) this.deactivateRouteAndItsChildren(s[o], i); if (r && r.outlet) { const o = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(e.value.snapshot, { componentRef: o, route: e, contexts: a }) } } deactivateRouteAndOutlet(e, n) { const r = n.getContext(e.value.outlet), i = r && e.value.component ? r.children : n, s = Ks(e); for (const o of Object.keys(s)) this.deactivateRouteAndItsChildren(s[o], i); r && r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated(), r.attachRef = null, r.resolver = null, r.route = null) } activateChildRoutes(e, n, r) { const i = Ks(n); e.children.forEach(s => { this.activateRoutes(s, i[s.value.outlet], r), this.forwardEvent(new kO(s.value.snapshot)) }), e.children.length && this.forwardEvent(new bO(e.value.snapshot)) } activateRoutes(e, n, r) { const i = e.value, s = n ? n.value : null; if (Bh(i), i === s) if (i.component) { const o = r.getOrCreateContext(i.outlet); this.activateChildRoutes(e, n, o.children) } else this.activateChildRoutes(e, n, r); else if (i.component) { const o = r.getOrCreateContext(i.outlet); if (this.routeReuseStrategy.shouldAttach(i.snapshot)) { const a = this.routeReuseStrategy.retrieve(i.snapshot); this.routeReuseStrategy.store(i.snapshot, null), o.children.onOutletReAttached(a.contexts), o.attachRef = a.componentRef, o.route = a.route.value, o.outlet && o.outlet.attach(a.componentRef, a.route.value), Bh(a.route.value), this.activateChildRoutes(e, null, o.children) } else { const a = function iR(t) { for (let e = t.parent; e; e = e.parent) { const n = e.routeConfig; if (n && n._loadedConfig) return n._loadedConfig; if (n && n.component) return null } return null }(i.snapshot), l = a ? a.module.componentFactoryResolver : null; o.attachRef = null, o.route = i, o.resolver = l, o.outlet && o.outlet.activateWith(i, l), this.activateChildRoutes(e, null, o.children) } } else this.activateChildRoutes(e, null, r) } } class zh { constructor(e, n) { this.routes = e, this.module = n } } function Qr(t) { return "function" == typeof t } function Pi(t) { return t instanceof Ii } const Aa = Symbol("INITIAL_VALUE"); function Pa() { return Si(t => sO(t.map(e => e.pipe(Ph(1), function uO(...t) { const e = $n(t); return Be((n, r) => { (e ? Ah(t, n, e) : Ah(t, n)).subscribe(r) }) }(Aa)))).pipe(_w((e, n) => { let r = !1; return n.reduce((i, s, o) => i !== Aa ? i : (s === Aa && (r = !0), r || !1 !== s && o !== n.length - 1 && !Pi(s) ? i : s), e) }, Aa), Ys(e => e !== Aa), X(e => Pi(e) ? e : !0 === e), Ph(1))) } class cR { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Oa, this.attachRef = null } } class Oa { constructor() { this.contexts = new Map } onChildOutletCreated(e, n) { const r = this.getOrCreateContext(e); r.outlet = n, this.contexts.set(e, r) } onChildOutletDestroyed(e) { const n = this.getContext(e); n && (n.outlet = null, n.attachRef = null) } onOutletDeactivated() { const e = this.contexts; return this.contexts = new Map, e } onOutletReAttached(e) { this.contexts = e } getOrCreateContext(e) { let n = this.getContext(e); return n || (n = new cR, this.contexts.set(e, n)), n } getContext(e) { return this.contexts.get(e) || null } } let Yw = (() => { class t { constructor(n, r, i, s, o) { this.parentContexts = n, this.location = r, this.resolver = i, this.changeDetector = o, this.activated = null, this._activatedRoute = null, this.activateEvents = new St, this.deactivateEvents = new St, this.attachEvents = new St, this.detachEvents = new St, this.name = s || ee, n.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const n = this.parentContexts.getContext(this.name); n && n.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { const n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = n; const o = (r = r || this.resolver).resolveComponentFactory(n._futureSnapshot.routeConfig.component), a = this.parentContexts.getOrCreateContext(this.name).children, l = new dR(n, a, this.location.injector); this.activated = this.location.createComponent(o, this.location.length, l), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (n) { return new (n || t)(N(Oa), N(On), N(pa), function Vo(t) { return function cD(t, e) { if ("class" === e) return t.classes; if ("style" === e) return t.styles; const n = t.attrs; if (n) { const r = n.length; let i = 0; for (; i < r;) { const s = n[i]; if (Mg(s)) break; if (0 === s) i += 2; else if ("number" == typeof s) for (i++; i < r && "string" == typeof n[i];)i++; else { if (s === e) return n[i + 1]; i += 2 } } } return null }(Qe(), t) }("name"), N(rh)) }, t.\u0275dir = pt({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"] }), t })(); class dR { constructor(e, n, r) { this.route = e, this.childContexts = n, this.parent = r } get(e, n) { return e === Js ? this.route : e === Oa ? this.childContexts : this.parent.get(e, n) } } let Xw = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275cmp = Io({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (n, r) { 1 & n && aa(0, "router-outlet") }, directives: [Yw], encapsulation: 2 }), t })(); function Qw(t, e = "") { for (let n = 0; n < t.length; n++) { const r = t[n]; fR(r, hR(e, r)) } } function fR(t, e) { t.children && Qw(t.children, e) } function hR(t, e) { return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Wh(t) { const e = t.children && t.children.map(Wh), n = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && n.outlet !== ee && (n.component = Xw), n } function dn(t) { return t.outlet || ee } function Kw(t, e) { const n = t.filter(r => dn(r) === e); return n.push(...t.filter(r => dn(r) !== e)), n } const Jw = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function w0(t, e, n) { var r; if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? Object.assign({}, Jw) : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; const s = (e.matcher || xO)(n, t, e); if (!s) return Object.assign({}, Jw); const o = {}; dt(s.posParams, (l, u) => { o[u] = l.path }); const a = s.consumed.length > 0 ? Object.assign(Object.assign({}, o), s.consumed[s.consumed.length - 1].parameters) : o; return { matched: !0, consumedSegments: s.consumed, remainingSegments: n.slice(s.consumed.length), parameters: a, positionalParamSegments: null !== (r = s.posParams) && void 0 !== r ? r : {} } } function v0(t, e, n, r, i = "corrected") { if (n.length > 0 && function mR(t, e, n) { return n.some(r => b0(t, e, r) && dn(r) !== ee) }(t, n, r)) { const o = new ie(e, function gR(t, e, n, r) { const i = {}; i[ee] = r, r._sourceSegment = t, r._segmentIndexShift = e.length; for (const s of n) if ("" === s.path && dn(s) !== ee) { const o = new ie([], {}); o._sourceSegment = t, o._segmentIndexShift = e.length, i[dn(s)] = o } return i }(t, e, r, new ie(n, t.children))); return o._sourceSegment = t, o._segmentIndexShift = e.length, { segmentGroup: o, slicedSegments: [] } } if (0 === n.length && function _R(t, e, n) { return n.some(r => b0(t, e, r)) }(t, n, r)) { const o = new ie(t.segments, function pR(t, e, n, r, i, s) { const o = {}; for (const a of r) if (b0(t, n, a) && !i[dn(a)]) { const l = new ie([], {}); l._sourceSegment = t, l._segmentIndexShift = "legacy" === s ? t.segments.length : e.length, o[dn(a)] = l } return Object.assign(Object.assign({}, i), o) }(t, e, n, r, t.children, i)); return o._sourceSegment = t, o._segmentIndexShift = e.length, { segmentGroup: o, slicedSegments: n } } const s = new ie(t.segments, t.children); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: n } } function b0(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path } function ev(t, e, n, r) { return !!(dn(t) === r || r !== ee && b0(e, n, t)) && ("**" === t.path || w0(e, t, n).matched) } function tv(t, e, n) { return 0 === e.length && !t.children[n] } class T0 { constructor(e) { this.segmentGroup = e || null } } class nv { constructor(e) { this.urlTree = e } } function Ra(t) { return u0(new T0(t)) } function rv(t) { return u0(new nv(t)) } class bR { constructor(e, n, r, i, s) { this.configLoader = n, this.urlSerializer = r, this.urlTree = i, this.config = s, this.allowRedirects = !0, this.ngModule = e.get(gr) } apply() { const e = v0(this.urlTree.root, [], [], this.config).segmentGroup, n = new ie(e.segments, e.children); return this.expandSegmentGroup(this.ngModule, this.config, n, ee).pipe(X(s => this.createUrlTree(qh(s), this.urlTree.queryParams, this.urlTree.fragment))).pipe(Xr(s => { if (s instanceof nv) return this.allowRedirects = !1, this.match(s.urlTree); throw s instanceof T0 ? this.noMatchError(s) : s })) } match(e) { return this.expandSegmentGroup(this.ngModule, this.config, e.root, ee).pipe(X(i => this.createUrlTree(qh(i), e.queryParams, e.fragment))).pipe(Xr(i => { throw i instanceof T0 ? this.noMatchError(i) : i })) } noMatchError(e) { return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`) } createUrlTree(e, n, r) { const i = e.segments.length > 0 ? new ie([], { [ee]: e }) : e; return new Ii(i, n, r) } expandSegmentGroup(e, n, r, i) { return 0 === r.segments.length && r.hasChildren() ? this.expandChildren(e, n, r).pipe(X(s => new ie([], s))) : this.expandSegment(e, r, n, r.segments, i, !0) } expandChildren(e, n, r) { const i = []; for (const s of Object.keys(r.children)) "primary" === s ? i.unshift(s) : i.push(s); return ye(i).pipe(Ca(s => { const o = r.children[s], a = Kw(n, s); return this.expandSegmentGroup(e, a, o, s).pipe(X(l => ({ segment: l, outlet: s }))) }), _w((s, o) => (s[o.outlet] = o.segment, s), {}), function fO(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? Ys((i, s) => t(i, s, r)) : Un, Oh(1), n ? ww(e) : yw(() => new c0)) }()) } expandSegment(e, n, r, i, s, o) { return ye(r).pipe(Ca(a => this.expandSegmentAgainstRoute(e, n, r, a, i, s, o).pipe(Xr(u => { if (u instanceof T0) return K(null); throw u }))), Xs(a => !!a), Xr((a, l) => { if (a instanceof c0 || "EmptyError" === a.name) return tv(n, i, s) ? K(new ie([], {})) : Ra(n); throw a })) } expandSegmentAgainstRoute(e, n, r, i, s, o, a) { return ev(i, n, s, o) ? void 0 === i.redirectTo ? this.matchSegmentAgainstRoute(e, n, i, s, o) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(e, n, r, i, s, o) : Ra(n) : Ra(n) } expandSegmentAgainstRouteUsingRedirect(e, n, r, i, s, o) { return "**" === i.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(e, r, i, o) : this.expandRegularSegmentAgainstRouteUsingRedirect(e, n, r, i, s, o) } expandWildCardWithParamsAgainstRouteUsingRedirect(e, n, r, i) { const s = this.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? rv(s) : this.lineralizeSegments(r, s).pipe(Pe(o => { const a = new ie(o, {}); return this.expandSegment(e, a, n, o, i, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(e, n, r, i, s, o) { const { matched: a, consumedSegments: l, remainingSegments: u, positionalParamSegments: c } = w0(n, i, s); if (!a) return Ra(n); const d = this.applyRedirectCommands(l, i.redirectTo, c); return i.redirectTo.startsWith("/") ? rv(d) : this.lineralizeSegments(i, d).pipe(Pe(f => this.expandSegment(e, n, r, f.concat(u), o, !1))) } matchSegmentAgainstRoute(e, n, r, i, s) { if ("**" === r.path) return r.loadChildren ? (r._loadedConfig ? K(r._loadedConfig) : this.configLoader.load(e.injector, r)).pipe(X(d => (r._loadedConfig = d, new ie(i, {})))) : K(new ie(i, {})); const { matched: o, consumedSegments: a, remainingSegments: l } = w0(n, r, i); return o ? this.getChildConfig(e, r, i).pipe(Pe(c => { const d = c.module, f = c.routes, { segmentGroup: h, slicedSegments: p } = v0(n, a, l, f), m = new ie(h.segments, h.children); if (0 === p.length && m.hasChildren()) return this.expandChildren(d, f, m).pipe(X(T => new ie(a, T))); if (0 === f.length && 0 === p.length) return K(new ie(a, {})); const y = dn(r) === s; return this.expandSegment(d, m, f, p, y ? ee : s, !0).pipe(X(w => new ie(a.concat(w.segments), w.children))) })) : Ra(n) } getChildConfig(e, n, r) { return n.children ? K(new zh(n.children, e)) : n.loadChildren ? void 0 !== n._loadedConfig ? K(n._loadedConfig) : this.runCanLoadGuards(e.injector, n, r).pipe(Pe(i => i ? this.configLoader.load(e.injector, n).pipe(X(s => (n._loadedConfig = s, s))) : function wR(t) { return u0(Fh(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)) }(n))) : K(new zh([], e)) } runCanLoadGuards(e, n, r) { const i = n.canLoad; return i && 0 !== i.length ? K(i.map(o => { const a = e.get(o); let l; if (function oR(t) { return t && Qr(t.canLoad) }(a)) l = a.canLoad(n, r); else { if (!Qr(a)) throw new Error("Invalid CanLoad guard"); l = a(n, r) } return nr(l) })).pipe(Pa(), Gt(o => { if (!Pi(o)) return; const a = Fh(`Redirecting to "${this.urlSerializer.serialize(o)}"`); throw a.url = o, a }), X(o => !0 === o)) : K(!0) } lineralizeSegments(e, n) { let r = [], i = n.root; for (; ;) { if (r = r.concat(i.segments), 0 === i.numberOfChildren) return K(r); if (i.numberOfChildren > 1 || !i.children[ee]) return u0(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e.redirectTo}'`)); i = i.children[ee] } } applyRedirectCommands(e, n, r) { return this.applyRedirectCreatreUrlTree(n, this.urlSerializer.parse(n), e, r) } applyRedirectCreatreUrlTree(e, n, r, i) { const s = this.createSegmentGroup(e, n.root, r, i); return new Ii(s, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(e, n) { const r = {}; return dt(e, (i, s) => { if ("string" == typeof i && i.startsWith(":")) { const a = i.substring(1); r[s] = n[a] } else r[s] = i }), r } createSegmentGroup(e, n, r, i) { const s = this.createSegments(e, n.segments, r, i); let o = {}; return dt(n.children, (a, l) => { o[l] = this.createSegmentGroup(e, a, r, i) }), new ie(s, o) } createSegments(e, n, r, i) { return n.map(s => s.path.startsWith(":") ? this.findPosParam(e, s, i) : this.findOrReturn(s, r)) } findPosParam(e, n, r) { const i = r[n.path.substring(1)]; if (!i) throw new Error(`Cannot redirect to '${e}'. Cannot find '${n.path}'.`); return i } findOrReturn(e, n) { let r = 0; for (const i of n) { if (i.path === e.path) return n.splice(r), i; r++ } return e } } function qh(t) { const e = {}; for (const r of Object.keys(t.children)) { const s = qh(t.children[r]); (s.segments.length > 0 || s.hasChildren()) && (e[r] = s) } return function TR(t) { if (1 === t.numberOfChildren && t.children[ee]) { const e = t.children[ee]; return new ie(t.segments.concat(e.segments), e.children) } return t }(new ie(t.segments, e)) } class iv { constructor(e) { this.path = e, this.route = this.path[this.path.length - 1] } } class k0 { constructor(e, n) { this.component = e, this.route = n } } function DR(t, e, n) { const r = t._root; return Fa(r, e ? e._root : null, n, [r.value]) } function D0(t, e, n) { const r = function xR(t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const n = e.routeConfig; if (n && n._loadedConfig) return n._loadedConfig } return null }(e); return (r ? r.module.injector : n).get(t) } function Fa(t, e, n, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const s = Ks(e); return t.children.forEach(o => { (function ER(t, e, n, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const s = t.value, o = e ? e.value : null, a = n ? n.getContext(t.value.outlet) : null; if (o && s.routeConfig === o.routeConfig) { const l = function MR(t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !Ai(t.url, e.url); case "pathParamsOrQueryParamsChange": return !Ai(t.url, e.url) || !tr(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !jh(t, e) || !tr(t.queryParams, e.queryParams); default: return !jh(t, e) } }(o, s, s.routeConfig.runGuardsAndResolvers); l ? i.canActivateChecks.push(new iv(r)) : (s.data = o.data, s._resolvedData = o._resolvedData), Fa(t, e, s.component ? a ? a.children : null : n, r, i), l && a && a.outlet && a.outlet.isActivated && i.canDeactivateChecks.push(new k0(a.outlet.component, o)) } else o && Na(e, a, i), i.canActivateChecks.push(new iv(r)), Fa(t, null, s.component ? a ? a.children : null : n, r, i) })(o, s[o.value.outlet], n, r.concat([o.value]), i), delete s[o.value.outlet] }), dt(s, (o, a) => Na(o, n.getContext(a), i)), i } function Na(t, e, n) { const r = Ks(t), i = t.value; dt(r, (s, o) => { Na(s, i.component ? e ? e.children.getContext(o) : null : e, n) }), n.canDeactivateChecks.push(new k0(i.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, i)) } class LR { } function sv(t) { return new Ve(e => e.error(t)) } class VR { constructor(e, n, r, i, s, o) { this.rootComponentType = e, this.config = n, this.urlTree = r, this.url = i, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = o } recognize() { const e = v0(this.urlTree.root, [], [], this.config.filter(o => void 0 === o.redirectTo), this.relativeLinkResolution).segmentGroup, n = this.processSegmentGroup(this.config, e, ee); if (null === n) return null; const r = new m0([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, ee, this.rootComponentType, null, this.urlTree.root, -1, {}), i = new vr(r, n), s = new Hw(this.url, i); return this.inheritParamsAndData(s._root), s } inheritParamsAndData(e) { const n = e.value, r = jw(n, this.paramsInheritanceStrategy); n.params = Object.freeze(r.params), n.data = Object.freeze(r.data), e.children.forEach(i => this.inheritParamsAndData(i)) } processSegmentGroup(e, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.processChildren(e, n) : this.processSegment(e, n, n.segments, r) } processChildren(e, n) { const r = []; for (const s of Object.keys(n.children)) { const o = n.children[s], a = Kw(e, s), l = this.processSegmentGroup(a, o, s); if (null === l) return null; r.push(...l) } const i = ov(r); return function BR(t) { t.sort((e, n) => e.value.outlet === ee ? -1 : n.value.outlet === ee ? 1 : e.value.outlet.localeCompare(n.value.outlet)) }(i), i } processSegment(e, n, r, i) { for (const s of e) { const o = this.processSegmentAgainstRoute(s, n, r, i); if (null !== o) return o } return tv(n, r, i) ? [] : null } processSegmentAgainstRoute(e, n, r, i) { if (e.redirectTo || !ev(e, n, r, i)) return null; let s, o = [], a = []; if ("**" === e.path) { const h = r.length > 0 ? Ew(r).parameters : {}; s = new m0(r, h, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, uv(e), dn(e), e.component, e, av(n), lv(n) + r.length, cv(e)) } else { const h = w0(n, e, r); if (!h.matched) return null; o = h.consumedSegments, a = h.remainingSegments, s = new m0(o, h.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, uv(e), dn(e), e.component, e, av(n), lv(n) + o.length, cv(e)) } const l = function jR(t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(e), { segmentGroup: u, slicedSegments: c } = v0(n, o, a, l.filter(h => void 0 === h.redirectTo), this.relativeLinkResolution); if (0 === c.length && u.hasChildren()) { const h = this.processChildren(l, u); return null === h ? null : [new vr(s, h)] } if (0 === l.length && 0 === c.length) return [new vr(s, [])]; const d = dn(e) === i, f = this.processSegment(l, u, c, d ? ee : i); return null === f ? null : [new vr(s, f)] } } function HR(t) { const e = t.value.routeConfig; return e && "" === e.path && void 0 === e.redirectTo } function ov(t) { const e = [], n = new Set; for (const r of t) { if (!HR(r)) { e.push(r); continue } const i = e.find(s => r.value.routeConfig === s.value.routeConfig); void 0 !== i ? (i.children.push(...r.children), n.add(i)) : e.push(r) } for (const r of n) { const i = ov(r.children); e.push(new vr(r.value, i)) } return e.filter(r => !n.has(r)) } function av(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function lv(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function uv(t) { return t.data || {} } function cv(t) { return t.resolve || {} } function dv(t) { return [...Object.keys(t), ...Object.getOwnPropertySymbols(t)] } function Gh(t) { return Si(e => { const n = t(e); return n ? ye(n).pipe(X(() => e)) : K(e) }) } class XR extends class YR { shouldDetach(e) { return !1 } store(e, n) { } shouldAttach(e) { return !1 } retrieve(e) { return null } shouldReuseRoute(e, n) { return e.routeConfig === n.routeConfig } }{ } const Yh = new ce("ROUTES"); class fv { constructor(e, n, r, i) { this.injector = e, this.compiler = n, this.onLoadStartListener = r, this.onLoadEndListener = i } load(e, n) { if (n._loader$) return n._loader$; this.onLoadStartListener && this.onLoadStartListener(n); const i = this.loadModuleFactory(n.loadChildren).pipe(X(s => { this.onLoadEndListener && this.onLoadEndListener(n); const o = s.create(e); return new zh(xw(o.injector.get(Yh, void 0, H.Self | H.Optional)).map(Wh), o) }), Xr(s => { throw n._loader$ = void 0, s })); return n._loader$ = new lO(i, () => new gn).pipe(mw()), n._loader$ } loadModuleFactory(e) { return nr(e()).pipe(Pe(n => n instanceof P1 ? K(n) : ye(this.compiler.compileModuleAsync(n)))) } } class KR { shouldProcessUrl(e) { return !0 } extract(e) { return e } merge(e, n) { return e } } function JR(t) { throw t } function eF(t, e, n) { return e.parse("/") } function hv(t, e) { return K(null) } const tF = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, nF = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Yt = (() => { class t { constructor(n, r, i, s, o, a, l) { this.rootComponentType = n, this.urlSerializer = r, this.rootContexts = i, this.location = s, this.config = l, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new gn, this.errorHandler = JR, this.malformedUriErrorHandler = eF, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: hv, afterPreactivation: hv }, this.urlHandlingStrategy = new KR, this.routeReuseStrategy = new XR, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = o.get(gr), this.console = o.get(XI); const d = o.get(ct); this.isNgZoneEnabled = d instanceof ct && ct.isInAngularZone(), this.resetConfig(l), this.currentUrlTree = function MO() { return new Ii(new ie([], {}), {}, null) }(), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new fv(o, a, f => this.triggerEvent(new bw(f)), f => this.triggerEvent(new Tw(f))), this.routerState = Bw(this.currentUrlTree, this.rootComponentType), this.transitions = new Nn({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } get browserPageId() { var n; return null === (n = this.location.getState()) || void 0 === n ? void 0 : n.\u0275routerPageId } setupNavigations(n) { const r = this.events; return n.pipe(Ys(i => 0 !== i.id), X(i => Object.assign(Object.assign({}, i), { extractedUrl: this.urlHandlingStrategy.extract(i.rawUrl) })), Si(i => { let s = !1, o = !1; return K(i).pipe(Gt(a => { this.currentNavigation = { id: a.id, initialUrl: a.currentRawUrl, extractedUrl: a.extractedUrl, trigger: a.source, extras: a.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), Si(a => { const l = this.browserUrlTree.toString(), u = !this.navigated || a.extractedUrl.toString() !== l || l !== this.currentUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || u) && this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)) return pv(a.source) && (this.browserUrlTree = a.extractedUrl), K(a).pipe(Si(d => { const f = this.transitions.getValue(); return r.next(new Rh(d.id, this.serializeUrl(d.extractedUrl), d.source, d.restoredState)), f !== this.transitions.getValue() ? kt : Promise.resolve(d) }), function kR(t, e, n, r) { return Si(i => function vR(t, e, n, r, i) { return new bR(t, e, n, r, i).apply() }(t, e, n, i.extractedUrl, r).pipe(X(s => Object.assign(Object.assign({}, i), { urlAfterRedirects: s })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), Gt(d => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: d.urlAfterRedirects }) }), function UR(t, e, n, r, i) { return Pe(s => function ZR(t, e, n, r, i = "emptyOnly", s = "legacy") { try { const o = new VR(t, e, n, r, i, s).recognize(); return null === o ? sv(new LR) : K(o) } catch (o) { return sv(o) } }(t, e, s.urlAfterRedirects, n(s.urlAfterRedirects), r, i).pipe(X(o => Object.assign(Object.assign({}, s), { targetSnapshot: o })))) }(this.rootComponentType, this.config, d => this.serializeUrl(d), this.paramsInheritanceStrategy, this.relativeLinkResolution), Gt(d => { if ("eager" === this.urlUpdateStrategy) { if (!d.extras.skipLocationChange) { const h = this.urlHandlingStrategy.merge(d.urlAfterRedirects, d.rawUrl); this.setBrowserUrl(h, d) } this.browserUrlTree = d.urlAfterRedirects } const f = new gO(d.id, this.serializeUrl(d.extractedUrl), this.serializeUrl(d.urlAfterRedirects), d.targetSnapshot); r.next(f) })); if (u && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: f, extractedUrl: h, source: p, restoredState: m, extras: y } = a, v = new Rh(f, this.serializeUrl(h), p, m); r.next(v); const w = Bw(h, this.rootComponentType).snapshot; return K(Object.assign(Object.assign({}, a), { targetSnapshot: w, urlAfterRedirects: h, extras: Object.assign(Object.assign({}, y), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = a.rawUrl, a.resolve(null), kt }), Gh(a => { const { targetSnapshot: l, id: u, extractedUrl: c, rawUrl: d, extras: { skipLocationChange: f, replaceUrl: h } } = a; return this.hooks.beforePreactivation(l, { navigationId: u, appliedUrlTree: c, rawUrlTree: d, skipLocationChange: !!f, replaceUrl: !!h }) }), Gt(a => { const l = new mO(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot); this.triggerEvent(l) }), X(a => Object.assign(Object.assign({}, a), { guards: DR(a.targetSnapshot, a.currentSnapshot, this.rootContexts) })), function SR(t, e) { return Pe(n => { const { targetSnapshot: r, currentSnapshot: i, guards: { canActivateChecks: s, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === s.length ? K(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function IR(t, e, n, r) { return ye(t).pipe(Pe(i => function NR(t, e, n, r, i) { const s = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return s && 0 !== s.length ? K(s.map(a => { const l = D0(a, e, i); let u; if (function uR(t) { return t && Qr(t.canDeactivate) }(l)) u = nr(l.canDeactivate(t, e, n, r)); else { if (!Qr(l)) throw new Error("Invalid CanDeactivate guard"); u = nr(l(t, e, n, r)) } return u.pipe(Xs()) })).pipe(Pa()) : K(!0) }(i.component, i.route, n, e, r)), Xs(i => !0 !== i, !0)) }(o, r, i, t).pipe(Pe(a => a && function sR(t) { return "boolean" == typeof t }(a) ? function AR(t, e, n, r) { return ye(e).pipe(Ca(i => Ah(function OR(t, e) { return null !== t && e && e(new vO(t)), K(!0) }(i.route.parent, r), function PR(t, e) { return null !== t && e && e(new TO(t)), K(!0) }(i.route, r), function FR(t, e, n) { const r = e[e.length - 1], s = e.slice(0, e.length - 1).reverse().map(o => function CR(t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(o)).filter(o => null !== o).map(o => gw(() => K(o.guards.map(l => { const u = D0(l, o.node, n); let c; if (function lR(t) { return t && Qr(t.canActivateChild) }(u)) c = nr(u.canActivateChild(r, t)); else { if (!Qr(u)) throw new Error("Invalid CanActivateChild guard"); c = nr(u(r, t)) } return c.pipe(Xs()) })).pipe(Pa()))); return K(s).pipe(Pa()) }(t, i.path, n), function RR(t, e, n) { const r = e.routeConfig ? e.routeConfig.canActivate : null; if (!r || 0 === r.length) return K(!0); const i = r.map(s => gw(() => { const o = D0(s, e, n); let a; if (function aR(t) { return t && Qr(t.canActivate) }(o)) a = nr(o.canActivate(e, t)); else { if (!Qr(o)) throw new Error("Invalid CanActivate guard"); a = nr(o(e, t)) } return a.pipe(Xs()) })); return K(i).pipe(Pa()) }(t, i.route, n))), Xs(i => !0 !== i, !0)) }(r, s, t, e) : K(a)), X(a => Object.assign(Object.assign({}, n), { guardsResult: a }))) }) }(this.ngModule.injector, a => this.triggerEvent(a)), Gt(a => { if (Pi(a.guardsResult)) { const u = Fh(`Redirecting to "${this.serializeUrl(a.guardsResult)}"`); throw u.url = a.guardsResult, u } const l = new _O(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot, !!a.guardsResult); this.triggerEvent(l) }), Ys(a => !!a.guardsResult || (this.restoreHistory(a), this.cancelNavigationTransition(a, ""), !1)), Gh(a => { if (a.guards.canActivateChecks.length) return K(a).pipe(Gt(l => { const u = new yO(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(u) }), Si(l => { let u = !1; return K(l).pipe(function $R(t, e) { return Pe(n => { const { targetSnapshot: r, guards: { canActivateChecks: i } } = n; if (!i.length) return K(n); let s = 0; return ye(i).pipe(Ca(o => function zR(t, e, n, r) { return function WR(t, e, n, r) { const i = dv(t); if (0 === i.length) return K({}); const s = {}; return ye(i).pipe(Pe(o => function qR(t, e, n, r) { const i = D0(t, e, r); return nr(i.resolve ? i.resolve(e, n) : i(e, n)) }(t[o], e, n, r).pipe(Gt(a => { s[o] = a }))), Oh(1), Pe(() => dv(s).length === i.length ? K(s) : kt)) }(t._resolve, t, e, r).pipe(X(s => (t._resolvedData = s, t.data = Object.assign(Object.assign({}, t.data), jw(t, n).resolve), null))) }(o.route, r, t, e)), Gt(() => s++), Oh(1), Pe(o => s === i.length ? K(n) : kt)) }) }(this.paramsInheritanceStrategy, this.ngModule.injector), Gt({ next: () => u = !0, complete: () => { u || (this.restoreHistory(l), this.cancelNavigationTransition(l, "At least one route resolver didn't emit any value.")) } })) }), Gt(l => { const u = new wO(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(u) })) }), Gh(a => { const { targetSnapshot: l, id: u, extractedUrl: c, rawUrl: d, extras: { skipLocationChange: f, replaceUrl: h } } = a; return this.hooks.afterPreactivation(l, { navigationId: u, appliedUrlTree: c, rawUrlTree: d, skipLocationChange: !!f, replaceUrl: !!h }) }), X(a => { const l = function WO(t, e, n) { const r = Sa(t, e._root, n ? n._root : void 0); return new Vw(r, e) }(this.routeReuseStrategy, a.targetSnapshot, a.currentRouterState); return Object.assign(Object.assign({}, a), { targetRouterState: l }) }), Gt(a => { this.currentUrlTree = a.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(a.urlAfterRedirects, a.rawUrl), this.routerState = a.targetRouterState, "deferred" === this.urlUpdateStrategy && (a.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, a), this.browserUrlTree = a.urlAfterRedirects) }), ((t, e, n) => X(r => (new rR(e, r.targetRouterState, r.currentRouterState, n).activate(t), r)))(this.rootContexts, this.routeReuseStrategy, a => this.triggerEvent(a)), Gt({ next() { s = !0 }, complete() { s = !0 } }), function hO(t) { return Be((e, n) => { try { e.subscribe(n) } finally { n.add(t) } }) }(() => { var a; s || o || this.cancelNavigationTransition(i, `Navigation ID ${i.id} is not equal to the current navigation id ${this.navigationId}`), (null === (a = this.currentNavigation) || void 0 === a ? void 0 : a.id) === i.id && (this.currentNavigation = null) }), Xr(a => { if (o = !0, function CO(t) { return t && t[Dw] }(a)) { const l = Pi(a.url); l || (this.navigated = !0, this.restoreHistory(i, !0)); const u = new vw(i.id, this.serializeUrl(i.extractedUrl), a.message); r.next(u), l ? setTimeout(() => { const c = this.urlHandlingStrategy.merge(a.url, this.rawUrlTree), d = { skipLocationChange: i.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || pv(i.source) }; this.scheduleNavigation(c, "imperative", null, d, { resolve: i.resolve, reject: i.reject, promise: i.promise }) }, 0) : i.resolve(!1) } else { this.restoreHistory(i, !0); const l = new pO(i.id, this.serializeUrl(i.extractedUrl), a); r.next(l); try { i.resolve(this.errorHandler(a)) } catch (u) { i.reject(u) } } return kt })) })) } resetRootComponentType(n) { this.rootComponentType = n, this.routerState.root.component = this.rootComponentType } setTransition(n) { this.transitions.next(Object.assign(Object.assign({}, this.transitions.value), n)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(n => { const r = "popstate" === n.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { var i; const s = { replaceUrl: !0 }, o = (null === (i = n.state) || void 0 === i ? void 0 : i.navigationId) ? n.state : null; if (o) { const l = Object.assign({}, o); delete l.navigationId, delete l.\u0275routerPageId, 0 !== Object.keys(l).length && (s.state = l) } const a = this.parseUrl(n.url); this.scheduleNavigation(a, r, o, s) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(n) { this.events.next(n) } resetConfig(n) { Qw(n), this.config = n.map(Wh), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(n, r = {}) { const { relativeTo: i, queryParams: s, fragment: o, queryParamsHandling: a, preserveFragment: l } = r, u = i || this.routerState.root, c = l ? this.currentUrlTree.fragment : o; let d = null; switch (a) { case "merge": d = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), s); break; case "preserve": d = this.currentUrlTree.queryParams; break; default: d = s || null }return null !== d && (d = this.removeEmptyProps(d)), function YO(t, e, n, r, i) { if (0 === n.length) return Hh(e.root, e.root, e.root, r, i); const s = function XO(t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new zw(!0, 0, t); let e = 0, n = !1; const r = t.reduce((i, s, o) => { if ("object" == typeof s && null != s) { if (s.outlets) { const a = {}; return dt(s.outlets, (l, u) => { a[u] = "string" == typeof l ? l.split("/") : l }), [...i, { outlets: a }] } if (s.segmentPath) return [...i, s.segmentPath] } return "string" != typeof s ? [...i, s] : 0 === o ? (s.split("/").forEach((a, l) => { 0 == l && "." === a || (0 == l && "" === a ? n = !0 : ".." === a ? e++ : "" != a && i.push(a)) }), i) : [...i, s] }, []); return new zw(n, e, r) }(n); if (s.toRoot()) return Hh(e.root, e.root, new ie([], {}), r, i); const o = function QO(t, e, n) { if (t.isAbsolute) return new Uh(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const s = n.snapshot._urlSegment; return new Uh(s, s === e.root, 0) } const r = _0(t.commands[0]) ? 0 : 1; return function KO(t, e, n) { let r = t, i = e, s = n; for (; s > i;) { if (s -= i, r = r.parent, !r) throw new Error("Invalid number of '../'"); i = r.segments.length } return new Uh(r, !1, i - s) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, t.numberOfDoubleDots) }(s, e, t), a = o.processChildren ? y0(o.segmentGroup, o.index, s.commands) : Ww(o.segmentGroup, o.index, s.commands); return Hh(e.root, o.segmentGroup, a, r, i) }(u, this.currentUrlTree, n, d, null != c ? c : null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { const i = Pi(n) ? n : this.parseUrl(n), s = this.urlHandlingStrategy.merge(i, this.rawUrlTree); return this.scheduleNavigation(s, "imperative", null, r) } navigate(n, r = { skipLocationChange: !1 }) { return function rF(t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { let r; try { r = this.urlSerializer.parse(n) } catch (i) { r = this.malformedUriErrorHandler(i, this.urlSerializer, n) } return r } isActive(n, r) { let i; if (i = !0 === r ? Object.assign({}, tF) : !1 === r ? Object.assign({}, nF) : r, Pi(n)) return Sw(this.currentUrlTree, n, i); const s = this.parseUrl(n); return Sw(this.currentUrlTree, s, i) } removeEmptyProps(n) { return Object.keys(n).reduce((r, i) => { const s = n[i]; return null != s && (r[i] = s), r }, {}) } processNavigations() { this.navigations.subscribe(n => { this.navigated = !0, this.lastSuccessfulId = n.id, this.currentPageId = n.targetPageId, this.events.next(new xa(n.id, this.serializeUrl(n.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, n.resolve(!0) }, n => { this.console.warn(`Unhandled Navigation Error: ${n}`) }) } scheduleNavigation(n, r, i, s, o) { var a, l; if (this.disposed) return Promise.resolve(!1); let u, c, d; o ? (u = o.resolve, c = o.reject, d = o.promise) : d = new Promise((p, m) => { u = p, c = m }); const f = ++this.navigationId; let h; return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (i = this.location.getState()), h = i && i.\u0275routerPageId ? i.\u0275routerPageId : s.replaceUrl || s.skipLocationChange ? null !== (a = this.browserPageId) && void 0 !== a ? a : 0 : (null !== (l = this.browserPageId) && void 0 !== l ? l : 0) + 1) : h = 0, this.setTransition({ id: f, targetPageId: h, source: r, restoredState: i, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: n, extras: s, resolve: u, reject: c, promise: d, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), d.catch(p => Promise.reject(p)) } setBrowserUrl(n, r) { const i = this.urlSerializer.serialize(n), s = Object.assign(Object.assign({}, r.extras.state), this.generateNgRouterState(r.id, r.targetPageId)); this.location.isCurrentPathEqualTo(i) || r.extras.replaceUrl ? this.location.replaceState(i, "", s) : this.location.go(i, "", s) } restoreHistory(n, r = !1) { var i, s; if ("computed" === this.canceledNavigationResolution) { const o = this.currentPageId - n.targetPageId; "popstate" !== n.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== (null === (i = this.currentNavigation) || void 0 === i ? void 0 : i.finalUrl) || 0 === o ? this.currentUrlTree === (null === (s = this.currentNavigation) || void 0 === s ? void 0 : s.finalUrl) && 0 === o && (this.resetState(n), this.browserUrlTree = n.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(o) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(n), this.resetUrlToCurrentUrlTree()) } resetState(n) { this.routerState = n.currentRouterState, this.currentUrlTree = n.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(n, r) { const i = new vw(n.id, this.serializeUrl(n.extractedUrl), r); this.triggerEvent(i), n.resolve(!1) } generateNgRouterState(n, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } } return t.\u0275fac = function (n) { gf() }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(); function pv(t) { return "imperative" !== t } class gv { } class mv { preload(e, n) { return K(null) } } let _v = (() => { class t { constructor(n, r, i, s) { this.router = n, this.injector = i, this.preloadingStrategy = s, this.loader = new fv(i, r, l => n.triggerEvent(new bw(l)), l => n.triggerEvent(new Tw(l))) } setUpPreloading() { this.subscription = this.router.events.pipe(Ys(n => n instanceof xa), Ca(() => this.preload())).subscribe(() => { }) } preload() { const n = this.injector.get(gr); return this.processRoutes(n, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(n, r) { const i = []; for (const s of r) if (s.loadChildren && !s.canLoad && s._loadedConfig) { const o = s._loadedConfig; i.push(this.processRoutes(o.module, o.routes)) } else s.loadChildren && !s.canLoad ? i.push(this.preloadConfig(n, s)) : s.children && i.push(this.processRoutes(n, s.children)); return ye(i).pipe(Vt(), X(s => { })) } preloadConfig(n, r) { return this.preloadingStrategy.preload(r, () => (r._loadedConfig ? K(r._loadedConfig) : this.loader.load(n.injector, r)).pipe(Pe(s => (r._loadedConfig = s, this.processRoutes(s.module, s.routes))))) } } return t.\u0275fac = function (n) { return new (n || t)(V(Yt), V(my), V(qt), V(gv)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(), Kh = (() => { class t { constructor(n, r, i = {}) { this.router = n, this.viewportScroller = r, this.options = i, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, i.scrollPositionRestoration = i.scrollPositionRestoration || "disabled", i.anchorScrolling = i.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(n => { n instanceof Rh ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = n.navigationTrigger, this.restoredId = n.restoredState ? n.restoredState.navigationId : 0) : n instanceof xa && (this.lastId = n.id, this.scheduleScrollEvent(n, this.router.parseUrl(n.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(n => { n instanceof kw && (n.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(n.position) : n.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(n.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(n, r) { this.router.triggerEvent(new kw(n, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (n) { gf() }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(); const Oi = new ce("ROUTER_CONFIGURATION"), yv = new ce("ROUTER_FORROOT_GUARD"), aF = [ch, { provide: Ow, useClass: Rw }, { provide: Yt, useFactory: function fF(t, e, n, r, i, s, o = {}, a, l) { const u = new Yt(null, t, e, n, r, i, xw(s)); return a && (u.urlHandlingStrategy = a), l && (u.routeReuseStrategy = l), function hF(t, e) { t.errorHandler && (e.errorHandler = t.errorHandler), t.malformedUriErrorHandler && (e.malformedUriErrorHandler = t.malformedUriErrorHandler), t.onSameUrlNavigation && (e.onSameUrlNavigation = t.onSameUrlNavigation), t.paramsInheritanceStrategy && (e.paramsInheritanceStrategy = t.paramsInheritanceStrategy), t.relativeLinkResolution && (e.relativeLinkResolution = t.relativeLinkResolution), t.urlUpdateStrategy && (e.urlUpdateStrategy = t.urlUpdateStrategy), t.canceledNavigationResolution && (e.canceledNavigationResolution = t.canceledNavigationResolution) }(o, u), o.enableTracing && u.events.subscribe(c => { var d, f; null === (d = console.group) || void 0 === d || d.call(console, `Router Event: ${c.constructor.name}`), console.log(c.toString()), console.log(c), null === (f = console.groupEnd) || void 0 === f || f.call(console) }), u }, deps: [Ow, Oa, ch, qt, my, Yh, Oi, [class QR { }, new Hr], [class GR { }, new Hr]] }, Oa, { provide: Js, useFactory: function pF(t) { return t.routerState.root }, deps: [Yt] }, _v, mv, class oF { preload(e, n) { return n().pipe(Xr(() => K(null))) } }, { provide: Oi, useValue: { enableTracing: !1 } }]; function lF() { return new by("Router", Yt) } let wv = (() => { class t { constructor(n, r) { } static forRoot(n, r) { return { ngModule: t, providers: [aF, vv(n), { provide: yv, useFactory: dF, deps: [[Yt, new Hr, new Wo]] }, { provide: Oi, useValue: r || {} }, { provide: Gs, useFactory: cF, deps: [Mi, [new uu(uh), new Hr], Oi] }, { provide: Kh, useFactory: uF, deps: [Yt, cP, Oi] }, { provide: gv, useExisting: r && r.preloadingStrategy ? r.preloadingStrategy : mv }, { provide: by, multi: !0, useFactory: lF }, [Jh, { provide: Wf, multi: !0, useFactory: gF, deps: [Jh] }, { provide: bv, useFactory: mF, deps: [Jh] }, { provide: gy, multi: !0, useExisting: bv }]] } } static forChild(n) { return { ngModule: t, providers: [vv(n)] } } } return t.\u0275fac = function (n) { return new (n || t)(V(yv, 8), V(Yt, 8)) }, t.\u0275mod = gi({ type: t }), t.\u0275inj = Fr({}), t })(); function uF(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new Kh(t, e, n) } function cF(t, e, n = {}) { return n.useHash ? new HA(t, e) : new By(t, e) } function dF(t) { return "guarded" } function vv(t) { return [{ provide: mD, multi: !0, useValue: t }, { provide: Yh, multi: !0, useValue: t }] } let Jh = (() => { class t { constructor(n) { this.injector = n, this.initNavigation = !1, this.destroyed = !1, this.resultOfPreactivationDone = new gn } appInitializer() { return this.injector.get(VA, Promise.resolve(null)).then(() => { if (this.destroyed) return Promise.resolve(!0); let r = null; const i = new Promise(a => r = a), s = this.injector.get(Yt), o = this.injector.get(Oi); return "disabled" === o.initialNavigation ? (s.setUpLocationChangeListener(), r(!0)) : "enabled" === o.initialNavigation || "enabledBlocking" === o.initialNavigation ? (s.hooks.afterPreactivation = () => this.initNavigation ? K(null) : (this.initNavigation = !0, r(!0), this.resultOfPreactivationDone), s.initialNavigation()) : r(!0), i }) } bootstrapListener(n) { const r = this.injector.get(Oi), i = this.injector.get(_v), s = this.injector.get(Kh), o = this.injector.get(Yt), a = this.injector.get(th); n === a.components[0] && (("enabledNonBlocking" === r.initialNavigation || void 0 === r.initialNavigation) && o.initialNavigation(), i.setUpPreloading(), s.init(), o.resetRootComponentType(a.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } ngOnDestroy() { this.destroyed = !0 } } return t.\u0275fac = function (n) { return new (n || t)(V(qt)) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac }), t })(); function gF(t) { return t.appInitializer.bind(t) } function mF(t) { return t.bootstrapListener.bind(t) } const bv = new ce("Router Initializer"), yF = []; let wF = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = gi({ type: t }), t.\u0275inj = Fr({ imports: [[wv.forRoot(yF)], wv] }), t })(); function to(t) { return t + .5 | 0 } const br = (t, e, n) => Math.max(Math.min(t, n), e); function La(t) { return br(to(2.55 * t), 0, 255) } function Kr(t) { return br(to(255 * t), 0, 255) } function Tr(t) { return br(to(t / 2.55) / 100, 0, 1) } function Tv(t) { return br(to(100 * t), 0, 100) } const fn = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, ep = [..."0123456789ABCDEF"], vF = t => ep[15 & t], bF = t => ep[(240 & t) >> 4] + ep[15 & t], C0 = t => (240 & t) >> 4 == (15 & t); const xF = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function kv(t, e, n) { const r = e * Math.min(n, 1 - n), i = (s, o = (s + t / 30) % 12) => n - r * Math.max(Math.min(o - 3, 9 - o, 1), -1); return [i(0), i(8), i(4)] } function EF(t, e, n) { const r = (i, s = (i + t / 60) % 6) => n - n * e * Math.max(Math.min(s, 4 - s, 1), 0); return [r(5), r(3), r(1)] } function MF(t, e, n) { const r = kv(t, 1, .5); let i; for (e + n > 1 && (i = 1 / (e + n), e *= i, n *= i), i = 0; i < 3; i++)r[i] *= 1 - e - n, r[i] += e; return r } function tp(t) { const n = t.r / 255, r = t.g / 255, i = t.b / 255, s = Math.max(n, r, i), o = Math.min(n, r, i), a = (s + o) / 2; let l, u, c; return s !== o && (c = s - o, u = a > .5 ? c / (2 - s - o) : c / (s + o), l = function SF(t, e, n, r, i) { return t === i ? (e - n) / r + (e < n ? 6 : 0) : e === i ? (n - t) / r + 2 : (t - e) / r + 4 }(n, r, i, c, s), l = 60 * l + .5), [0 | l, u || 0, a] } function np(t, e, n, r) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, r)).map(Kr) } function rp(t, e, n) { return np(kv, t, e, n) } function Dv(t) { return (t % 360 + 360) % 360 } const Cv = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, xv = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; let x0; const LF = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/, ip = t => t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055, no = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4); function E0(t, e, n) { if (t) { let r = tp(t); r[e] = Math.max(0, Math.min(r[e] + r[e] * n, 0 === e ? 360 : 1)), r = rp(r), t.r = r[0], t.g = r[1], t.b = r[2] } } function Ev(t, e) { return t && Object.assign(e || {}, t) } function Mv(t) { var e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = Kr(t[3]))) : (e = Ev(t, { r: 0, g: 0, b: 0, a: 1 })).a = Kr(e.a), e } function jF(t) { return "r" === t.charAt(0) ? function ZF(t) { const e = LF.exec(t); let r, i, s, n = 255; if (e) { if (e[7] !== r) { const o = +e[7]; n = e[8] ? La(o) : br(255 * o, 0, 255) } return r = +e[1], i = +e[3], s = +e[5], r = 255 & (e[2] ? La(r) : br(r, 0, 255)), i = 255 & (e[4] ? La(i) : br(i, 0, 255)), s = 255 & (e[6] ? La(s) : br(s, 0, 255)), { r, g: i, b: s, a: n } } }(t) : function PF(t) { const e = xF.exec(t); let r, n = 255; if (!e) return; e[5] !== r && (n = e[6] ? La(+e[5]) : Kr(+e[5])); const i = Dv(+e[2]), s = +e[3] / 100, o = +e[4] / 100; return r = "hwb" === e[1] ? function IF(t, e, n) { return np(MF, t, e, n) }(i, s, o) : "hsv" === e[1] ? function AF(t, e, n) { return np(EF, t, e, n) }(i, s, o) : rp(i, s, o), { r: r[0], g: r[1], b: r[2], a: n } }(t) } class ro { constructor(e) { if (e instanceof ro) return e; const n = typeof e; let r; "object" === n ? r = Mv(e) : "string" === n && (r = function kF(t) { var n, e = t.length; return "#" === t[0] && (4 === e || 5 === e ? n = { r: 255 & 17 * fn[t[1]], g: 255 & 17 * fn[t[2]], b: 255 & 17 * fn[t[3]], a: 5 === e ? 17 * fn[t[4]] : 255 } : (7 === e || 9 === e) && (n = { r: fn[t[1]] << 4 | fn[t[2]], g: fn[t[3]] << 4 | fn[t[4]], b: fn[t[5]] << 4 | fn[t[6]], a: 9 === e ? fn[t[7]] << 4 | fn[t[8]] : 255 })), n }(e) || function NF(t) { x0 || (x0 = function FF() { const t = {}, e = Object.keys(xv), n = Object.keys(Cv); let r, i, s, o, a; for (r = 0; r < e.length; r++) { for (o = a = e[r], i = 0; i < n.length; i++)s = n[i], a = a.replace(s, Cv[s]); s = parseInt(xv[o], 16), t[a] = [s >> 16 & 255, s >> 8 & 255, 255 & s] } return t }(), x0.transparent = [0, 0, 0, 0]); const e = x0[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: 4 === e.length ? e[3] : 255 } }(e) || jF(e)), this._rgb = r, this._valid = !!r } get valid() { return this._valid } get rgb() { var e = Ev(this._rgb); return e && (e.a = Tr(e.a)), e } set rgb(e) { this._rgb = Mv(e) } rgbString() { return this._valid ? function VF(t) { return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${Tr(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) }(this._rgb) : void 0 } hexString() { return this._valid ? function CF(t) { var e = (t => C0(t.r) && C0(t.g) && C0(t.b) && C0(t.a))(t) ? vF : bF; return t ? "#" + e(t.r) + e(t.g) + e(t.b) + ((t, e) => t < 255 ? e(t) : "")(t.a, e) : void 0 }(this._rgb) : void 0 } hslString() { return this._valid ? function RF(t) { if (!t) return; const e = tp(t), n = e[0], r = Tv(e[1]), i = Tv(e[2]); return t.a < 255 ? `hsla(${n}, ${r}%, ${i}%, ${Tr(t.a)})` : `hsl(${n}, ${r}%, ${i}%)` }(this._rgb) : void 0 } mix(e, n) { if (e) { const r = this.rgb, i = e.rgb; let s; const o = n === s ? .5 : n, a = 2 * o - 1, l = r.a - i.a, u = ((a * l == -1 ? a : (a + l) / (1 + a * l)) + 1) / 2; s = 1 - u, r.r = 255 & u * r.r + s * i.r + .5, r.g = 255 & u * r.g + s * i.g + .5, r.b = 255 & u * r.b + s * i.b + .5, r.a = o * r.a + (1 - o) * i.a, this.rgb = r } return this } interpolate(e, n) { return e && (this._rgb = function BF(t, e, n) { const r = no(Tr(t.r)), i = no(Tr(t.g)), s = no(Tr(t.b)); return { r: Kr(ip(r + n * (no(Tr(e.r)) - r))), g: Kr(ip(i + n * (no(Tr(e.g)) - i))), b: Kr(ip(s + n * (no(Tr(e.b)) - s))), a: t.a + n * (e.a - t.a) } }(this._rgb, e._rgb, n)), this } clone() { return new ro(this.rgb) } alpha(e) { return this._rgb.a = Kr(e), this } clearer(e) { return this._rgb.a *= 1 - e, this } greyscale() { const e = this._rgb, n = to(.3 * e.r + .59 * e.g + .11 * e.b); return e.r = e.g = e.b = n, this } opaquer(e) { return this._rgb.a *= 1 + e, this } negate() { const e = this._rgb; return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this } lighten(e) { return E0(this._rgb, 2, e), this } darken(e) { return E0(this._rgb, 2, -e), this } saturate(e) { return E0(this._rgb, 1, e), this } desaturate(e) { return E0(this._rgb, 1, -e), this } rotate(e) { return function OF(t, e) { var n = tp(t); n[0] = Dv(n[0] + e), n = rp(n), t.r = n[0], t.g = n[1], t.b = n[2] }(this._rgb, e), this } } function kr() { } const HF = (() => { let t = 0; return () => t++ })(); function de(t) { return null == t } function De(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return "[object" === e.slice(0, 7) && "Array]" === e.slice(-6) } function se(t) { return null !== t && "[object Object]" === Object.prototype.toString.call(t) } function Ne(t) { return ("number" == typeof t || t instanceof Number) && isFinite(+t) } function Xt(t, e) { return Ne(t) ? t : e } function B(t, e) { return void 0 === t ? e : t } const Sv = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t; function z(t, e, n) { if (t && "function" == typeof t.call) return t.apply(n, e) } function re(t, e, n, r) { let i, s, o; if (De(t)) if (s = t.length, r) for (i = s - 1; i >= 0; i--)e.call(n, t[i], i); else for (i = 0; i < s; i++)e.call(n, t[i], i); else if (se(t)) for (o = Object.keys(t), s = o.length, i = 0; i < s; i++)e.call(n, t[o[i]], o[i]) } function M0(t, e) { let n, r, i, s; if (!t || !e || t.length !== e.length) return !1; for (n = 0, r = t.length; n < r; ++n)if (i = t[n], s = e[n], i.datasetIndex !== s.datasetIndex || i.index !== s.index) return !1; return !0 } function S0(t) { if (De(t)) return t.map(S0); if (se(t)) { const e = Object.create(null), n = Object.keys(t), r = n.length; let i = 0; for (; i < r; ++i)e[n[i]] = S0(t[n[i]]); return e } return t } function Iv(t) { return -1 === ["__proto__", "prototype", "constructor"].indexOf(t) } function $F(t, e, n, r) { if (!Iv(t)) return; const i = e[t], s = n[t]; se(i) && se(s) ? Za(i, s, r) : e[t] = S0(s) } function Za(t, e, n) { const r = De(e) ? e : [e], i = r.length; if (!se(t)) return t; const s = (n = n || {}).merger || $F; let o; for (let a = 0; a < i; ++a) { if (o = r[a], !se(o)) continue; const l = Object.keys(o); for (let u = 0, c = l.length; u < c; ++u)s(l[u], t, o, n) } return t } function Va(t, e) { return Za(t, e, { merger: zF }) } function zF(t, e, n) { if (!Iv(t)) return; const r = e[t], i = n[t]; se(r) && se(i) ? Va(r, i) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = S0(i)) } const Av = { "": t => t, x: t => t.x, y: t => t.y }; function Jr(t, e) { return (Av[e] || (Av[e] = function qF(t) { const e = function WF(t) { const e = t.split("."), n = []; let r = ""; for (const i of e) r += i, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = ""); return n }(t); return n => { for (const r of e) { if ("" === r) break; n = n && n[r] } return n } }(e)))(t) } function sp(t) { return t.charAt(0).toUpperCase() + t.slice(1) } const Ba = t => void 0 !== t, ei = t => "function" == typeof t, Pv = (t, e) => { if (t.size !== e.size) return !1; for (const n of t) if (!e.has(n)) return !1; return !0 }, Ee = Math.PI, Ce = 2 * Ee, YF = Ce + Ee, I0 = Number.POSITIVE_INFINITY, XF = Ee / 180, Le = Ee / 2, Ri = Ee / 4, Ov = 2 * Ee / 3, ti = Math.log10, hn = Math.sign; function ja(t, e, n) { return Math.abs(t - e) < n } function Rv(t) { const e = Math.round(t); t = ja(t, e, t / 1e3) ? e : t; const n = Math.pow(10, Math.floor(ti(t))), r = t / n; return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n } function io(t) { return !isNaN(parseFloat(t)) && isFinite(t) } function Fv(t, e, n) { let r, i, s; for (r = 0, i = t.length; r < i; r++)s = t[r][n], isNaN(s) || (e.min = Math.min(e.min, s), e.max = Math.max(e.max, s)) } function Ln(t) { return t * (Ee / 180) } function op(t) { return t * (180 / Ee) } function Nv(t) { if (!Ne(t)) return; let e = 1, n = 0; for (; Math.round(t * e) / e !== t;)e *= 10, n++; return n } function Lv(t, e) { const n = e.x - t.x, r = e.y - t.y, i = Math.sqrt(n * n + r * r); let s = Math.atan2(r, n); return s < -.5 * Ee && (s += Ce), { angle: s, distance: i } } function ap(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function JF(t, e) { return (t - e + YF) % Ce - Ee } function Qt(t) { return (t % Ce + Ce) % Ce } function Ha(t, e, n, r) { const i = Qt(t), s = Qt(e), o = Qt(n), a = Qt(s - i), l = Qt(o - i), u = Qt(i - s), c = Qt(i - o); return i === s || i === o || r && s === o || a > l && u < c } function at(t, e, n) { return Math.max(e, Math.min(n, t)) } function Dr(t, e, n, r = 1e-6) { return t >= Math.min(e, n) - r && t <= Math.max(e, n) + r } function lp(t, e, n) { n = n || (o => t[o] < e); let s, r = t.length - 1, i = 0; for (; r - i > 1;)s = i + r >> 1, n(s) ? i = s : r = s; return { lo: i, hi: r } } const Cr = (t, e, n, r) => lp(t, n, r ? i => { const s = t[i][e]; return s < n || s === n && t[i + 1][e] === n } : i => t[i][e] < n), tN = (t, e, n) => lp(t, n, r => t[r][e] >= n), Zv = ["push", "pop", "shift", "splice", "unshift"]; function Vv(t, e) { const n = t._chartjs; if (!n) return; const r = n.listeners, i = r.indexOf(e); -1 !== i && r.splice(i, 1), !(r.length > 0) && (Zv.forEach(s => { delete t[s] }), delete t._chartjs) } function Bv(t) { const e = new Set(t); return e.size === t.length ? t : Array.from(e) } const jv = "undefined" == typeof window ? function (t) { return t() } : window.requestAnimationFrame; function Hv(t, e) { let n = [], r = !1; return function (...i) { n = i, r || (r = !0, jv.call(window, () => { r = !1, t.apply(e, n) })) } } const up = t => "start" === t ? "left" : "end" === t ? "right" : "center", yt = (t, e, n) => "start" === t ? e : "end" === t ? n : (e + n) / 2; function Uv(t, e, n) { const r = e.length; let i = 0, s = r; if (t._sorted) { const { iScale: o, _parsed: a } = t, l = o.axis, { min: u, max: c, minDefined: d, maxDefined: f } = o.getUserBounds(); d && (i = at(Math.min(Cr(a, o.axis, u).lo, n ? r : Cr(e, l, o.getPixelForValue(u)).lo), 0, r - 1)), s = f ? at(Math.max(Cr(a, o.axis, c, !0).hi + 1, n ? 0 : Cr(e, l, o.getPixelForValue(c), !0).hi + 1), i, r) - i : r - i } return { start: i, count: s } } function $v(t) { const { xScale: e, yScale: n, _scaleRanges: r } = t, i = { xmin: e.min, xmax: e.max, ymin: n.min, ymax: n.max }; if (!r) return t._scaleRanges = i, !0; const s = r.xmin !== e.min || r.xmax !== e.max || r.ymin !== n.min || r.ymax !== n.max; return Object.assign(r, i), s } const A0 = t => 0 === t || 1 === t, zv = (t, e, n) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * Ce / n), Wv = (t, e, n) => Math.pow(2, -10 * t) * Math.sin((t - e) * Ce / n) + 1, Ua = { linear: t => t, easeInQuad: t => t * t, easeOutQuad: t => -t * (t - 2), easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1), easeInCubic: t => t * t * t, easeOutCubic: t => (t -= 1) * t * t + 1, easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2), easeInQuart: t => t * t * t * t, easeOutQuart: t => -((t -= 1) * t * t * t - 1), easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2), easeInQuint: t => t * t * t * t * t, easeOutQuint: t => (t -= 1) * t * t * t * t + 1, easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2), easeInSine: t => 1 - Math.cos(t * Le), easeOutSine: t => Math.sin(t * Le), easeInOutSine: t => -.5 * (Math.cos(Ee * t) - 1), easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)), easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t), easeInOutExpo: t => A0(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))), easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1), easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t), easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1), easeInElastic: t => A0(t) ? t : zv(t, .075, .3), easeOutElastic: t => A0(t) ? t : Wv(t, .075, .3), easeInOutElastic: t => A0(t) ? t : t < .5 ? .5 * zv(2 * t, .1125, .45) : .5 + .5 * Wv(2 * t - 1, .1125, .45), easeInBack: t => t * t * (2.70158 * t - 1.70158), easeOutBack: t => (t -= 1) * t * (2.70158 * t + 1.70158) + 1, easeInOutBack(t) { let e = 1.70158; return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2) }, easeInBounce: t => 1 - Ua.easeOutBounce(1 - t), easeOutBounce: t => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, easeInOutBounce: t => t < .5 ? .5 * Ua.easeInBounce(2 * t) : .5 * Ua.easeOutBounce(2 * t - 1) + .5 }; function cp(t) { if (t && "object" == typeof t) { const e = t.toString(); return "[object CanvasPattern]" === e || "[object CanvasGradient]" === e } return !1 } function qv(t) { return cp(t) ? t : new ro(t) } function dp(t) { return cp(t) ? t : new ro(t).saturate(.5).darken(.1).hexString() } const oN = ["x", "y", "borderWidth", "radius", "tension"], aN = ["color", "borderColor", "backgroundColor"], Gv = new Map; function $a(t, e, n) { return function cN(t, e) { e = e || {}; const n = t + JSON.stringify(e); let r = Gv.get(n); return r || (r = new Intl.NumberFormat(t, e), Gv.set(n, r)), r }(e, n).format(t) } const Yv = { values: t => De(t) ? t : "" + t, numeric(t, e, n) { if (0 === t) return "0"; const r = this.chart.options.locale; let i, s = t; if (n.length > 1) { const u = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value)); (u < 1e-4 || u > 1e15) && (i = "scientific"), s = function dN(t, e) { let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value; return Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t)), n }(t, n) } const o = ti(Math.abs(s)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = { notation: i, minimumFractionDigits: a, maximumFractionDigits: a }; return Object.assign(l, this.options.ticks.format), $a(t, r, l) }, logarithmic(t, e, n) { if (0 === t) return "0"; const r = n[e].significand || t / Math.pow(10, Math.floor(ti(t))); return [1, 2, 3, 5, 10, 15].includes(r) || e > .8 * n.length ? Yv.numeric.call(this, t, e, n) : "" } }; var P0 = { formatters: Yv }; const Fi = Object.create(null), fp = Object.create(null); function za(t, e) { if (!e) return t; const n = e.split("."); for (let r = 0, i = n.length; r < i; ++r) { const s = n[r]; t = t[s] || (t[s] = Object.create(null)) } return t } function hp(t, e, n) { return "string" == typeof e ? Za(za(t, e), n) : Za(za(t, ""), e) } class hN { constructor(e, n) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = r => r.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (r, i) => dp(i.backgroundColor), this.hoverBorderColor = (r, i) => dp(i.borderColor), this.hoverColor = (r, i) => dp(i.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(n) } set(e, n) { return hp(this, e, n) } get(e) { return za(this, e) } describe(e, n) { return hp(fp, e, n) } override(e, n) { return hp(Fi, e, n) } route(e, n, r, i) { const s = za(this, e), o = za(this, r), a = "_" + n; Object.defineProperties(s, { [a]: { value: s[n], writable: !0 }, [n]: { enumerable: !0, get() { const l = this[a], u = o[i]; return se(l) ? Object.assign({}, u, l) : B(l, u) }, set(l) { this[a] = l } } }) } apply(e) { e.forEach(n => n(this)) } } var Ze = new hN({ _scriptable: t => !t.startsWith("on"), _indexable: t => "events" !== t, hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [function lN(t) { t.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), t.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: e => "onProgress" !== e && "onComplete" !== e && "fn" !== e }), t.set("animations", { colors: { type: "color", properties: aN }, numbers: { type: "number", properties: oN } }), t.describe("animations", { _fallback: "animation" }), t.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: e => 0 | e } } } }) }, function uN(t) { t.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) }, function fN(t) { t.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (e, n) => n.lineWidth, tickColor: (e, n) => n.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: P0.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", { _fallback: !1, _scriptable: e => !e.startsWith("before") && !e.startsWith("after") && "callback" !== e && "parser" !== e, _indexable: e => "borderDash" !== e && "tickBorderDash" !== e && "dash" !== e }), t.describe("scales", { _fallback: "scale" }), t.describe("scale.ticks", { _scriptable: e => "backdropPadding" !== e && "callback" !== e, _indexable: e => "backdropPadding" !== e }) }]); function O0(t, e, n, r, i) { let s = e[i]; return s || (s = e[i] = t.measureText(i).width, n.push(i)), s > r && (r = s), r } function gN(t, e, n, r) { let i = (r = r || {}).data = r.data || {}, s = r.garbageCollect = r.garbageCollect || []; r.font !== e && (i = r.data = {}, s = r.garbageCollect = [], r.font = e), t.save(), t.font = e; let o = 0; const a = n.length; let l, u, c, d, f; for (l = 0; l < a; l++)if (d = n[l], null == d || De(d)) { if (De(d)) for (u = 0, c = d.length; u < c; u++)f = d[u], null != f && !De(f) && (o = O0(t, i, s, o, f)) } else o = O0(t, i, s, o, d); t.restore(); const h = s.length / 2; if (h > n.length) { for (l = 0; l < h; l++)delete i[s[l]]; s.splice(0, h) } return o } function Ni(t, e, n) { const r = t.currentDevicePixelRatio, i = 0 !== n ? Math.max(n / 2, .5) : 0; return Math.round((e - i) * r) / r + i } function Xv(t, e) { (e = e || t.getContext("2d")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore() } function pp(t, e, n, r) { Qv(t, e, n, r, null) } function Qv(t, e, n, r, i) { let s, o, a, l, u, c, d, f; const h = e.pointStyle, p = e.rotation, m = e.radius; let y = (p || 0) * XF; if (h && "object" == typeof h && (s = h.toString(), "[object HTMLImageElement]" === s || "[object HTMLCanvasElement]" === s)) return t.save(), t.translate(n, r), t.rotate(y), t.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), void t.restore(); if (!(isNaN(m) || m <= 0)) { switch (t.beginPath(), h) { default: i ? t.ellipse(n, r, i / 2, m, 0, 0, Ce) : t.arc(n, r, m, 0, Ce), t.closePath(); break; case "triangle": c = i ? i / 2 : m, t.moveTo(n + Math.sin(y) * c, r - Math.cos(y) * m), y += Ov, t.lineTo(n + Math.sin(y) * c, r - Math.cos(y) * m), y += Ov, t.lineTo(n + Math.sin(y) * c, r - Math.cos(y) * m), t.closePath(); break; case "rectRounded": u = .516 * m, l = m - u, o = Math.cos(y + Ri) * l, d = Math.cos(y + Ri) * (i ? i / 2 - u : l), a = Math.sin(y + Ri) * l, f = Math.sin(y + Ri) * (i ? i / 2 - u : l), t.arc(n - d, r - a, u, y - Ee, y - Le), t.arc(n + f, r - o, u, y - Le, y), t.arc(n + d, r + a, u, y, y + Le), t.arc(n - f, r + o, u, y + Le, y + Ee), t.closePath(); break; case "rect": if (!p) { l = Math.SQRT1_2 * m, c = i ? i / 2 : l, t.rect(n - c, r - l, 2 * c, 2 * l); break } y += Ri; case "rectRot": d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, f = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + f, r - o), t.lineTo(n + d, r + a), t.lineTo(n - f, r + o), t.closePath(); break; case "crossRot": y += Ri; case "cross": d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, f = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + f, r - o), t.lineTo(n - f, r + o); break; case "star": d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, f = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + f, r - o), t.lineTo(n - f, r + o), y += Ri, d = Math.cos(y) * (i ? i / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, f = Math.sin(y) * (i ? i / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + f, r - o), t.lineTo(n - f, r + o); break; case "line": o = i ? i / 2 : Math.cos(y) * m, a = Math.sin(y) * m, t.moveTo(n - o, r - a), t.lineTo(n + o, r + a); break; case "dash": t.moveTo(n, r), t.lineTo(n + Math.cos(y) * (i ? i / 2 : m), r + Math.sin(y) * m); break; case !1: t.closePath() }t.fill(), e.borderWidth > 0 && t.stroke() } } function xr(t, e, n) { return n = n || .5, !e || t && t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n } function R0(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function F0(t) { t.restore() } function mN(t, e, n, r, i) { if (!e) return t.lineTo(n.x, n.y); if ("middle" === i) { const s = (e.x + n.x) / 2; t.lineTo(s, e.y), t.lineTo(s, n.y) } else "after" === i != !!r ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y); t.lineTo(n.x, n.y) } function _N(t, e, n, r) { if (!e) return t.lineTo(n.x, n.y); t.bezierCurveTo(r ? e.cp1x : e.cp2x, r ? e.cp1y : e.cp2y, r ? n.cp2x : n.cp1x, r ? n.cp2y : n.cp1y, n.x, n.y) } function wN(t, e, n, r, i) { if (i.strikethrough || i.underline) { const s = t.measureText(r), o = e - s.actualBoundingBoxLeft, a = e + s.actualBoundingBoxRight, l = n - s.actualBoundingBoxAscent, u = n + s.actualBoundingBoxDescent, c = i.strikethrough ? (l + u) / 2 : u; t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = i.decorationWidth || 2, t.moveTo(o, c), t.lineTo(a, c), t.stroke() } } function vN(t, e) { const n = t.fillStyle; t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = n } function Li(t, e, n, r, i, s = {}) { const o = De(e) ? e : [e], a = s.strokeWidth > 0 && "" !== s.strokeColor; let l, u; for (t.save(), t.font = i.string, function yN(t, e) { e.translation && t.translate(e.translation[0], e.translation[1]), de(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline) }(t, s), l = 0; l < o.length; ++l)u = o[l], s.backdrop && vN(t, s.backdrop), a && (s.strokeColor && (t.strokeStyle = s.strokeColor), de(s.strokeWidth) || (t.lineWidth = s.strokeWidth), t.strokeText(u, n, r, s.maxWidth)), t.fillText(u, n, r, s.maxWidth), wN(t, n, r, u, s), r += Number(i.lineHeight); t.restore() } function Wa(t, e) { const { x: n, y: r, w: i, h: s, radius: o } = e; t.arc(n + o.topLeft, r + o.topLeft, o.topLeft, -Le, Ee, !0), t.lineTo(n, r + s - o.bottomLeft), t.arc(n + o.bottomLeft, r + s - o.bottomLeft, o.bottomLeft, Ee, Le, !0), t.lineTo(n + i - o.bottomRight, r + s), t.arc(n + i - o.bottomRight, r + s - o.bottomRight, o.bottomRight, Le, 0, !0), t.lineTo(n + i, r + o.topRight), t.arc(n + i - o.topRight, r + o.topRight, o.topRight, 0, -Le, !0), t.lineTo(n + o.topLeft, r) } const bN = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, TN = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function kN(t, e) { const n = ("" + t).match(bN); if (!n || "normal" === n[1]) return 1.2 * e; switch (t = +n[2], n[3]) { case "px": return t; case "%": t /= 100 }return e * t } const DN = t => +t || 0; function gp(t, e) { const n = {}, r = se(e), i = r ? Object.keys(e) : e, s = se(t) ? r ? o => B(t[o], t[e[o]]) : o => t[o] : () => t; for (const o of i) n[o] = DN(s(o)); return n } function Kv(t) { return gp(t, { top: "y", right: "x", bottom: "y", left: "x" }) } function Zi(t) { return gp(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function wt(t) { const e = Kv(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function tt(t, e) { let n = B((t = t || {}).size, (e = e || Ze.font).size); "string" == typeof n && (n = parseInt(n, 10)); let r = B(t.style, e.style); r && !("" + r).match(TN) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0); const i = { family: B(t.family, e.family), lineHeight: kN(B(t.lineHeight, e.lineHeight), n), size: n, style: r, weight: B(t.weight, e.weight), string: "" }; return i.string = function pN(t) { return !t || de(t.size) || de(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family }(i), i } function qa(t, e, n, r) { let s, o, a, i = !0; for (s = 0, o = t.length; s < o; ++s)if (a = t[s], void 0 !== a && (void 0 !== e && "function" == typeof a && (a = a(e), i = !1), void 0 !== n && De(a) && (a = a[n % a.length], i = !1), void 0 !== a)) return r && !i && (r.cacheable = !1), a } function ni(t, e) { return Object.assign(Object.create(t), e) } function mp(t, e = [""], n, r, i = (() => t[0])) { const s = n || t; void 0 === r && (r = rb("_fallback", t)); const o = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: t, _rootScopes: s, _fallback: r, _getTarget: i, override: a => mp([a, ...t], e, s, r) }; return new Proxy(o, { deleteProperty: (a, l) => (delete a[l], delete a._keys, delete t[0][l], !0), get: (a, l) => eb(a, l, () => function ON(t, e, n, r) { let i; for (const s of e) if (i = rb(xN(s, t), n), void 0 !== i) return _p(t, i) ? yp(n, r, t, i) : i }(l, e, t, a)), getOwnPropertyDescriptor: (a, l) => Reflect.getOwnPropertyDescriptor(a._scopes[0], l), getPrototypeOf: () => Reflect.getPrototypeOf(t[0]), has: (a, l) => ib(a).includes(l), ownKeys: a => ib(a), set(a, l, u) { const c = a._storage || (a._storage = i()); return a[l] = c[l] = u, delete a._keys, !0 } }) } function so(t, e, n, r) { const i = { _cacheable: !1, _proxy: t, _context: e, _subProxy: n, _stack: new Set, _descriptors: Jv(t, r), setContext: s => so(t, s, n, r), override: s => so(t.override(s), e, n, r) }; return new Proxy(i, { deleteProperty: (s, o) => (delete s[o], delete t[o], !0), get: (s, o, a) => eb(s, o, () => function EN(t, e, n) { const { _proxy: r, _context: i, _subProxy: s, _descriptors: o } = t; let a = r[e]; return ei(a) && o.isScriptable(e) && (a = function MN(t, e, n, r) { const { _proxy: i, _context: s, _subProxy: o, _stack: a } = n; if (a.has(t)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t); a.add(t); let l = e(s, o || r); return a.delete(t), _p(t, l) && (l = yp(i._scopes, i, t, l)), l }(e, a, t, n)), De(a) && a.length && (a = function SN(t, e, n, r) { const { _proxy: i, _context: s, _subProxy: o, _descriptors: a } = n; if (void 0 !== s.index && r(t)) return e[s.index % e.length]; if (se(e[0])) { const l = e, u = i._scopes.filter(c => c !== l); e = []; for (const c of l) { const d = yp(u, i, t, c); e.push(so(d, s, o && o[t], a)) } } return e }(e, a, t, o.isIndexable)), _p(e, a) && (a = so(a, i, s && s[e], o)), a }(s, o, a)), getOwnPropertyDescriptor: (s, o) => s._descriptors.allKeys ? Reflect.has(t, o) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(t, o), getPrototypeOf: () => Reflect.getPrototypeOf(t), has: (s, o) => Reflect.has(t, o), ownKeys: () => Reflect.ownKeys(t), set: (s, o, a) => (t[o] = a, delete s[o], !0) }) } function Jv(t, e = { scriptable: !0, indexable: !0 }) { const { _scriptable: n = e.scriptable, _indexable: r = e.indexable, _allKeys: i = e.allKeys } = t; return { allKeys: i, scriptable: n, indexable: r, isScriptable: ei(n) ? n : () => n, isIndexable: ei(r) ? r : () => r } } const xN = (t, e) => t ? t + sp(e) : e, _p = (t, e) => se(e) && "adapters" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object); function eb(t, e, n) { if (Object.prototype.hasOwnProperty.call(t, e)) return t[e]; const r = n(); return t[e] = r, r } function tb(t, e, n) { return ei(t) ? t(e, n) : t } const IN = (t, e) => !0 === t ? e : "string" == typeof t ? Jr(e, t) : void 0; function AN(t, e, n, r, i) { for (const s of e) { const o = IN(n, s); if (o) { t.add(o); const a = tb(o._fallback, n, i); if (void 0 !== a && a !== n && a !== r) return a } else if (!1 === o && void 0 !== r && n !== r) return null } return !1 } function yp(t, e, n, r) { const i = e._rootScopes, s = tb(e._fallback, n, r), o = [...t, ...i], a = new Set; a.add(r); let l = nb(a, o, n, s || n, r); return null !== l && (void 0 === s || s === n || (l = nb(a, o, s, l, r), null !== l)) && mp(Array.from(a), [""], i, s, () => function PN(t, e, n) { const r = t._getTarget(); e in r || (r[e] = {}); const i = r[e]; return De(i) && se(n) ? n : i || {} }(e, n, r)) } function nb(t, e, n, r, i) { for (; n;)n = AN(t, e, n, r, i); return n } function rb(t, e) { for (const n of e) { if (!n) continue; const r = n[t]; if (void 0 !== r) return r } } function ib(t) { let e = t._keys; return e || (e = t._keys = function RN(t) { const e = new Set; for (const n of t) for (const r of Object.keys(n).filter(i => !i.startsWith("_"))) e.add(r); return Array.from(e) }(t._scopes)), e } function sb(t, e, n, r) { const { iScale: i } = t, { key: s = "r" } = this._parsing, o = new Array(r); let a, l, u, c; for (a = 0, l = r; a < l; ++a)u = a + n, c = e[u], o[a] = { r: i.parse(Jr(c, s), u) }; return o } const FN = Number.EPSILON || 1e-14, oo = (t, e) => e < t.length && !t[e].skip && t[e], ob = t => "x" === t ? "y" : "x"; function NN(t, e, n, r) { const i = t.skip ? e : t, s = e, o = n.skip ? e : n, a = ap(s, i), l = ap(o, s); let u = a / (a + l), c = l / (a + l); u = isNaN(u) ? 0 : u, c = isNaN(c) ? 0 : c; const d = r * u, f = r * c; return { previous: { x: s.x - d * (o.x - i.x), y: s.y - d * (o.y - i.y) }, next: { x: s.x + f * (o.x - i.x), y: s.y + f * (o.y - i.y) } } } function N0(t, e, n) { return Math.max(Math.min(t, n), e) } function jN(t, e, n, r, i) { let s, o, a, l; if (e.spanGaps && (t = t.filter(u => !u.skip)), "monotone" === e.cubicInterpolationMode) !function VN(t, e = "x") { const n = ob(e), r = t.length, i = Array(r).fill(0), s = Array(r); let o, a, l, u = oo(t, 0); for (o = 0; o < r; ++o)if (a = l, l = u, u = oo(t, o + 1), l) { if (u) { const c = u[e] - l[e]; i[o] = 0 !== c ? (u[n] - l[n]) / c : 0 } s[o] = a ? u ? hn(i[o - 1]) !== hn(i[o]) ? 0 : (i[o - 1] + i[o]) / 2 : i[o - 1] : i[o] } (function LN(t, e, n) { const r = t.length; let i, s, o, a, l, u = oo(t, 0); for (let c = 0; c < r - 1; ++c)if (l = u, u = oo(t, c + 1), l && u) { if (ja(e[c], 0, FN)) { n[c] = n[c + 1] = 0; continue } i = n[c] / e[c], s = n[c + 1] / e[c], a = Math.pow(i, 2) + Math.pow(s, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), n[c] = i * o * e[c], n[c + 1] = s * o * e[c]) } })(t, i, s), function ZN(t, e, n = "x") { const r = ob(n), i = t.length; let s, o, a, l = oo(t, 0); for (let u = 0; u < i; ++u) { if (o = a, a = l, l = oo(t, u + 1), !a) continue; const c = a[n], d = a[r]; o && (s = (c - o[n]) / 3, a[`cp1${n}`] = c - s, a[`cp1${r}`] = d - s * e[u]), l && (s = (l[n] - c) / 3, a[`cp2${n}`] = c + s, a[`cp2${r}`] = d + s * e[u]) } }(t, s, e) }(t, i); else { let u = r ? t[t.length - 1] : t[0]; for (s = 0, o = t.length; s < o; ++s)a = t[s], l = NN(u, a, t[Math.min(s + 1, o - (r ? 0 : 1)) % o], e.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, u = a } e.capBezierPoints && function BN(t, e) { let n, r, i, s, o, a = xr(t[0], e); for (n = 0, r = t.length; n < r; ++n)o = s, s = a, a = n < r - 1 && xr(t[n + 1], e), s && (i = t[n], o && (i.cp1x = N0(i.cp1x, e.left, e.right), i.cp1y = N0(i.cp1y, e.top, e.bottom)), a && (i.cp2x = N0(i.cp2x, e.left, e.right), i.cp2y = N0(i.cp2y, e.top, e.bottom))) }(t, n) } function ab() { return "undefined" != typeof window && "undefined" != typeof document } function wp(t) { let e = t.parentNode; return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e } function L0(t, e, n) { let r; return "string" == typeof t ? (r = parseInt(t, 10), -1 !== t.indexOf("%") && (r = r / 100 * e.parentNode[n])) : r = t, r } const Z0 = t => t.ownerDocument.defaultView.getComputedStyle(t, null), UN = ["top", "right", "bottom", "left"]; function Vi(t, e, n) { const r = {}; n = n ? "-" + n : ""; for (let i = 0; i < 4; i++) { const s = UN[i]; r[s] = parseFloat(t[e + "-" + s + n]) || 0 } return r.width = r.left + r.right, r.height = r.top + r.bottom, r } function rr(t, e) { if ("native" in t) return t; const { canvas: n, currentDevicePixelRatio: r } = e, i = Z0(n), s = "border-box" === i.boxSizing, o = Vi(i, "padding"), a = Vi(i, "border", "width"), { x: l, y: u, box: c } = function zN(t, e) { const n = t.touches, r = n && n.length ? n[0] : t, { offsetX: i, offsetY: s } = r; let a, l, o = !1; if (((t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot))(i, s, t.target)) a = i, l = s; else { const u = e.getBoundingClientRect(); a = r.clientX - u.left, l = r.clientY - u.top, o = !0 } return { x: a, y: l, box: o } }(t, n), d = o.left + (c && a.left), f = o.top + (c && a.top); let { width: h, height: p } = e; return s && (h -= o.width + a.width, p -= o.height + a.height), { x: Math.round((l - d) / h * n.width / r), y: Math.round((u - f) / p * n.height / r) } } const V0 = t => Math.round(10 * t) / 10; function lb(t, e, n) { const r = e || 1, i = Math.floor(t.height * r), s = Math.floor(t.width * r); t.height = Math.floor(t.height), t.width = Math.floor(t.width); const o = t.canvas; return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${t.height}px`, o.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== r || o.height !== i || o.width !== s) && (t.currentDevicePixelRatio = r, o.height = i, o.width = s, t.ctx.setTransform(r, 0, 0, r, 0, 0), !0) } const GN = function () { let t = !1; try { const e = { get passive() { return t = !0, !1 } }; window.addEventListener("test", null, e), window.removeEventListener("test", null, e) } catch (e) { } return t }(); function ub(t, e) { const n = function HN(t, e) { return Z0(t).getPropertyValue(e) }(t, e), r = n && n.match(/^(\d+)(\.\d+)?px$/); return r ? +r[1] : void 0 } function Bi(t, e, n, r) { return { x: t.x + n * (e.x - t.x), y: t.y + n * (e.y - t.y) } } function YN(t, e, n, r) { return { x: t.x + n * (e.x - t.x), y: "middle" === r ? n < .5 ? t.y : e.y : "after" === r ? n < 1 ? t.y : e.y : n > 0 ? e.y : t.y } } function XN(t, e, n, r) { const i = { x: t.cp2x, y: t.cp2y }, s = { x: e.cp1x, y: e.cp1y }, o = Bi(t, i, n), a = Bi(i, s, n), l = Bi(s, e, n), u = Bi(o, a, n), c = Bi(a, l, n); return Bi(u, c, n) } function ao(t, e, n) { return t ? function (t, e) { return { x: n => t + t + e - n, setWidth(n) { e = n }, textAlign: n => "center" === n ? n : "right" === n ? "left" : "right", xPlus: (n, r) => n - r, leftForLtr: (n, r) => n - r } }(e, n) : { x: t => t, setWidth(t) { }, textAlign: t => t, xPlus: (t, e) => t + e, leftForLtr: (t, e) => t } } function cb(t, e) { let n, r; ("ltr" === e || "rtl" === e) && (n = t.canvas.style, r = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", e, "important"), t.prevTextDirection = r) } function db(t, e) { void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1])) } function fb(t) { return "angle" === t ? { between: Ha, compare: JF, normalize: Qt } : { between: Dr, compare: (e, n) => e - n, normalize: e => e } } function hb({ start: t, end: e, count: n, loop: r, style: i }) { return { start: t % n, end: e % n, loop: r && (e - t + 1) % n == 0, style: i } } function pb(t, e, n) { if (!n) return [t]; const { property: r, start: i, end: s } = n, o = e.length, { compare: a, between: l, normalize: u } = fb(r), { start: c, end: d, loop: f, style: h } = function JN(t, e, n) { const { property: r, start: i, end: s } = n, { between: o, normalize: a } = fb(r), l = e.length; let f, h, { start: u, end: c, loop: d } = t; if (d) { for (u += l, c += l, f = 0, h = l; f < h && o(a(e[u % l][r]), i, s); ++f)u--, c--; u %= l, c %= l } return c < u && (c += l), { start: u, end: c, loop: d, style: t.style } }(t, e, n), p = []; let v, w, T, m = !1, y = null; for (let A = c, F = c; A <= d; ++A)w = e[A % o], !w.skip && (v = u(w[r]), v !== T && (m = l(v, i, s), null === y && (m || l(i, T, v) && 0 !== a(i, T)) && (y = 0 === a(v, i) ? A : F), null !== y && (!m || 0 === a(s, v) || l(s, T, v)) && (p.push(hb({ start: y, end: A, loop: f, count: o, style: h })), y = null), F = A, T = v)); return null !== y && p.push(hb({ start: y, end: d, loop: f, count: o, style: h })), p } function gb(t, e) { const n = [], r = t.segments; for (let i = 0; i < r.length; i++) { const s = pb(r[i], t.points, e); s.length && n.push(...s) } return n } function _b(t) { return { backgroundColor: t.backgroundColor, borderCapStyle: t.borderCapStyle, borderDash: t.borderDash, borderDashOffset: t.borderDashOffset, borderJoinStyle: t.borderJoinStyle, borderWidth: t.borderWidth, borderColor: t.borderColor } } function i4(t, e) { if (!e) return !1; const n = [], r = function (i, s) { return cp(s) ? (n.includes(s) || n.push(s), n.indexOf(s)) : s }; return JSON.stringify(t, r) !== JSON.stringify(e, r) } class s4 { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(e, n, r, i) { const o = n.duration; n.listeners[i].forEach(a => a({ chart: e, initial: n.initial, numSteps: o, currentStep: Math.min(r - n.start, o) })) } _refresh() { this._request || (this._running = !0, this._request = jv.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(e = Date.now()) { let n = 0; this._charts.forEach((r, i) => { if (!r.running || !r.items.length) return; const s = r.items; let l, o = s.length - 1, a = !1; for (; o >= 0; --o)l = s[o], l._active ? (l._total > r.duration && (r.duration = l._total), l.tick(e), a = !0) : (s[o] = s[s.length - 1], s.pop()); a && (i.draw(), this._notify(i, r, e, "progress")), s.length || (r.running = !1, this._notify(i, r, e, "complete"), r.initial = !1), n += s.length }), this._lastDate = e, 0 === n && (this._running = !1) } _getAnims(e) { const n = this._charts; let r = n.get(e); return r || (r = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, n.set(e, r)), r } listen(e, n, r) { this._getAnims(e).listeners[n].push(r) } add(e, n) { !n || !n.length || this._getAnims(e).items.push(...n) } has(e) { return this._getAnims(e).items.length > 0 } start(e) { const n = this._charts.get(e); !n || (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((r, i) => Math.max(r, i._duration), 0), this._refresh()) } running(e) { if (!this._running) return !1; const n = this._charts.get(e); return !(!n || !n.running || !n.items.length) } stop(e) { const n = this._charts.get(e); if (!n || !n.items.length) return; const r = n.items; let i = r.length - 1; for (; i >= 0; --i)r[i].cancel(); n.items = [], this._notify(e, n, Date.now(), "complete") } remove(e) { return this._charts.delete(e) } } var Er = new s4; const yb = "transparent", o4 = { boolean: (t, e, n) => n > .5 ? e : t, color(t, e, n) { const r = qv(t || yb), i = r.valid && qv(e || yb); return i && i.valid ? i.mix(r, n).hexString() : e }, number: (t, e, n) => t + (e - t) * n }; class a4 { constructor(e, n, r, i) { const s = n[r]; i = qa([e.to, i, s, e.from]); const o = qa([e.from, s, i]); this._active = !0, this._fn = e.fn || o4[e.type || typeof o], this._easing = Ua[e.easing] || Ua.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = n, this._prop = r, this._from = o, this._to = i, this._promises = void 0 } active() { return this._active } update(e, n, r) { if (this._active) { this._notify(!1); const i = this._target[this._prop], s = r - this._start, o = this._duration - s; this._start = r, this._duration = Math.floor(Math.max(o, e.duration)), this._total += s, this._loop = !!e.loop, this._to = qa([e.to, n, i, e.from]), this._from = qa([e.from, i, n]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(e) { const n = e - this._start, r = this._duration, i = this._prop, s = this._from, o = this._loop, a = this._to; let l; if (this._active = s !== a && (o || n < r), !this._active) return this._target[i] = a, void this._notify(!0); n < 0 ? this._target[i] = s : (l = n / r % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(s, a, l)) } wait() { const e = this._promises || (this._promises = []); return new Promise((n, r) => { e.push({ res: n, rej: r }) }) } _notify(e) { const n = e ? "res" : "rej", r = this._promises || []; for (let i = 0; i < r.length; i++)r[i][n]() } } class wb { constructor(e, n) { this._chart = e, this._properties = new Map, this.configure(n) } configure(e) { if (!se(e)) return; const n = Object.keys(Ze.animation), r = this._properties; Object.getOwnPropertyNames(e).forEach(i => { const s = e[i]; if (!se(s)) return; const o = {}; for (const a of n) o[a] = s[a]; (De(s.properties) && s.properties || [i]).forEach(a => { (a === i || !r.has(a)) && r.set(a, o) }) }) } _animateOptions(e, n) { const r = n.options, i = function u4(t, e) { if (!e) return; let n = t.options; if (n) return n.$shared && (t.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n; t.options = e }(e, r); if (!i) return []; const s = this._createAnimations(i, r); return r.$shared && function l4(t, e) { const n = [], r = Object.keys(e); for (let i = 0; i < r.length; i++) { const s = t[r[i]]; s && s.active() && n.push(s.wait()) } return Promise.all(n) }(e.options.$animations, r).then(() => { e.options = r }, () => { }), s } _createAnimations(e, n) { const r = this._properties, i = [], s = e.$animations || (e.$animations = {}), o = Object.keys(n), a = Date.now(); let l; for (l = o.length - 1; l >= 0; --l) { const u = o[l]; if ("$" === u.charAt(0)) continue; if ("options" === u) { i.push(...this._animateOptions(e, n)); continue } const c = n[u]; let d = s[u]; const f = r.get(u); if (d) { if (f && d.active()) { d.update(f, c, a); continue } d.cancel() } f && f.duration ? (s[u] = d = new a4(f, e, u, c), i.push(d)) : e[u] = c } return i } update(e, n) { if (0 === this._properties.size) return void Object.assign(e, n); const r = this._createAnimations(e, n); return r.length ? (Er.add(this._chart, r), !0) : void 0 } } function vb(t, e) { const n = t && t.options || {}, r = n.reverse, i = void 0 === n.min ? e : 0, s = void 0 === n.max ? e : 0; return { start: r ? s : i, end: r ? i : s } } function bb(t, e) { const n = [], r = t._getSortedDatasetMetas(e); let i, s; for (i = 0, s = r.length; i < s; ++i)n.push(r[i].index); return n } function Tb(t, e, n, r = {}) { const i = t.keys, s = "single" === r.mode; let o, a, l, u; if (null !== e) { for (o = 0, a = i.length; o < a; ++o) { if (l = +i[o], l === n) { if (r.all) continue; break } u = t.values[l], Ne(u) && (s || 0 === e || hn(e) === hn(u)) && (e += u) } return e } } function kb(t, e) { const n = t && t.options.stacked; return n || void 0 === n && void 0 !== e.stack } function g4(t, e, n) { const r = t[e] || (t[e] = {}); return r[n] || (r[n] = {}) } function Db(t, e, n, r) { for (const i of e.getMatchingVisibleMetas(r).reverse()) { const s = t[i.index]; if (n && s > 0 || !n && s < 0) return i.index } return null } function Cb(t, e) { const { chart: n, _cachedMeta: r } = t, i = n._stacks || (n._stacks = {}), { iScale: s, vScale: o, index: a } = r, l = s.axis, u = o.axis, c = function h4(t, e, n) { return `${t.id}.${e.id}.${n.stack || n.type}` }(s, o, r), d = e.length; let f; for (let h = 0; h < d; ++h) { const p = e[h], { [l]: m, [u]: y } = p; f = (p._stacks || (p._stacks = {}))[u] = g4(i, c, m), f[a] = y, f._top = Db(f, o, !0, r.type), f._bottom = Db(f, o, !1, r.type), (f._visualValues || (f._visualValues = {}))[a] = y } } function vp(t, e) { const n = t.scales; return Object.keys(n).filter(r => n[r].axis === e).shift() } function Ga(t, e) { const n = t.controller.index, r = t.vScale && t.vScale.axis; if (r) { e = e || t._parsed; for (const i of e) { const s = i._stacks; if (!s || void 0 === s[r] || void 0 === s[r][n]) return; delete s[r][n], void 0 !== s[r]._visualValues && void 0 !== s[r]._visualValues[n] && delete s[r]._visualValues[n] } } } const bp = t => "reset" === t || "none" === t, xb = (t, e) => e ? t : Object.assign({}, t); class Zn { constructor(e, n) { this.chart = e, this._ctx = e.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const e = this._cachedMeta; this.configure(), this.linkScales(), e._stacked = kb(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(e) { this.index !== e && Ga(this._cachedMeta), this.index = e } linkScales() { const e = this.chart, n = this._cachedMeta, r = this.getDataset(), i = (d, f, h, p) => "x" === d ? f : "r" === d ? p : h, s = n.xAxisID = B(r.xAxisID, vp(e, "x")), o = n.yAxisID = B(r.yAxisID, vp(e, "y")), a = n.rAxisID = B(r.rAxisID, vp(e, "r")), l = n.indexAxis, u = n.iAxisID = i(l, s, o, a), c = n.vAxisID = i(l, o, s, a); n.xScale = this.getScaleForId(s), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(u), n.vScale = this.getScaleForId(c) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(e) { return this.chart.scales[e] } _getOtherScale(e) { const n = this._cachedMeta; return e === n.iScale ? n.vScale : n.iScale } reset() { this._update("reset") } _destroy() { const e = this._cachedMeta; this._data && Vv(this._data, this), e._stacked && Ga(e) } _dataCheck() { const e = this.getDataset(), n = e.data || (e.data = []), r = this._data; if (se(n)) this._data = function f4(t) { const e = Object.keys(t), n = new Array(e.length); let r, i, s; for (r = 0, i = e.length; r < i; ++r)s = e[r], n[r] = { x: s, y: t[s] }; return n }(n); else if (r !== n) { if (r) { Vv(r, this); const i = this._cachedMeta; Ga(i), i._parsed = [] } n && Object.isExtensible(n) && function rN(t, e) { t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [e] } }), Zv.forEach(n => { const r = "_onData" + sp(n), i = t[n]; Object.defineProperty(t, n, { configurable: !0, enumerable: !1, value(...s) { const o = i.apply(this, s); return t._chartjs.listeners.forEach(a => { "function" == typeof a[r] && a[r](...s) }), o } }) })) }(n, this), this._syncList = [], this._data = n } } addElements() { const e = this._cachedMeta; this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType) } buildOrUpdateElements(e) { const n = this._cachedMeta, r = this.getDataset(); let i = !1; this._dataCheck(); const s = n._stacked; n._stacked = kb(n.vScale, n), n.stack !== r.stack && (i = !0, Ga(n), n.stack = r.stack), this._resyncElements(e), (i || s !== n._stacked) && Cb(this, n._parsed) } configure() { const e = this.chart.config, n = e.datasetScopeKeys(this._type), r = e.getOptionScopes(this.getDataset(), n, !0); this.options = e.createResolver(r, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(e, n) { const { _cachedMeta: r, _data: i } = this, { iScale: s, _stacked: o } = r, a = s.axis; let c, d, f, l = 0 === e && n === i.length || r._sorted, u = e > 0 && r._parsed[e - 1]; if (!1 === this._parsing) r._parsed = i, r._sorted = !0, f = i; else { f = De(i[e]) ? this.parseArrayData(r, i, e, n) : se(i[e]) ? this.parseObjectData(r, i, e, n) : this.parsePrimitiveData(r, i, e, n); const h = () => null === d[a] || u && d[a] < u[a]; for (c = 0; c < n; ++c)r._parsed[c + e] = d = f[c], l && (h() && (l = !1), u = d); r._sorted = l } o && Cb(this, f) } parsePrimitiveData(e, n, r, i) { const { iScale: s, vScale: o } = e, a = s.axis, l = o.axis, u = s.getLabels(), c = s === o, d = new Array(i); let f, h, p; for (f = 0, h = i; f < h; ++f)p = f + r, d[f] = { [a]: c || s.parse(u[p], p), [l]: o.parse(n[p], p) }; return d } parseArrayData(e, n, r, i) { const { xScale: s, yScale: o } = e, a = new Array(i); let l, u, c, d; for (l = 0, u = i; l < u; ++l)c = l + r, d = n[c], a[l] = { x: s.parse(d[0], c), y: o.parse(d[1], c) }; return a } parseObjectData(e, n, r, i) { const { xScale: s, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, u = new Array(i); let c, d, f, h; for (c = 0, d = i; c < d; ++c)f = c + r, h = n[f], u[c] = { x: s.parse(Jr(h, a), f), y: o.parse(Jr(h, l), f) }; return u } getParsed(e) { return this._cachedMeta._parsed[e] } getDataElement(e) { return this._cachedMeta.data[e] } applyStack(e, n, r) { const s = this._cachedMeta, o = n[e.axis]; return Tb({ keys: bb(this.chart, !0), values: n._stacks[e.axis]._visualValues }, o, s.index, { mode: r }) } updateRangeFromParsed(e, n, r, i) { const s = r[n.axis]; let o = null === s ? NaN : s; const a = i && r._stacks[n.axis]; i && a && (i.values = a, o = Tb(i, s, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o) } getMinMax(e, n) { const r = this._cachedMeta, i = r._parsed, s = r._sorted && e === r.iScale, o = i.length, a = this._getOtherScale(e), l = ((t, e, n) => t && !e.hidden && e._stacked && { keys: bb(this.chart, !0), values: null })(n, r), u = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: c, max: d } = function p4(t) { const { min: e, max: n, minDefined: r, maxDefined: i } = t.getUserBounds(); return { min: r ? e : Number.NEGATIVE_INFINITY, max: i ? n : Number.POSITIVE_INFINITY } }(a); let f, h; function p() { h = i[f]; const m = h[a.axis]; return !Ne(h[e.axis]) || c > m || d < m } for (f = 0; f < o && (p() || (this.updateRangeFromParsed(u, e, h, l), !s)); ++f); if (s) for (f = o - 1; f >= 0; --f)if (!p()) { this.updateRangeFromParsed(u, e, h, l); break } return u } getAllParsedValues(e) { const n = this._cachedMeta._parsed, r = []; let i, s, o; for (i = 0, s = n.length; i < s; ++i)o = n[i][e.axis], Ne(o) && r.push(o); return r } getMaxOverflow() { return !1 } getLabelAndValue(e) { const n = this._cachedMeta, r = n.iScale, i = n.vScale, s = this.getParsed(e); return { label: r ? "" + r.getLabelForValue(s[r.axis]) : "", value: i ? "" + i.getLabelForValue(s[i.axis]) : "" } } _update(e) { const n = this._cachedMeta; this.update(e || "default"), n._clip = function d4(t) { let e, n, r, i; return se(t) ? (e = t.top, n = t.right, r = t.bottom, i = t.left) : e = n = r = i = t, { top: e, right: n, bottom: r, left: i, disabled: !1 === t } }(B(this.options.clip, function c4(t, e, n) { if (!1 === n) return !1; const r = vb(t, n), i = vb(e, n); return { top: i.end, right: r.end, bottom: i.start, left: r.start } }(n.xScale, n.yScale, this.getMaxOverflow()))) } update(e) { } draw() { const e = this._ctx, r = this._cachedMeta, i = r.data || [], s = this.chart.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || i.length - a, u = this.options.drawActiveElementsOnTop; let c; for (r.dataset && r.dataset.draw(e, s, a, l), c = a; c < a + l; ++c) { const d = i[c]; d.hidden || (d.active && u ? o.push(d) : d.draw(e, s)) } for (c = 0; c < o.length; ++c)o[c].draw(e, s) } getStyle(e, n) { const r = n ? "active" : "default"; return void 0 === e && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(r) : this.resolveDataElementOptions(e || 0, r) } getContext(e, n, r) { const i = this.getDataset(); let s; if (e >= 0 && e < this._cachedMeta.data.length) { const o = this._cachedMeta.data[e]; s = o.$context || (o.$context = function _4(t, e, n) { return ni(t, { active: !1, dataIndex: e, parsed: void 0, raw: void 0, element: n, index: e, mode: "default", type: "data" }) }(this.getContext(), e, o)), s.parsed = this.getParsed(e), s.raw = i.data[e], s.index = s.dataIndex = e } else s = this.$context || (this.$context = function m4(t, e) { return ni(t, { active: !1, dataset: void 0, datasetIndex: e, index: e, mode: "default", type: "dataset" }) }(this.chart.getContext(), this.index)), s.dataset = i, s.index = s.datasetIndex = this.index; return s.active = !!n, s.mode = r, s } resolveDatasetElementOptions(e) { return this._resolveElementOptions(this.datasetElementType.id, e) } resolveDataElementOptions(e, n) { return this._resolveElementOptions(this.dataElementType.id, n, e) } _resolveElementOptions(e, n = "default", r) { const i = "active" === n, s = this._cachedDataOpts, o = e + "-" + n, a = s[o], l = this.enableOptionSharing && Ba(r); if (a) return xb(a, l); const u = this.chart.config, c = u.datasetElementScopeKeys(this._type, e), d = i ? [`${e}Hover`, "hover", e, ""] : [e, ""], f = u.getOptionScopes(this.getDataset(), c), h = Object.keys(Ze.elements[e]), m = u.resolveNamedOptions(f, h, () => this.getContext(r, i, n), d); return m.$shared && (m.$shared = l, s[o] = Object.freeze(xb(m, l))), m } _resolveAnimations(e, n, r) { const i = this.chart, s = this._cachedDataOpts, o = `animation-${n}`, a = s[o]; if (a) return a; let l; if (!1 !== i.options.animation) { const c = this.chart.config, d = c.datasetAnimationScopeKeys(this._type, n), f = c.getOptionScopes(this.getDataset(), d); l = c.createResolver(f, this.getContext(e, r, n)) } const u = new wb(i, l && l.animations); return l && l._cacheable && (s[o] = Object.freeze(u)), u } getSharedOptions(e) { if (e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e)) } includeOptions(e, n) { return !n || bp(e) || this.chart._animationsDisabled } _getSharedOptions(e, n) { const r = this.resolveDataElementOptions(e, n), i = this._sharedOptions, s = this.getSharedOptions(r), o = this.includeOptions(n, s) || s !== i; return this.updateSharedOptions(s, n, r), { sharedOptions: s, includeOptions: o } } updateElement(e, n, r, i) { bp(i) ? Object.assign(e, r) : this._resolveAnimations(n, i).update(e, r) } updateSharedOptions(e, n, r) { e && !bp(n) && this._resolveAnimations(void 0, n).update(e, r) } _setStyle(e, n, r, i) { e.active = i; const s = this.getStyle(n, i); this._resolveAnimations(n, r, i).update(e, { options: !i && this.getSharedOptions(s) || s }) } removeHoverStyle(e, n, r) { this._setStyle(e, r, "active", !1) } setHoverStyle(e, n, r) { this._setStyle(e, r, "active", !0) } _removeDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !1) } _setDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !0) } _resyncElements(e) { const n = this._data, r = this._cachedMeta.data; for (const [a, l, u] of this._syncList) this[a](l, u); this._syncList = []; const i = r.length, s = n.length, o = Math.min(s, i); o && this.parse(0, o), s > i ? this._insertElements(i, s - i, e) : s < i && this._removeElements(s, i - s) } _insertElements(e, n, r = !0) { const i = this._cachedMeta, s = i.data, o = e + n; let a; const l = u => { for (u.length += n, a = u.length - 1; a >= o; a--)u[a] = u[a - n] }; for (l(s), a = e; a < o; ++a)s[a] = new this.dataElementType; this._parsing && l(i._parsed), this.parse(e, n), r && this.updateElements(s, e, n, "reset") } updateElements(e, n, r, i) { } _removeElements(e, n) { const r = this._cachedMeta; if (this._parsing) { const i = r._parsed.splice(e, n); r._stacked && Ga(r, i) } r.data.splice(e, n) } _sync(e) { if (this._parsing) this._syncList.push(e); else { const [n, r, i] = e; this[n](r, i) } this.chart._dataChanges.push([this.index, ...e]) } _onDataPush() { const e = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - e, e]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(e, n) { n && this._sync(["_removeElements", e, n]); const r = arguments.length - 2; r && this._sync(["_insertElements", e, r]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } function v4(t) { const e = t.iScale, n = function w4(t, e) { if (!t._cache.$bar) { const n = t.getMatchingVisibleMetas(e); let r = []; for (let i = 0, s = n.length; i < s; i++)r = r.concat(n[i].controller.getAllParsedValues(t)); t._cache.$bar = Bv(r.sort((i, s) => i - s)) } return t._cache.$bar }(e, t.type); let i, s, o, a, r = e._length; const l = () => { 32767 === o || -32768 === o || (Ba(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o) }; for (i = 0, s = n.length; i < s; ++i)o = e.getPixelForValue(n[i]), l(); for (a = void 0, i = 0, s = e.ticks.length; i < s; ++i)o = e.getPixelForTick(i), l(); return r } function Eb(t, e, n, r) { return De(t) ? function k4(t, e, n, r) { const i = n.parse(t[0], r), s = n.parse(t[1], r), o = Math.min(i, s), a = Math.max(i, s); let l = o, u = a; Math.abs(o) > Math.abs(a) && (l = a, u = o), e[n.axis] = u, e._custom = { barStart: l, barEnd: u, start: i, end: s, min: o, max: a } }(t, e, n, r) : e[n.axis] = n.parse(t, r), e } function Mb(t, e, n, r) { const i = t.iScale, s = t.vScale, o = i.getLabels(), a = i === s, l = []; let u, c, d, f; for (u = n, c = n + r; u < c; ++u)f = e[u], d = {}, d[i.axis] = a || i.parse(o[u], u), l.push(Eb(f, d, s, u)); return l } function Tp(t) { return t && void 0 !== t.barStart && void 0 !== t.barEnd } function x4(t, e, n, r) { let i = e.borderSkipped; const s = {}; if (!i) return void (t.borderSkipped = s); if (!0 === i) return void (t.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }); const { start: o, end: a, reverse: l, top: u, bottom: c } = function C4(t) { let e, n, r, i, s; return t.horizontal ? (e = t.base > t.x, n = "left", r = "right") : (e = t.base < t.y, n = "bottom", r = "top"), e ? (i = "end", s = "start") : (i = "start", s = "end"), { start: n, end: r, reverse: e, top: i, bottom: s } }(t); "middle" === i && n && (t.enableBorderRadius = !0, (n._top || 0) === r ? i = u : (n._bottom || 0) === r ? i = c : (s[Sb(c, o, a, l)] = !0, i = u)), s[Sb(i, o, a, l)] = !0, t.borderSkipped = s } function Sb(t, e, n, r) { return r ? (t = function E4(t, e, n) { return t === e ? n : t === n ? e : t }(t, e, n), t = Ib(t, n, e)) : t = Ib(t, e, n), t } function Ib(t, e, n) { return "start" === t ? e : "end" === t ? n : t } function M4(t, { inflateAmount: e }, n) { t.inflateAmount = "auto" === e ? 1 === n ? .33 : 0 : e } I(Zn, "defaults", {}), I(Zn, "datasetElementType", null), I(Zn, "dataElementType", null); class B0 extends Zn { parsePrimitiveData(e, n, r, i) { return Mb(e, n, r, i) } parseArrayData(e, n, r, i) { return Mb(e, n, r, i) } parseObjectData(e, n, r, i) { const { iScale: s, vScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, u = "x" === s.axis ? a : l, c = "x" === o.axis ? a : l, d = []; let f, h, p, m; for (f = r, h = r + i; f < h; ++f)m = n[f], p = {}, p[s.axis] = s.parse(Jr(m, u), f), d.push(Eb(Jr(m, c), p, o, f)); return d } updateRangeFromParsed(e, n, r, i) { super.updateRangeFromParsed(e, n, r, i); const s = r._custom; s && n === this._cachedMeta.vScale && (e.min = Math.min(e.min, s.min), e.max = Math.max(e.max, s.max)) } getMaxOverflow() { return 0 } getLabelAndValue(e) { const n = this._cachedMeta, { iScale: r, vScale: i } = n, s = this.getParsed(e), o = s._custom, a = Tp(o) ? "[" + o.start + ", " + o.end + "]" : "" + i.getLabelForValue(s[i.axis]); return { label: "" + r.getLabelForValue(s[r.axis]), value: a } } initialize() { this.enableOptionSharing = !0, super.initialize(), this._cachedMeta.stack = this.getDataset().stack } update(e) { const n = this._cachedMeta; this.updateElements(n.data, 0, n.data.length, e) } updateElements(e, n, r, i) { const s = "reset" === i, { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), u = a.isHorizontal(), c = this._getRuler(), { sharedOptions: d, includeOptions: f } = this._getSharedOptions(n, i); for (let h = n; h < n + r; h++) { const p = this.getParsed(h), m = s || de(p[a.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(h), y = this._calculateBarIndexPixels(h, c), v = (p._stacks || {})[a.axis], w = { horizontal: u, base: m.base, enableBorderRadius: !v || Tp(p._custom) || o === v._top || o === v._bottom, x: u ? m.head : y.center, y: u ? y.center : m.head, height: u ? y.size : Math.abs(m.size), width: u ? Math.abs(m.size) : y.size }; f && (w.options = d || this.resolveDataElementOptions(h, e[h].active ? "active" : i)); const T = w.options || e[h].options; x4(w, T, v, o), M4(w, T, c.ratio), this.updateElement(e[h], h, w, i) } } _getStacks(e, n) { const { iScale: r } = this._cachedMeta, i = r.getMatchingVisibleMetas(this._type).filter(l => l.controller.options.grouped), s = r.options.stacked, o = [], a = l => { const u = l.controller.getParsed(n), c = u && u[l.vScale.axis]; if (de(c) || isNaN(c)) return !0 }; for (const l of i) if ((void 0 === n || !a(l)) && ((!1 === s || -1 === o.indexOf(l.stack) || void 0 === s && void 0 === l.stack) && o.push(l.stack), l.index === e)) break; return o.length || o.push(void 0), o } _getStackCount(e) { return this._getStacks(void 0, e).length } _getStackIndex(e, n, r) { const i = this._getStacks(e, r), s = void 0 !== n ? i.indexOf(n) : -1; return -1 === s ? i.length - 1 : s } _getRuler() { const e = this.options, n = this._cachedMeta, r = n.iScale, i = []; let s, o; for (s = 0, o = n.data.length; s < o; ++s)i.push(r.getPixelForValue(this.getParsed(s)[r.axis], s)); const a = e.barThickness; return { min: a || v4(n), pixels: i, start: r._startPixel, end: r._endPixel, stackCount: this._getStackCount(), scale: r, grouped: e.grouped, ratio: a ? 1 : e.categoryPercentage * e.barPercentage } } _calculateBarValuePixels(e) { const { _cachedMeta: { vScale: n, _stacked: r, index: i }, options: { base: s, minBarLength: o } } = this, a = s || 0, l = this.getParsed(e), u = l._custom, c = Tp(u); let p, m, d = l[n.axis], f = 0, h = r ? this.applyStack(n, l, r) : d; h !== d && (f = h - d, h = d), c && (d = u.barStart, h = u.barEnd - u.barStart, 0 !== d && hn(d) !== hn(u.barEnd) && (f = 0), f += d); const y = de(s) || c ? f : s; let v = n.getPixelForValue(y); if (p = this.chart.getDataVisibility(e) ? n.getPixelForValue(f + h) : v, m = p - v, Math.abs(m) < o) { m = function D4(t, e, n) { return 0 !== t ? hn(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= n ? 1 : -1) }(m, n, a) * o, d === a && (v -= m / 2); const w = n.getPixelForDecimal(0), T = n.getPixelForDecimal(1), C = Math.min(w, T), D = Math.max(w, T); v = Math.max(Math.min(v, D), C), p = v + m, r && !c && (l._stacks[n.axis]._visualValues[i] = n.getValueForPixel(p) - n.getValueForPixel(v)) } if (v === n.getPixelForValue(a)) { const w = hn(m) * n.getLineWidthForValue(a) / 2; v += w, m -= w } return { size: m, base: v, head: p, center: p + m / 2 } } _calculateBarIndexPixels(e, n) { const r = n.scale, i = this.options, s = i.skipNull, o = B(i.maxBarThickness, 1 / 0); let a, l; if (n.grouped) { const u = s ? this._getStackCount(e) : n.stackCount, c = "flex" === i.barThickness ? function T4(t, e, n, r) { const i = e.pixels, s = i[t]; let o = t > 0 ? i[t - 1] : null, a = t < i.length - 1 ? i[t + 1] : null; const l = n.categoryPercentage; null === o && (o = s - (null === a ? e.end - e.start : a - s)), null === a && (a = s + s - o); const u = s - (s - Math.min(o, a)) / 2 * l; return { chunk: Math.abs(a - o) / 2 * l / r, ratio: n.barPercentage, start: u } }(e, n, i, u) : function b4(t, e, n, r) { const i = n.barThickness; let s, o; return de(i) ? (s = e.min * n.categoryPercentage, o = n.barPercentage) : (s = i * r, o = 1), { chunk: s / r, ratio: o, start: e.pixels[t] - s / 2 } }(e, n, i, u), d = this._getStackIndex(this.index, this._cachedMeta.stack, s ? e : void 0); a = c.start + c.chunk * d + c.chunk / 2, l = Math.min(o, c.chunk * c.ratio) } else a = r.getPixelForValue(this.getParsed(e)[r.axis], e), l = Math.min(o, n.min * n.ratio); return { base: a - l / 2, head: a + l / 2, center: a, size: l } } draw() { const e = this._cachedMeta, n = e.vScale, r = e.data, i = r.length; let s = 0; for (; s < i; ++s)null !== this.getParsed(s)[n.axis] && r[s].draw(this._ctx) } } I(B0, "id", "bar"), I(B0, "defaults", { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }), I(B0, "overrides", { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }); class j0 extends Zn { initialize() { this.enableOptionSharing = !0, super.initialize() } parsePrimitiveData(e, n, r, i) { const s = super.parsePrimitiveData(e, n, r, i); for (let o = 0; o < s.length; o++)s[o]._custom = this.resolveDataElementOptions(o + r).radius; return s } parseArrayData(e, n, r, i) { const s = super.parseArrayData(e, n, r, i); for (let o = 0; o < s.length; o++)s[o]._custom = B(n[r + o][2], this.resolveDataElementOptions(o + r).radius); return s } parseObjectData(e, n, r, i) { const s = super.parseObjectData(e, n, r, i); for (let o = 0; o < s.length; o++) { const a = n[r + o]; s[o]._custom = B(a && a.r && +a.r, this.resolveDataElementOptions(o + r).radius) } return s } getMaxOverflow() { const e = this._cachedMeta.data; let n = 0; for (let r = e.length - 1; r >= 0; --r)n = Math.max(n, e[r].size(this.resolveDataElementOptions(r)) / 2); return n > 0 && n } getLabelAndValue(e) { const n = this._cachedMeta, r = this.chart.data.labels || [], { xScale: i, yScale: s } = n, o = this.getParsed(e), a = i.getLabelForValue(o.x), l = s.getLabelForValue(o.y), u = o._custom; return { label: r[e] || "", value: "(" + a + ", " + l + (u ? ", " + u : "") + ")" } } update(e) { const n = this._cachedMeta.data; this.updateElements(n, 0, n.length, e) } updateElements(e, n, r, i) { const s = "reset" === i, { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: u } = this._getSharedOptions(n, i), c = o.axis, d = a.axis; for (let f = n; f < n + r; f++) { const h = e[f], p = !s && this.getParsed(f), m = {}, y = m[c] = s ? o.getPixelForDecimal(.5) : o.getPixelForValue(p[c]), v = m[d] = s ? a.getBasePixel() : a.getPixelForValue(p[d]); m.skip = isNaN(y) || isNaN(v), u && (m.options = l || this.resolveDataElementOptions(f, h.active ? "active" : i), s && (m.options.radius = 0)), this.updateElement(h, f, m, i) } } resolveDataElementOptions(e, n) { const r = this.getParsed(e); let i = super.resolveDataElementOptions(e, n); i.$shared && (i = Object.assign({}, i, { $shared: !1 })); const s = i.radius; return "active" !== n && (i.radius = 0), i.radius += B(r && r._custom, s), i } } I(j0, "id", "bubble"), I(j0, "defaults", { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }), I(j0, "overrides", { scales: { x: { type: "linear" }, y: { type: "linear" } } }); class ji extends Zn { constructor(e, n) { super(e, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales() { } parse(e, n) { const r = this.getDataset().data, i = this._cachedMeta; if (!1 === this._parsing) i._parsed = r; else { let o, a, s = l => +r[l]; if (se(r[e])) { const { key: l = "value" } = this._parsing; s = u => +Jr(r[u], l) } for (o = e, a = e + n; o < a; ++o)i._parsed[o] = s(o) } } _getRotation() { return Ln(this.options.rotation - 90) } _getCircumference() { return Ln(this.options.circumference) } _getRotationExtents() { let e = Ce, n = -Ce; for (let r = 0; r < this.chart.data.datasets.length; ++r)if (this.chart.isDatasetVisible(r) && this.chart.getDatasetMeta(r).type === this._type) { const i = this.chart.getDatasetMeta(r).controller, s = i._getRotation(), o = i._getCircumference(); e = Math.min(e, s), n = Math.max(n, s + o) } return { rotation: e, circumference: n - e } } update(e) { const n = this.chart, { chartArea: r } = n, i = this._cachedMeta, s = i.data, o = this.getMaxBorderWidth() + this.getMaxOffset(s) + this.options.spacing, a = Math.max((Math.min(r.width, r.height) - o) / 2, 0), l = Math.min(((t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 : +t / e)(this.options.cutout, a), 1), u = this._getRingWeight(this.index), { circumference: c, rotation: d } = this._getRotationExtents(), { ratioX: f, ratioY: h, offsetX: p, offsetY: m } = function S4(t, e, n) { let r = 1, i = 1, s = 0, o = 0; if (e < Ce) { const a = t, l = a + e, u = Math.cos(a), c = Math.sin(a), d = Math.cos(l), f = Math.sin(l), h = (T, C, D) => Ha(T, a, l, !0) ? 1 : Math.max(C, C * n, D, D * n), p = (T, C, D) => Ha(T, a, l, !0) ? -1 : Math.min(C, C * n, D, D * n), m = h(0, u, d), y = h(Le, c, f), v = p(Ee, u, d), w = p(Ee + Le, c, f); r = (m - v) / 2, i = (y - w) / 2, s = -(m + v) / 2, o = -(y + w) / 2 } return { ratioX: r, ratioY: i, offsetX: s, offsetY: o } }(d, c, l), w = Math.max(Math.min((r.width - o) / f, (r.height - o) / h) / 2, 0), T = Sv(this.options.radius, w), D = (T - Math.max(T * l, 0)) / this._getVisibleDatasetWeightTotal(); this.offsetX = p * T, this.offsetY = m * T, i.total = this.calculateTotal(), this.outerRadius = T - D * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - D * u, 0), this.updateElements(s, 0, s.length, e) } _circumference(e, n) { const r = this.options, i = this._cachedMeta, s = this._getCircumference(); return n && r.animation.animateRotate || !this.chart.getDataVisibility(e) || null === i._parsed[e] || i.data[e].hidden ? 0 : this.calculateCircumference(i._parsed[e] * s / Ce) } updateElements(e, n, r, i) { const s = "reset" === i, o = this.chart, a = o.chartArea, c = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, f = s && o.options.animation.animateScale, h = f ? 0 : this.innerRadius, p = f ? 0 : this.outerRadius, { sharedOptions: m, includeOptions: y } = this._getSharedOptions(n, i); let w, v = this._getRotation(); for (w = 0; w < n; ++w)v += this._circumference(w, s); for (w = n; w < n + r; ++w) { const T = this._circumference(w, s), C = e[w], D = { x: c + this.offsetX, y: d + this.offsetY, startAngle: v, endAngle: v + T, circumference: T, outerRadius: p, innerRadius: h }; y && (D.options = m || this.resolveDataElementOptions(w, C.active ? "active" : i)), v += T, this.updateElement(C, w, D, i) } } calculateTotal() { const e = this._cachedMeta, n = e.data; let i, r = 0; for (i = 0; i < n.length; i++) { const s = e._parsed[i]; null !== s && !isNaN(s) && this.chart.getDataVisibility(i) && !n[i].hidden && (r += Math.abs(s)) } return r } calculateCircumference(e) { const n = this._cachedMeta.total; return n > 0 && !isNaN(e) ? Ce * (Math.abs(e) / n) : 0 } getLabelAndValue(e) { const r = this.chart, i = r.data.labels || [], s = $a(this._cachedMeta._parsed[e], r.options.locale); return { label: i[e] || "", value: s } } getMaxBorderWidth(e) { let n = 0; const r = this.chart; let i, s, o, a, l; if (!e) for (i = 0, s = r.data.datasets.length; i < s; ++i)if (r.isDatasetVisible(i)) { o = r.getDatasetMeta(i), e = o.data, a = o.controller; break } if (!e) return 0; for (i = 0, s = e.length; i < s; ++i)l = a.resolveDataElementOptions(i), "inner" !== l.borderAlign && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0)); return n } getMaxOffset(e) { let n = 0; for (let r = 0, i = e.length; r < i; ++r) { const s = this.resolveDataElementOptions(r); n = Math.max(n, s.offset || 0, s.hoverOffset || 0) } return n } _getRingWeightOffset(e) { let n = 0; for (let r = 0; r < e; ++r)this.chart.isDatasetVisible(r) && (n += this._getRingWeight(r)); return n } _getRingWeight(e) { return Math.max(B(this.chart.data.datasets[e].weight, 1), 0) } _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } } I(ji, "id", "doughnut"), I(ji, "defaults", { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", spacing: 0, indexAxis: "r" }), I(ji, "descriptors", { _scriptable: e => "spacing" !== e, _indexable: e => "spacing" !== e && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash") }), I(ji, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(e) { const n = e.data; if (n.labels.length && n.datasets.length) { const { labels: { pointStyle: r, color: i } } = e.legend.options; return n.labels.map((s, o) => { const l = e.getDatasetMeta(0).controller.getStyle(o); return { text: s, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: i, lineWidth: l.borderWidth, pointStyle: r, hidden: !e.getDataVisibility(o), index: o } }) } return [] } }, onClick(e, n, r) { r.chart.toggleDataVisibility(n.index), r.chart.update() } } } }); class H0 extends Zn { initialize() { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update(e) { const n = this._cachedMeta, { dataset: r, data: i = [], _dataset: s } = n, o = this.chart._animationsDisabled; let { start: a, count: l } = Uv(n, i, o); this._drawStart = a, this._drawCount = l, $v(n) && (a = 0, l = i.length), r._chart = this.chart, r._datasetIndex = this.index, r._decimated = !!s._decimated, r.points = i; const u = this.resolveDatasetElementOptions(e); this.options.showLine || (u.borderWidth = 0), u.segment = this.options.segment, this.updateElement(r, void 0, { animated: !o, options: u }, e), this.updateElements(i, a, l, e) } updateElements(e, n, r, i) { const s = "reset" === i, { iScale: o, vScale: a, _stacked: l, _dataset: u } = this._cachedMeta, { sharedOptions: c, includeOptions: d } = this._getSharedOptions(n, i), f = o.axis, h = a.axis, { spanGaps: p, segment: m } = this.options, y = io(p) ? p : Number.POSITIVE_INFINITY, v = this.chart._animationsDisabled || s || "none" === i, w = n + r, T = e.length; let C = n > 0 && this.getParsed(n - 1); for (let D = 0; D < T; ++D) { const M = e[D], S = v ? M : {}; if (D < n || D >= w) { S.skip = !0; continue } const A = this.getParsed(D), F = de(A[h]), W = S[f] = o.getPixelForValue(A[f], D), q = S[h] = s || F ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, A, l) : A[h], D); S.skip = isNaN(W) || isNaN(q) || F, S.stop = D > 0 && Math.abs(A[f] - C[f]) > y, m && (S.parsed = A, S.raw = u.data[D]), d && (S.options = c || this.resolveDataElementOptions(D, M.active ? "active" : i)), v || this.updateElement(M, D, S, i), C = A } } getMaxOverflow() { const e = this._cachedMeta, n = e.dataset, r = n.options && n.options.borderWidth || 0, i = e.data || []; if (!i.length) return r; const s = i[0].size(this.resolveDataElementOptions(0)), o = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1)); return Math.max(r, s, o) / 2 } draw() { const e = this._cachedMeta; e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw() } } I(H0, "id", "line"), I(H0, "defaults", { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }), I(H0, "overrides", { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }); class Ya extends Zn { constructor(e, n) { super(e, n), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue(e) { const r = this.chart, i = r.data.labels || [], s = $a(this._cachedMeta._parsed[e].r, r.options.locale); return { label: i[e] || "", value: s } } parseObjectData(e, n, r, i) { return sb.bind(this)(e, n, r, i) } update(e) { const n = this._cachedMeta.data; this._updateRadius(), this.updateElements(n, 0, n.length, e) } getMinMax() { const n = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; return this._cachedMeta.data.forEach((r, i) => { const s = this.getParsed(i).r; !isNaN(s) && this.chart.getDataVisibility(i) && (s < n.min && (n.min = s), s > n.max && (n.max = s)) }), n } _updateRadius() { const e = this.chart, n = e.chartArea, r = e.options, i = Math.min(n.right - n.left, n.bottom - n.top), s = Math.max(i / 2, 0), a = (s - Math.max(r.cutoutPercentage ? s / 100 * r.cutoutPercentage : 1, 0)) / e.getVisibleDatasetCount(); this.outerRadius = s - a * this.index, this.innerRadius = this.outerRadius - a } updateElements(e, n, r, i) { const s = "reset" === i, o = this.chart, l = o.options.animation, u = this._cachedMeta.rScale, c = u.xCenter, d = u.yCenter, f = u.getIndexAngle(0) - .5 * Ee; let p, h = f; const m = 360 / this.countVisibleElements(); for (p = 0; p < n; ++p)h += this._computeAngle(p, i, m); for (p = n; p < n + r; p++) { const y = e[p]; let v = h, w = h + this._computeAngle(p, i, m), T = o.getDataVisibility(p) ? u.getDistanceFromCenterForValue(this.getParsed(p).r) : 0; h = w, s && (l.animateScale && (T = 0), l.animateRotate && (v = w = f)); const C = { x: c, y: d, innerRadius: 0, outerRadius: T, startAngle: v, endAngle: w, options: this.resolveDataElementOptions(p, y.active ? "active" : i) }; this.updateElement(y, p, C, i) } } countVisibleElements() { let n = 0; return this._cachedMeta.data.forEach((r, i) => { !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && n++ }), n } _computeAngle(e, n, r) { return this.chart.getDataVisibility(e) ? Ln(this.resolveDataElementOptions(e, n).angle || r) : 0 } } I(Ya, "id", "polarArea"), I(Ya, "defaults", { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }), I(Ya, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(e) { const n = e.data; if (n.labels.length && n.datasets.length) { const { labels: { pointStyle: r, color: i } } = e.legend.options; return n.labels.map((s, o) => { const l = e.getDatasetMeta(0).controller.getStyle(o); return { text: s, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: i, lineWidth: l.borderWidth, pointStyle: r, hidden: !e.getDataVisibility(o), index: o } }) } return [] } }, onClick(e, n, r) { r.chart.toggleDataVisibility(n.index), r.chart.update() } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }); class kp extends ji { } I(kp, "id", "pie"), I(kp, "defaults", { cutout: 0, rotation: 0, circumference: 360, radius: "100%" }); class U0 extends Zn { getLabelAndValue(e) { const n = this._cachedMeta.vScale, r = this.getParsed(e); return { label: n.getLabels()[e], value: "" + n.getLabelForValue(r[n.axis]) } } parseObjectData(e, n, r, i) { return sb.bind(this)(e, n, r, i) } update(e) { const n = this._cachedMeta, r = n.dataset, i = n.data || [], s = n.iScale.getLabels(); if (r.points = i, "resize" !== e) { const o = this.resolveDatasetElementOptions(e); this.options.showLine || (o.borderWidth = 0), this.updateElement(r, void 0, { _loop: !0, _fullLoop: s.length === i.length, options: o }, e) } this.updateElements(i, 0, i.length, e) } updateElements(e, n, r, i) { const s = this._cachedMeta.rScale, o = "reset" === i; for (let a = n; a < n + r; a++) { const l = e[a], u = this.resolveDataElementOptions(a, l.active ? "active" : i), c = s.getPointPositionForValue(a, this.getParsed(a).r), d = o ? s.xCenter : c.x, f = o ? s.yCenter : c.y, h = { x: d, y: f, angle: c.angle, skip: isNaN(d) || isNaN(f), options: u }; this.updateElement(l, a, h, i) } } } I(U0, "id", "radar"), I(U0, "defaults", { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: !0, elements: { line: { fill: "start" } } }), I(U0, "overrides", { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }); class $0 extends Zn { getLabelAndValue(e) { const n = this._cachedMeta, r = this.chart.data.labels || [], { xScale: i, yScale: s } = n, o = this.getParsed(e), a = i.getLabelForValue(o.x), l = s.getLabelForValue(o.y); return { label: r[e] || "", value: "(" + a + ", " + l + ")" } } update(e) { const n = this._cachedMeta, { data: r = [] } = n, i = this.chart._animationsDisabled; let { start: s, count: o } = Uv(n, r, i); if (this._drawStart = s, this._drawCount = o, $v(n) && (s = 0, o = r.length), this.options.showLine) { const { dataset: a, _dataset: l } = n; a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = r; const u = this.resolveDatasetElementOptions(e); u.segment = this.options.segment, this.updateElement(a, void 0, { animated: !i, options: u }, e) } this.updateElements(r, s, o, e) } addElements() { const { showLine: e } = this.options; !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements() } updateElements(e, n, r, i) { const s = "reset" === i, { iScale: o, vScale: a, _stacked: l, _dataset: u } = this._cachedMeta, c = this.resolveDataElementOptions(n, i), d = this.getSharedOptions(c), f = this.includeOptions(i, d), h = o.axis, p = a.axis, { spanGaps: m, segment: y } = this.options, v = io(m) ? m : Number.POSITIVE_INFINITY, w = this.chart._animationsDisabled || s || "none" === i; let T = n > 0 && this.getParsed(n - 1); for (let C = n; C < n + r; ++C) { const D = e[C], M = this.getParsed(C), S = w ? D : {}, A = de(M[p]), F = S[h] = o.getPixelForValue(M[h], C), W = S[p] = s || A ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, M, l) : M[p], C); S.skip = isNaN(F) || isNaN(W) || A, S.stop = C > 0 && Math.abs(M[h] - T[h]) > v, y && (S.parsed = M, S.raw = u.data[C]), f && (S.options = d || this.resolveDataElementOptions(C, D.active ? "active" : i)), w || this.updateElement(D, C, S, i), T = M } this.updateSharedOptions(d, i, c) } getMaxOverflow() { const e = this._cachedMeta, n = e.data || []; if (!this.options.showLine) { let a = 0; for (let l = n.length - 1; l >= 0; --l)a = Math.max(a, n[l].size(this.resolveDataElementOptions(l)) / 2); return a > 0 && a } const r = e.dataset, i = r.options && r.options.borderWidth || 0; if (!n.length) return i; const s = n[0].size(this.resolveDataElementOptions(0)), o = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1)); return Math.max(i, s, o) / 2 } } I($0, "id", "scatter"), I($0, "defaults", { datasetElementType: !1, dataElementType: "point", showLine: !1, fill: !1 }), I($0, "overrides", { interaction: { mode: "point" }, scales: { x: { type: "linear" }, y: { type: "linear" } } }); var I4 = Object.freeze({ __proto__: null, BarController: B0, BubbleController: j0, DoughnutController: ji, LineController: H0, PieController: kp, PolarAreaController: Ya, RadarController: U0, ScatterController: $0 }); function Hi() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class Dp { constructor(e) { I(this, "options"), this.options = e || {} } static override(e) { Object.assign(Dp.prototype, e) } init() { } formats() { return Hi() } parse() { return Hi() } format() { return Hi() } add() { return Hi() } diff() { return Hi() } startOf() { return Hi() } endOf() { return Hi() } } var A4__date = Dp; function P4(t, e, n, r) { const { controller: i, data: s, _sorted: o } = t, a = i._cachedMeta.iScale; if (a && e === a.axis && "r" !== e && o && s.length) { const l = a._reversePixels ? tN : Cr; if (!r) return l(s, e, n); if (i._sharedOptions) { const u = s[0], c = "function" == typeof u.getRange && u.getRange(e); if (c) { const d = l(s, e, n - c), f = l(s, e, n + c); return { lo: d.lo, hi: f.hi } } } } return { lo: 0, hi: s.length - 1 } } function Xa(t, e, n, r, i) { const s = t.getSortedVisibleDatasetMetas(), o = n[e]; for (let a = 0, l = s.length; a < l; ++a) { const { index: u, data: c } = s[a], { lo: d, hi: f } = P4(s[a], e, o, i); for (let h = d; h <= f; ++h) { const p = c[h]; p.skip || r(p, u, h) } } } function Cp(t, e, n, r, i) { const s = []; return !i && !t.isPointInArea(e) || Xa(t, n, e, function (a, l, u) { !i && !xr(a, t.chartArea, 0) || a.inRange(e.x, e.y, r) && s.push({ element: a, datasetIndex: l, index: u }) }, !0), s } function xp(t, e, n, r, i, s) { return s || t.isPointInArea(e) ? "r" !== n || r ? function F4(t, e, n, r, i, s) { let o = []; const a = function O4(t) { const e = -1 !== t.indexOf("x"), n = -1 !== t.indexOf("y"); return function (r, i) { const s = e ? Math.abs(r.x - i.x) : 0, o = n ? Math.abs(r.y - i.y) : 0; return Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2)) } }(n); let l = Number.POSITIVE_INFINITY; return Xa(t, n, e, function u(c, d, f) { const h = c.inRange(e.x, e.y, i); if (r && !h) return; const p = c.getCenterPoint(i); if (!s && !t.isPointInArea(p) && !h) return; const y = a(e, p); y < l ? (o = [{ element: c, datasetIndex: d, index: f }], l = y) : y === l && o.push({ element: c, datasetIndex: d, index: f }) }), o }(t, e, n, r, i, s) : function R4(t, e, n, r) { let i = []; return Xa(t, n, e, function s(o, a, l) { const { startAngle: u, endAngle: c } = o.getProps(["startAngle", "endAngle"], r), { angle: d } = Lv(o, { x: e.x, y: e.y }); Ha(d, u, c) && i.push({ element: o, datasetIndex: a, index: l }) }), i }(t, e, n, i) : [] } function Ab(t, e, n, r, i) { const s = [], o = "x" === n ? "inXRange" : "inYRange"; let a = !1; return Xa(t, n, e, (l, u, c) => { l[o](e[n], i) && (s.push({ element: l, datasetIndex: u, index: c }), a = a || l.inRange(e.x, e.y, i)) }), r && !a ? [] : s } var N4 = { evaluateInteractionItems: Xa, modes: { index(t, e, n, r) { const i = rr(e, t), s = n.axis || "x", o = n.includeInvisible || !1, a = n.intersect ? Cp(t, i, s, r, o) : xp(t, i, s, !1, r, o), l = []; return a.length ? (t.getSortedVisibleDatasetMetas().forEach(u => { const c = a[0].index, d = u.data[c]; d && !d.skip && l.push({ element: d, datasetIndex: u.index, index: c }) }), l) : [] }, dataset(t, e, n, r) { const i = rr(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; let a = n.intersect ? Cp(t, i, s, r, o) : xp(t, i, s, !1, r, o); if (a.length > 0) { const l = a[0].datasetIndex, u = t.getDatasetMeta(l).data; a = []; for (let c = 0; c < u.length; ++c)a.push({ element: u[c], datasetIndex: l, index: c }) } return a }, point: (t, e, n, r) => Cp(t, rr(e, t), n.axis || "xy", r, n.includeInvisible || !1), nearest: (t, e, n, r) => xp(t, rr(e, t), n.axis || "xy", n.intersect, r, n.includeInvisible || !1), x: (t, e, n, r) => Ab(t, rr(e, t), "x", n.intersect, r), y: (t, e, n, r) => Ab(t, rr(e, t), "y", n.intersect, r) } }; const Pb = ["left", "top", "right", "bottom"]; function Qa(t, e) { return t.filter(n => n.pos === e) } function Ob(t, e) { return t.filter(n => -1 === Pb.indexOf(n.pos) && n.box.axis === e) } function Ka(t, e) { return t.sort((n, r) => { const i = e ? r : n, s = e ? n : r; return i.weight === s.weight ? i.index - s.index : i.weight - s.weight }) } function Rb(t, e, n, r) { return Math.max(t[n], e[n]) + Math.max(t[r], e[r]) } function Fb(t, e) { t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right) } function j4(t, e, n, r) { const { pos: i, box: s } = n, o = t.maxPadding; if (!se(i)) { n.size && (t[i] -= n.size); const d = r[n.stack] || { size: 0, count: 1 }; d.size = Math.max(d.size, n.horizontal ? s.height : s.width), n.size = d.size / d.count, t[i] += n.size } s.getPadding && Fb(o, s.getPadding()); const a = Math.max(0, e.outerWidth - Rb(o, t, "left", "right")), l = Math.max(0, e.outerHeight - Rb(o, t, "top", "bottom")), u = a !== t.w, c = l !== t.h; return t.w = a, t.h = l, n.horizontal ? { same: u, other: c } : { same: c, other: u } } function U4(t, e) { const n = e.maxPadding; return function r(i) { const s = { left: 0, top: 0, right: 0, bottom: 0 }; return i.forEach(o => { s[o] = Math.max(e[o], n[o]) }), s }(t ? ["left", "right"] : ["top", "bottom"]) } function Ja(t, e, n, r) { const i = []; let s, o, a, l, u, c; for (s = 0, o = t.length, u = 0; s < o; ++s) { a = t[s], l = a.box, l.update(a.width || e.w, a.height || e.h, U4(a.horizontal, e)); const { same: d, other: f } = j4(e, n, a, r); u |= d && i.length, c = c || f, l.fullSize || i.push(a) } return u && Ja(i, e, n, r) || c } function z0(t, e, n, r, i) { t.top = n, t.left = e, t.right = e + r, t.bottom = n + i, t.width = r, t.height = i } function Nb(t, e, n, r) { const i = n.padding; let { x: s, y: o } = e; for (const a of t) { const l = a.box, u = r[a.stack] || { count: 1, placed: 0, weight: 1 }, c = a.stackWeight / u.weight || 1; if (a.horizontal) { const d = e.w * c, f = u.size || l.height; Ba(u.start) && (o = u.start), l.fullSize ? z0(l, i.left, o, n.outerWidth - i.right - i.left, f) : z0(l, e.left + u.placed, o, d, f), u.start = o, u.placed += d, o = l.bottom } else { const d = e.h * c, f = u.size || l.width; Ba(u.start) && (s = u.start), l.fullSize ? z0(l, s, i.top, f, n.outerHeight - i.bottom - i.top) : z0(l, s, e.top + u.placed, f, d), u.start = s, u.placed += d, s = l.right } } e.x = s, e.y = o } var vt = { addBox(t, e) { t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw(n) { e.draw(n) } }] }, t.boxes.push(e) }, removeBox(t, e) { const n = t.boxes ? t.boxes.indexOf(e) : -1; -1 !== n && t.boxes.splice(n, 1) }, configure(t, e, n) { e.fullSize = n.fullSize, e.position = n.position, e.weight = n.weight }, update(t, e, n, r) { if (!t) return; const i = wt(t.options.layout.padding), s = Math.max(e - i.width, 0), o = Math.max(n - i.height, 0), a = function B4(t) { const e = function L4(t) { const e = []; let n, r, i, s, o, a; for (n = 0, r = (t || []).length; n < r; ++n)i = t[n], ({ position: s, options: { stack: o, stackWeight: a = 1 } } = i), e.push({ index: n, box: i, pos: s, horizontal: i.isHorizontal(), weight: i.weight, stack: o && s + o, stackWeight: a }); return e }(t), n = Ka(e.filter(u => u.box.fullSize), !0), r = Ka(Qa(e, "left"), !0), i = Ka(Qa(e, "right")), s = Ka(Qa(e, "top"), !0), o = Ka(Qa(e, "bottom")), a = Ob(e, "x"), l = Ob(e, "y"); return { fullSize: n, leftAndTop: r.concat(s), rightAndBottom: i.concat(l).concat(o).concat(a), chartArea: Qa(e, "chartArea"), vertical: r.concat(i).concat(l), horizontal: s.concat(o).concat(a) } }(t.boxes), l = a.vertical, u = a.horizontal; re(t.boxes, m => { "function" == typeof m.beforeLayout && m.beforeLayout() }); const c = l.reduce((m, y) => y.box.options && !1 === y.box.options.display ? m : m + 1, 0) || 1, d = Object.freeze({ outerWidth: e, outerHeight: n, padding: i, availableWidth: s, availableHeight: o, vBoxMaxWidth: s / 2 / c, hBoxMaxHeight: o / 2 }), f = Object.assign({}, i); Fb(f, wt(r)); const h = Object.assign({ maxPadding: f, w: s, h: o, x: i.left, y: i.top }, i), p = function V4(t, e) { const n = function Z4(t) { const e = {}; for (const n of t) { const { stack: r, pos: i, stackWeight: s } = n; if (!r || !Pb.includes(i)) continue; const o = e[r] || (e[r] = { count: 0, placed: 0, weight: 0, size: 0 }); o.count++, o.weight += s } return e }(t), { vBoxMaxWidth: r, hBoxMaxHeight: i } = e; let s, o, a; for (s = 0, o = t.length; s < o; ++s) { a = t[s]; const { fullSize: l } = a.box, u = n[a.stack], c = u && a.stackWeight / u.weight; a.horizontal ? (a.width = c ? c * r : l && e.availableWidth, a.height = i) : (a.width = r, a.height = c ? c * i : l && e.availableHeight) } return n }(l.concat(u), d); Ja(a.fullSize, h, d, p), Ja(l, h, d, p), Ja(u, h, d, p) && Ja(l, h, d, p), function H4(t) { const e = t.maxPadding; function n(r) { const i = Math.max(e[r] - t[r], 0); return t[r] += i, i } t.y += n("top"), t.x += n("left"), n("right"), n("bottom") }(h), Nb(a.leftAndTop, h, d, p), h.x += h.w, h.y += h.h, Nb(a.rightAndBottom, h, d, p), t.chartArea = { left: h.left, top: h.top, right: h.left + h.w, bottom: h.top + h.h, height: h.h, width: h.w }, re(a.chartArea, m => { const y = m.box; Object.assign(y, t.chartArea), y.update(h.w, h.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class Lb { acquireContext(e, n) { } releaseContext(e) { return !1 } addEventListener(e, n, r) { } removeEventListener(e, n, r) { } getDevicePixelRatio() { return 1 } getMaximumSize(e, n, r, i) { return n = Math.max(0, n || e.width), r = r || e.height, { width: n, height: Math.max(0, i ? Math.floor(n / i) : r) } } isAttached(e) { return !0 } updateConfig(e) { } } class $4 extends Lb { acquireContext(e) { return e && e.getContext && e.getContext("2d") || null } updateConfig(e) { e.options.animation = !1 } } const W0 = "$chartjs", z4 = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, Zb = t => null === t || "" === t, Vb = !!GN && { passive: !0 }; function G4(t, e, n) { t.canvas.removeEventListener(e, n, Vb) } function q0(t, e) { for (const n of t) if (n === e || n.contains(e)) return !0 } function X4(t, e, n) { const r = t.canvas, i = new MutationObserver(s => { let o = !1; for (const a of s) o = o || q0(a.addedNodes, r), o = o && !q0(a.removedNodes, r); o && n() }); return i.observe(document, { childList: !0, subtree: !0 }), i } function Q4(t, e, n) { const r = t.canvas, i = new MutationObserver(s => { let o = !1; for (const a of s) o = o || q0(a.removedNodes, r), o = o && !q0(a.addedNodes, r); o && n() }); return i.observe(document, { childList: !0, subtree: !0 }), i } const el = new Map; let Bb = 0; function jb() { const t = window.devicePixelRatio; t !== Bb && (Bb = t, el.forEach((e, n) => { n.currentDevicePixelRatio !== t && e() })) } function eL(t, e, n) { const r = t.canvas, i = r && wp(r); if (!i) return; const s = Hv((a, l) => { const u = i.clientWidth; n(a, l), u < i.clientWidth && n() }, window), o = new ResizeObserver(a => { const l = a[0], u = l.contentRect.width, c = l.contentRect.height; 0 === u && 0 === c || s(u, c) }); return o.observe(i), function K4(t, e) { el.size || window.addEventListener("resize", jb), el.set(t, e) }(t, s), o } function Ep(t, e, n) { n && n.disconnect(), "resize" === e && function J4(t) { el.delete(t), el.size || window.removeEventListener("resize", jb) }(t) } function tL(t, e, n) { const r = t.canvas, i = Hv(s => { null !== t.ctx && n(function Y4(t, e) { const n = z4[t.type] || t.type, { x: r, y: i } = rr(t, e); return { type: n, chart: e, native: t, x: void 0 !== r ? r : null, y: void 0 !== i ? i : null } }(s, t)) }, t); return function q4(t, e, n) { t.addEventListener(e, n, Vb) }(r, e, i), i } class nL extends Lb { acquireContext(e, n) { const r = e && e.getContext && e.getContext("2d"); return r && r.canvas === e ? (function W4(t, e) { const n = t.style, r = t.getAttribute("height"), i = t.getAttribute("width"); if (t[W0] = { initial: { height: r, width: i, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", Zb(i)) { const s = ub(t, "width"); void 0 !== s && (t.width = s) } if (Zb(r)) if ("" === t.style.height) t.height = t.width / (e || 2); else { const s = ub(t, "height"); void 0 !== s && (t.height = s) } }(e, n), r) : null } releaseContext(e) { const n = e.canvas; if (!n[W0]) return !1; const r = n[W0].initial;["height", "width"].forEach(s => { const o = r[s]; de(o) ? n.removeAttribute(s) : n.setAttribute(s, o) }); const i = r.style || {}; return Object.keys(i).forEach(s => { n.style[s] = i[s] }), n.width = n.width, delete n[W0], !0 } addEventListener(e, n, r) { this.removeEventListener(e, n), (e.$proxies || (e.$proxies = {}))[n] = ({ attach: X4, detach: Q4, resize: eL }[n] || tL)(e, n, r) } removeEventListener(e, n) { const r = e.$proxies || (e.$proxies = {}), i = r[n]; i && (({ attach: Ep, detach: Ep, resize: Ep }[n] || G4)(e, n, i), r[n] = void 0) } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(e, n, r, i) { return function qN(t, e, n, r) { const i = Z0(t), s = Vi(i, "margin"), o = L0(i.maxWidth, t, "clientWidth") || I0, a = L0(i.maxHeight, t, "clientHeight") || I0, l = function WN(t, e, n) { let r, i; if (void 0 === e || void 0 === n) { const s = wp(t); if (s) { const o = s.getBoundingClientRect(), a = Z0(s), l = Vi(a, "border", "width"), u = Vi(a, "padding"); e = o.width - u.width - l.width, n = o.height - u.height - l.height, r = L0(a.maxWidth, s, "clientWidth"), i = L0(a.maxHeight, s, "clientHeight") } else e = t.clientWidth, n = t.clientHeight } return { width: e, height: n, maxWidth: r || I0, maxHeight: i || I0 } }(t, e, n); let { width: u, height: c } = l; if ("content-box" === i.boxSizing) { const f = Vi(i, "border", "width"), h = Vi(i, "padding"); u -= h.width + f.width, c -= h.height + f.height } return u = Math.max(0, u - s.width), c = Math.max(0, r ? u / r : c - s.height), u = V0(Math.min(u, o, l.maxWidth)), c = V0(Math.min(c, a, l.maxHeight)), u && !c && (c = V0(u / 2)), (void 0 !== e || void 0 !== n) && r && l.height && c > l.height && (c = l.height, u = V0(Math.floor(c * r))), { width: u, height: c } }(e, n, r, i) } isAttached(e) { const n = wp(e); return !(!n || !n.isConnected) } } class Vn { constructor() { I(this, "x"), I(this, "y"), I(this, "active", !1), I(this, "options"), I(this, "$animations") } tooltipPosition(e) { const { x: n, y: r } = this.getProps(["x", "y"], e); return { x: n, y: r } } hasValue() { return io(this.x) && io(this.y) } getProps(e, n) { const r = this.$animations; if (!n || !r) return this; const i = {}; return e.forEach(s => { i[s] = r[s] && r[s].active() ? r[s]._to : this[s] }), i } } function G0(t, e, n, r, i) { const s = B(r, 0), o = Math.min(B(i, t.length), t.length); let l, u, c, a = 0; for (n = Math.ceil(n), i && (l = i - r, n = l / Math.floor(l / n)), c = s; c < 0;)a++, c = Math.round(s + a * n); for (u = Math.max(s, 0); u < o; u++)u === c && (e.push(t[u]), a++, c = Math.round(s + a * n)) } I(Vn, "defaults", {}), I(Vn, "defaultRoutes"); const Hb = (t, e, n) => "top" === e || "left" === e ? t[e] + n : t[e] - n, Ub = (t, e) => Math.min(e || t, t); function $b(t, e) { const n = [], r = t.length / e, i = t.length; let s = 0; for (; s < i; s += r)n.push(t[Math.floor(s)]); return n } function dL(t, e, n) { const r = t.ticks.length, i = Math.min(e, r - 1), s = t._startPixel, o = t._endPixel, a = 1e-6; let u, l = t.getPixelForTick(i); if (!(n && (u = 1 === r ? Math.max(l - s, o - l) : 0 === e ? (t.getPixelForTick(1) - l) / 2 : (l - t.getPixelForTick(i - 1)) / 2, l += i < e ? u : -u, l < s - a || l > o + a))) return l } function tl(t) { return t.drawTicks ? t.tickLength : 0 } function zb(t, e) { if (!t.display) return 0; const n = tt(t.font, e), r = wt(t.padding); return (De(t.text) ? t.text.length : 1) * n.lineHeight + r.height } function gL(t, e, n) { let r = up(t); return (n && "right" !== e || !n && "right" === e) && (r = (t => "left" === t ? "right" : "right" === t ? "left" : t)(r)), r } class Ui extends Vn { constructor(e) { super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(e) { this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax) } parse(e, n) { return e } getUserBounds() { let { _userMin: e, _userMax: n, _suggestedMin: r, _suggestedMax: i } = this; return e = Xt(e, Number.POSITIVE_INFINITY), n = Xt(n, Number.NEGATIVE_INFINITY), r = Xt(r, Number.POSITIVE_INFINITY), i = Xt(i, Number.NEGATIVE_INFINITY), { min: Xt(e, r), max: Xt(n, i), minDefined: Ne(e), maxDefined: Ne(n) } } getMinMax(e) { let o, { min: n, max: r, minDefined: i, maxDefined: s } = this.getUserBounds(); if (i && s) return { min: n, max: r }; const a = this.getMatchingVisibleMetas(); for (let l = 0, u = a.length; l < u; ++l)o = a[l].controller.getMinMax(this, e), i || (n = Math.min(n, o.min)), s || (r = Math.max(r, o.max)); return n = s && n > r ? r : n, r = i && n > r ? n : r, { min: Xt(n, Xt(r, n)), max: Xt(r, Xt(n, r)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const e = this.chart.data; return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [] } getLabelItems(e = this.chart.chartArea) { return this._labelItems || (this._labelItems = this._computeLabelItems(e)) } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { z(this.options.beforeUpdate, [this]) } update(e, n, r) { const { beginAtZero: i, grace: s, ticks: o } = this.options, a = o.sampleSize; this.beforeUpdate(), this.maxWidth = e, this.maxHeight = n, this._margins = r = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, r), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + r.left + r.right : this.height + r.top + r.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = function CN(t, e, n) { const { min: r, max: i } = t, s = Sv(e, (i - r) / 2), o = (a, l) => n && 0 === a ? 0 : a + l; return { min: o(r, -Math.abs(s)), max: o(i, s) } }(this, s, i), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = a < this.ticks.length; this._convertTicksToLabels(l ? $b(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || "auto" === o.source) && (this.ticks = function iL(t, e) { const n = t.options.ticks, r = function sL(t) { const e = t.options.offset, n = t._tickSize(); return Math.floor(Math.min(t._length / n + (e ? 0 : 1), t._maxLength / n)) }(t), i = Math.min(n.maxTicksLimit || r, r), s = n.major.enabled ? function aL(t) { const e = []; let n, r; for (n = 0, r = t.length; n < r; n++)t[n].major && e.push(n); return e }(e) : [], o = s.length, a = s[0], l = s[o - 1], u = []; if (o > i) return function lL(t, e, n, r) { let o, i = 0, s = n[0]; for (r = Math.ceil(r), o = 0; o < t.length; o++)o === s && (e.push(t[o]), i++, s = n[i * r]) }(e, u, s, o / i), u; const c = function oL(t, e, n) { const r = function uL(t) { const e = t.length; let n, r; if (e < 2) return !1; for (r = t[0], n = 1; n < e; ++n)if (t[n] - t[n - 1] !== r) return !1; return r }(t), i = e.length / n; if (!r) return Math.max(i, 1); const s = function QF(t) { const e = [], n = Math.sqrt(t); let r; for (r = 1; r < n; r++)t % r == 0 && (e.push(r), e.push(t / r)); return n === (0 | n) && e.push(n), e.sort((i, s) => i - s).pop(), e }(r); for (let o = 0, a = s.length - 1; o < a; o++) { const l = s[o]; if (l > i) return l } return Math.max(i, 1) }(s, e, i); if (o > 0) { let d, f; const h = o > 1 ? Math.round((l - a) / (o - 1)) : null; for (G0(e, u, c, de(h) ? 0 : a - h, a), d = 0, f = o - 1; d < f; d++)G0(e, u, c, s[d], s[d + 1]); return G0(e, u, c, l, de(h) ? e.length : l + h), u } return G0(e, u, c), u }(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let n, r, e = this.options.reverse; this.isHorizontal() ? (n = this.left, r = this.right) : (n = this.top, r = this.bottom, e = !e), this._startPixel = n, this._endPixel = r, this._reversePixels = e, this._length = r - n, this._alignToPixels = this.options.alignToPixels } afterUpdate() { z(this.options.afterUpdate, [this]) } beforeSetDimensions() { z(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { z(this.options.afterSetDimensions, [this]) } _callHooks(e) { this.chart.notifyPlugins(e, this.getContext()), z(this.options[e], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { z(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(e) { const n = this.options.ticks; let r, i, s; for (r = 0, i = e.length; r < i; r++)s = e[r], s.label = z(n.callback, [s.value, r, e], this) } afterTickToLabelConversion() { z(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { z(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const e = this.options, n = e.ticks, r = Ub(this.ticks.length, e.ticks.maxTicksLimit), i = n.minRotation || 0, s = n.maxRotation; let a, l, u, o = i; if (!this._isVisible() || !n.display || i >= s || r <= 1 || !this.isHorizontal()) return void (this.labelRotation = i); const c = this._getLabelSizes(), d = c.widest.width, f = c.highest.height, h = at(this.chart.width - d, 0, this.maxWidth); a = e.offset ? this.maxWidth / r : h / (r - 1), d + 6 > a && (a = h / (r - (e.offset ? .5 : 1)), l = this.maxHeight - tl(e.grid) - n.padding - zb(e.title, this.chart.options.font), u = Math.sqrt(d * d + f * f), o = op(Math.min(Math.asin(at((c.highest.height + 6) / a, -1, 1)), Math.asin(at(l / u, -1, 1)) - Math.asin(at(f / u, -1, 1)))), o = Math.max(i, Math.min(s, o))), this.labelRotation = o } afterCalculateLabelRotation() { z(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { z(this.options.beforeFit, [this]) } fit() { const e = { width: 0, height: 0 }, { chart: n, options: { ticks: r, title: i, grid: s } } = this, o = this._isVisible(), a = this.isHorizontal(); if (o) { const l = zb(i, n.options.font); if (a ? (e.width = this.maxWidth, e.height = tl(s) + l) : (e.height = this.maxHeight, e.width = tl(s) + l), r.display && this.ticks.length) { const { first: u, last: c, widest: d, highest: f } = this._getLabelSizes(), h = 2 * r.padding, p = Ln(this.labelRotation), m = Math.cos(p), y = Math.sin(p); a ? e.height = Math.min(this.maxHeight, e.height + (r.mirror ? 0 : y * d.width + m * f.height) + h) : e.width = Math.min(this.maxWidth, e.width + (r.mirror ? 0 : m * d.width + y * f.height) + h), this._calculatePadding(u, c, y, m) } } this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom) } _calculatePadding(e, n, r, i) { const { ticks: { align: s, padding: o }, position: a } = this.options, l = 0 !== this.labelRotation, u = "top" !== a && "x" === this.axis; if (this.isHorizontal()) { const c = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1); let f = 0, h = 0; l ? u ? (f = i * e.width, h = r * n.height) : (f = r * e.height, h = i * n.width) : "start" === s ? h = n.width : "end" === s ? f = e.width : "inner" !== s && (f = e.width / 2, h = n.width / 2), this.paddingLeft = Math.max((f - c + o) * this.width / (this.width - c), 0), this.paddingRight = Math.max((h - d + o) * this.width / (this.width - d), 0) } else { let c = n.height / 2, d = e.height / 2; "start" === s ? (c = 0, d = e.height) : "end" === s && (c = n.height, d = 0), this.paddingTop = c + o, this.paddingBottom = d + o } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { z(this.options.afterFit, [this]) } isHorizontal() { const { axis: e, position: n } = this.options; return "top" === n || "bottom" === n || "x" === e } isFullSize() { return this.options.fullSize } _convertTicksToLabels(e) { let n, r; for (this.beforeTickToLabelConversion(), this.generateTickLabels(e), n = 0, r = e.length; n < r; n++)de(e[n].label) && (e.splice(n, 1), r--, n--); this.afterTickToLabelConversion() } _getLabelSizes() { let e = this._labelSizes; if (!e) { const n = this.options.ticks.sampleSize; let r = this.ticks; n < r.length && (r = $b(r, n)), this._labelSizes = e = this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit) } return e } _computeLabelSizes(e, n, r) { const { ctx: i, _longestTextCache: s } = this, o = [], a = [], l = Math.floor(n / Ub(n, r)); let d, f, h, p, m, y, v, w, T, C, D, u = 0, c = 0; for (d = 0; d < n; d += l) { if (p = e[d].label, m = this._resolveTickFontOptions(d), i.font = y = m.string, v = s[y] = s[y] || { data: {}, gc: [] }, w = m.lineHeight, T = C = 0, de(p) || De(p)) { if (De(p)) for (f = 0, h = p.length; f < h; ++f)D = p[f], !de(D) && !De(D) && (T = O0(i, v.data, v.gc, T, D), C += w) } else T = O0(i, v.data, v.gc, T, p), C = w; o.push(T), a.push(C), u = Math.max(T, u), c = Math.max(C, c) } !function fL(t, e) { re(t, n => { const r = n.gc, i = r.length / 2; let s; if (i > e) { for (s = 0; s < i; ++s)delete n.data[r[s]]; r.splice(0, i) } }) }(s, n); const M = o.indexOf(u), S = a.indexOf(c), A = F => ({ width: o[F] || 0, height: a[F] || 0 }); return { first: A(0), last: A(n - 1), widest: A(M), highest: A(S), widths: o, heights: a } } getLabelForValue(e) { return e } getPixelForValue(e, n) { return NaN } getValueForPixel(e) { } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getPixelForDecimal(e) { this._reversePixels && (e = 1 - e); const n = this._startPixel + e * this._length; return function eN(t) { return at(t, -32768, 32767) }(this._alignToPixels ? Ni(this.chart, n, 0) : n) } getDecimalForPixel(e) { const n = (e - this._startPixel) / this._length; return this._reversePixels ? 1 - n : n } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: e, max: n } = this; return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0 } getContext(e) { const n = this.ticks || []; if (e >= 0 && e < n.length) { const r = n[e]; return r.$context || (r.$context = function pL(t, e, n) { return ni(t, { tick: n, index: e, type: "tick" }) }(this.getContext(), e, r)) } return this.$context || (this.$context = function hL(t, e) { return ni(t, { scale: e, type: "scale" }) }(this.chart.getContext(), this)) } _tickSize() { const e = this.options.ticks, n = Ln(this.labelRotation), r = Math.abs(Math.cos(n)), i = Math.abs(Math.sin(n)), s = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = s ? s.widest.width + o : 0, l = s ? s.highest.height + o : 0; return this.isHorizontal() ? l * r > a * i ? a / r : l / i : l * i < a * r ? l / r : a / i } _isVisible() { const e = this.options.display; return "auto" !== e ? !!e : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(e) { const n = this.axis, r = this.chart, i = this.options, { grid: s, position: o, border: a } = i, l = s.offset, u = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), f = tl(s), h = [], p = a.setContext(this.getContext()), m = p.display ? p.width : 0, y = m / 2, v = function (ve) { return Ni(r, ve, m) }; let w, T, C, D, M, S, A, F, W, q, te, Ue; if ("top" === o) w = v(this.bottom), S = this.bottom - f, F = w - y, q = v(e.top) + y, Ue = e.bottom; else if ("bottom" === o) w = v(this.top), q = e.top, Ue = v(e.bottom) - y, S = w + y, F = this.top + f; else if ("left" === o) w = v(this.right), M = this.right - f, A = w - y, W = v(e.left) + y, te = e.right; else if ("right" === o) w = v(this.left), W = e.left, te = v(e.right) - y, M = w + y, A = this.left + f; else if ("x" === n) { if ("center" === o) w = v((e.top + e.bottom) / 2 + .5); else if (se(o)) { const ve = Object.keys(o)[0]; w = v(this.chart.scales[ve].getPixelForValue(o[ve])) } q = e.top, Ue = e.bottom, S = w + y, F = S + f } else if ("y" === n) { if ("center" === o) w = v((e.left + e.right) / 2); else if (se(o)) { const ve = Object.keys(o)[0]; w = v(this.chart.scales[ve].getPixelForValue(o[ve])) } M = w - y, A = M - f, W = e.left, te = e.right } const ft = B(i.ticks.maxTicksLimit, d), he = Math.max(1, Math.ceil(d / ft)); for (T = 0; T < d; T += he) { const ve = this.getContext(T), $e = s.setContext(ve), Bn = a.setContext(ve), bt = $e.lineWidth, fo = $e.color, ac = Bn.dash || [], ho = Bn.dashOffset, dl = $e.tickWidth, fl = $e.tickColor, hl = $e.tickBorderDash || [], pl = $e.tickBorderDashOffset; C = dL(this, T, l), void 0 !== C && (D = Ni(r, C, bt), u ? M = A = W = te = D : S = F = q = Ue = D, h.push({ tx1: M, ty1: S, tx2: A, ty2: F, x1: W, y1: q, x2: te, y2: Ue, width: bt, color: fo, borderDash: ac, borderDashOffset: ho, tickWidth: dl, tickColor: fl, tickBorderDash: hl, tickBorderDashOffset: pl })) } return this._ticksLength = d, this._borderValue = w, h } _computeLabelItems(e) { const n = this.axis, r = this.options, { position: i, ticks: s } = r, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: u, padding: c, mirror: d } = s, f = tl(r.grid), h = f + c, p = d ? -c : h, m = -Ln(this.labelRotation), y = []; let v, w, T, C, D, M, S, A, F, W, q, te, Ue = "middle"; if ("top" === i) M = this.bottom - p, S = this._getXAxisLabelAlignment(); else if ("bottom" === i) M = this.top + p, S = this._getXAxisLabelAlignment(); else if ("left" === i) { const he = this._getYAxisLabelAlignment(f); S = he.textAlign, D = he.x } else if ("right" === i) { const he = this._getYAxisLabelAlignment(f); S = he.textAlign, D = he.x } else if ("x" === n) { if ("center" === i) M = (e.top + e.bottom) / 2 + h; else if (se(i)) { const he = Object.keys(i)[0]; M = this.chart.scales[he].getPixelForValue(i[he]) + h } S = this._getXAxisLabelAlignment() } else if ("y" === n) { if ("center" === i) D = (e.left + e.right) / 2 - h; else if (se(i)) { const he = Object.keys(i)[0]; D = this.chart.scales[he].getPixelForValue(i[he]) } S = this._getYAxisLabelAlignment(f).textAlign } "y" === n && ("start" === l ? Ue = "top" : "end" === l && (Ue = "bottom")); const ft = this._getLabelSizes(); for (v = 0, w = a.length; v < w; ++v) { T = a[v], C = T.label; const he = s.setContext(this.getContext(v)); A = this.getPixelForTick(v) + s.labelOffset, F = this._resolveTickFontOptions(v), W = F.lineHeight, q = De(C) ? C.length : 1; const ve = q / 2, $e = he.color, Bn = he.textStrokeColor, bt = he.textStrokeWidth; let ac, fo = S; if (o ? (D = A, "inner" === S && (fo = v === w - 1 ? this.options.reverse ? "left" : "right" : 0 === v ? this.options.reverse ? "right" : "left" : "center"), te = "top" === i ? "near" === u || 0 !== m ? -q * W + W / 2 : "center" === u ? -ft.highest.height / 2 - ve * W + W : W / 2 - ft.highest.height : "near" === u || 0 !== m ? W / 2 : "center" === u ? ft.highest.height / 2 - ve * W : ft.highest.height - q * W, d && (te *= -1), 0 !== m && !he.showLabelBackdrop && (D += W / 2 * Math.sin(m))) : (M = A, te = (1 - q) * W / 2), he.showLabelBackdrop) { const ho = wt(he.backdropPadding), dl = ft.heights[v], fl = ft.widths[v]; let hl = te - ho.top, pl = 0 - ho.left; switch (Ue) { case "middle": hl -= dl / 2; break; case "bottom": hl -= dl }switch (S) { case "center": pl -= fl / 2; break; case "right": pl -= fl }ac = { left: pl, top: hl, width: fl + ho.width, height: dl + ho.height, color: he.backdropColor } } y.push({ label: C, font: F, textOffset: te, options: { rotation: m, color: $e, strokeColor: Bn, strokeWidth: bt, textAlign: fo, textBaseline: Ue, translation: [D, M], backdrop: ac } }) } return y } _getXAxisLabelAlignment() { const { position: e, ticks: n } = this.options; if (-Ln(this.labelRotation)) return "top" === e ? "left" : "right"; let i = "center"; return "start" === n.align ? i = "left" : "end" === n.align ? i = "right" : "inner" === n.align && (i = "inner"), i } _getYAxisLabelAlignment(e) { const { position: n, ticks: { crossAlign: r, mirror: i, padding: s } } = this.options, a = e + s, l = this._getLabelSizes().widest.width; let u, c; return "left" === n ? i ? (c = this.right + s, "near" === r ? u = "left" : "center" === r ? (u = "center", c += l / 2) : (u = "right", c += l)) : (c = this.right - a, "near" === r ? u = "right" : "center" === r ? (u = "center", c -= l / 2) : (u = "left", c = this.left)) : "right" === n ? i ? (c = this.left + s, "near" === r ? u = "right" : "center" === r ? (u = "center", c -= l / 2) : (u = "left", c -= l)) : (c = this.left + a, "near" === r ? u = "left" : "center" === r ? (u = "center", c += l / 2) : (u = "right", c = this.right)) : u = "right", { textAlign: u, x: c } } _computeLabelArea() { if (this.options.ticks.mirror) return; const e = this.chart, n = this.options.position; return "left" === n || "right" === n ? { top: 0, left: this.left, bottom: e.height, right: this.right } : "top" === n || "bottom" === n ? { top: this.top, left: 0, bottom: this.bottom, right: e.width } : void 0 } drawBackground() { const { ctx: e, options: { backgroundColor: n }, left: r, top: i, width: s, height: o } = this; n && (e.save(), e.fillStyle = n, e.fillRect(r, i, s, o), e.restore()) } getLineWidthForValue(e) { const n = this.options.grid; if (!this._isVisible() || !n.display) return 0; const i = this.ticks.findIndex(s => s.value === e); return i >= 0 ? n.setContext(this.getContext(i)).lineWidth : 0 } drawGrid(e) { const n = this.options.grid, r = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e)); let s, o; const a = (l, u, c) => { !c.width || !c.color || (r.save(), r.lineWidth = c.width, r.strokeStyle = c.color, r.setLineDash(c.borderDash || []), r.lineDashOffset = c.borderDashOffset, r.beginPath(), r.moveTo(l.x, l.y), r.lineTo(u.x, u.y), r.stroke(), r.restore()) }; if (n.display) for (s = 0, o = i.length; s < o; ++s) { const l = i[s]; n.drawOnChartArea && a({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l), n.drawTicks && a({ x: l.tx1, y: l.ty1 }, { x: l.tx2, y: l.ty2 }, { color: l.tickColor, width: l.tickWidth, borderDash: l.tickBorderDash, borderDashOffset: l.tickBorderDashOffset }) } } drawBorder() { const { chart: e, ctx: n, options: { border: r, grid: i } } = this, s = r.setContext(this.getContext()), o = r.display ? s.width : 0; if (!o) return; const a = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue; let u, c, d, f; this.isHorizontal() ? (u = Ni(e, this.left, o) - o / 2, c = Ni(e, this.right, a) + a / 2, d = f = l) : (d = Ni(e, this.top, o) - o / 2, f = Ni(e, this.bottom, a) + a / 2, u = c = l), n.save(), n.lineWidth = s.width, n.strokeStyle = s.color, n.beginPath(), n.moveTo(u, d), n.lineTo(c, f), n.stroke(), n.restore() } drawLabels(e) { if (!this.options.ticks.display) return; const r = this.ctx, i = this._computeLabelArea(); i && R0(r, i); const s = this.getLabelItems(e); for (const o of s) Li(r, o.label, 0, o.textOffset, o.font, o.options); i && F0(r) } drawTitle() { const { ctx: e, options: { position: n, title: r, reverse: i } } = this; if (!r.display) return; const s = tt(r.font), o = wt(r.padding), a = r.align; let l = s.lineHeight / 2; "bottom" === n || "center" === n || se(n) ? (l += o.bottom, De(r.text) && (l += s.lineHeight * (r.text.length - 1))) : l += o.top; const { titleX: u, titleY: c, maxWidth: d, rotation: f } = function mL(t, e, n, r) { const { top: i, left: s, bottom: o, right: a, chart: l } = t, { chartArea: u, scales: c } = l; let f, h, p, d = 0; const m = o - i, y = a - s; if (t.isHorizontal()) { if (h = yt(r, s, a), se(n)) { const v = Object.keys(n)[0]; p = c[v].getPixelForValue(n[v]) + m - e } else p = "center" === n ? (u.bottom + u.top) / 2 + m - e : Hb(t, n, e); f = a - s } else { if (se(n)) { const v = Object.keys(n)[0]; h = c[v].getPixelForValue(n[v]) - y + e } else h = "center" === n ? (u.left + u.right) / 2 - y + e : Hb(t, n, e); p = yt(r, o, i), d = "left" === n ? -Le : Le } return { titleX: h, titleY: p, maxWidth: f, rotation: d } }(this, l, n, a); Li(e, r.text, 0, 0, s, { color: r.color, maxWidth: d, rotation: f, textAlign: gL(a, n, i), textBaseline: "middle", translation: [u, c] }) } draw(e) { !this._isVisible() || (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e)) } _layers() { const e = this.options, n = e.ticks && e.ticks.z || 0, r = B(e.grid && e.grid.z, -1), i = B(e.border && e.border.z, 0); return this._isVisible() && this.draw === Ui.prototype.draw ? [{ z: r, draw: s => { this.drawBackground(), this.drawGrid(s), this.drawTitle() } }, { z: i, draw: () => { this.drawBorder() } }, { z: n, draw: s => { this.drawLabels(s) } }] : [{ z: n, draw: s => { this.draw(s) } }] } getMatchingVisibleMetas(e) { const n = this.chart.getSortedVisibleDatasetMetas(), r = this.axis + "AxisID", i = []; let s, o; for (s = 0, o = n.length; s < o; ++s) { const a = n[s]; a[r] === this.id && (!e || a.type === e) && i.push(a) } return i } _resolveTickFontOptions(e) { return tt(this.options.ticks.setContext(this.getContext(e)).font) } _maxDigits() { const e = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / e } } class Y0 { constructor(e, n, r) { this.type = e, this.scope = n, this.override = r, this.items = Object.create(null) } isForType(e) { return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype) } register(e) { const n = Object.getPrototypeOf(e); let r; (function wL(t) { return "id" in t && "defaults" in t })(n) && (r = this.register(n)); const i = this.items, s = e.id, o = this.scope + "." + s; if (!s) throw new Error("class does not have id: " + e); return s in i || (i[s] = e, function _L(t, e, n) { const r = Za(Object.create(null), [n ? Ze.get(n) : {}, Ze.get(e), t.defaults]); Ze.set(e, r), t.defaultRoutes && function yL(t, e) { Object.keys(e).forEach(n => { const r = n.split("."), i = r.pop(), s = [t].concat(r).join("."), o = e[n].split("."), a = o.pop(), l = o.join("."); Ze.route(s, i, l, a) }) }(e, t.defaultRoutes), t.descriptors && Ze.describe(e, t.descriptors) }(e, o, r), this.override && Ze.override(e.id, e.overrides)), o } get(e) { return this.items[e] } unregister(e) { const n = this.items, r = e.id, i = this.scope; r in n && delete n[r], i && r in Ze[i] && (delete Ze[i][r], this.override && delete Fi[r]) } } class vL { constructor() { this.controllers = new Y0(Zn, "datasets", !0), this.elements = new Y0(Vn, "elements"), this.plugins = new Y0(Object, "plugins"), this.scales = new Y0(Ui, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...e) { this._each("register", e) } remove(...e) { this._each("unregister", e) } addControllers(...e) { this._each("register", e, this.controllers) } addElements(...e) { this._each("register", e, this.elements) } addPlugins(...e) { this._each("register", e, this.plugins) } addScales(...e) { this._each("register", e, this.scales) } getController(e) { return this._get(e, this.controllers, "controller") } getElement(e) { return this._get(e, this.elements, "element") } getPlugin(e) { return this._get(e, this.plugins, "plugin") } getScale(e) { return this._get(e, this.scales, "scale") } removeControllers(...e) { this._each("unregister", e, this.controllers) } removeElements(...e) { this._each("unregister", e, this.elements) } removePlugins(...e) { this._each("unregister", e, this.plugins) } removeScales(...e) { this._each("unregister", e, this.scales) } _each(e, n, r) { [...n].forEach(i => { const s = r || this._getRegistryForType(i); r || s.isForType(i) || s === this.plugins && i.id ? this._exec(e, s, i) : re(i, o => { const a = r || this._getRegistryForType(o); this._exec(e, a, o) }) }) } _exec(e, n, r) { const i = sp(e); z(r["before" + i], [], r), n[e](r), z(r["after" + i], [], r) } _getRegistryForType(e) { for (let n = 0; n < this._typedRegistries.length; n++) { const r = this._typedRegistries[n]; if (r.isForType(e)) return r } return this.plugins } _get(e, n, r) { const i = n.get(e); if (void 0 === i) throw new Error('"' + e + '" is not a registered ' + r + "."); return i } } var ir = new vL; class bL { constructor() { this._init = [] } notify(e, n, r, i) { "beforeInit" === n && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install")); const s = i ? this._descriptors(e).filter(i) : this._descriptors(e), o = this._notify(s, e, n, r); return "afterDestroy" === n && (this._notify(s, e, "stop"), this._notify(this._init, e, "uninstall")), o } _notify(e, n, r, i) { i = i || {}; for (const s of e) { const o = s.plugin; if (!1 === z(o[r], [n, i, s.options], o) && i.cancelable) return !1 } return !0 } invalidate() { de(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(e) { if (this._cache) return this._cache; const n = this._cache = this._createDescriptors(e); return this._notifyStateChanges(e), n } _createDescriptors(e, n) { const r = e && e.config, i = B(r.options && r.options.plugins, {}), s = function TL(t) { const e = {}, n = [], r = Object.keys(ir.plugins.items); for (let s = 0; s < r.length; s++)n.push(ir.getPlugin(r[s])); const i = t.plugins || []; for (let s = 0; s < i.length; s++) { const o = i[s]; -1 === n.indexOf(o) && (n.push(o), e[o.id] = !0) } return { plugins: n, localIds: e } }(r); return !1 !== i || n ? function DL(t, { plugins: e, localIds: n }, r, i) { const s = [], o = t.getContext(); for (const a of e) { const l = a.id, u = kL(r[l], i); null !== u && s.push({ plugin: a, options: CL(t.config, { plugin: a, local: n[l] }, u, o) }) } return s }(e, s, i, n) : [] } _notifyStateChanges(e) { const n = this._oldCache || [], r = this._cache, i = (s, o) => s.filter(a => !o.some(l => a.plugin.id === l.plugin.id)); this._notify(i(n, r), e, "stop"), this._notify(i(r, n), e, "start") } } function kL(t, e) { return e || !1 !== t ? !0 === t ? {} : t : null } function CL(t, { plugin: e, local: n }, r, i) { const s = t.pluginScopeKeys(e), o = t.getOptionScopes(r, s); return n && e.defaults && o.push(e.defaults), t.createResolver(o, i, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function Mp(t, e) { return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || (Ze.datasets[t] || {}).indexAxis || "x" } function Wb(t) { if ("x" === t || "y" === t || "r" === t) return t } function ML(t) { return "top" === t || "bottom" === t ? "x" : "left" === t || "right" === t ? "y" : void 0 } function Sp(t, ...e) { if (Wb(t)) return t; for (const n of e) { const r = n.axis || ML(n.position) || t.length > 1 && Wb(t[0].toLowerCase()); if (r) return r } throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`) } function qb(t, e, n) { if (n[e + "AxisID"] === t) return { axis: e } } function Gb(t) { const e = t.options || (t.options = {}); e.plugins = B(e.plugins, {}), e.scales = function IL(t, e) { const n = Fi[t.type] || { scales: {} }, r = e.scales || {}, i = Mp(t.type, e), s = Object.create(null); return Object.keys(r).forEach(o => { const a = r[o]; if (!se(a)) return console.error(`Invalid scale configuration for scale: ${o}`); if (a._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${o}`); const l = Sp(o, a, function SL(t, e) { if (e.data && e.data.datasets) { const n = e.data.datasets.filter(r => r.xAxisID === t || r.yAxisID === t); if (n.length) return qb(t, "x", n[0]) || qb(t, "y", n[0]) } return {} }(o, t), Ze.scales[a.type]), u = function EL(t, e) { return t === e ? "_index_" : "_value_" }(l, i), c = n.scales || {}; s[o] = Va(Object.create(null), [{ axis: l }, a, c[l], c[u]]) }), t.data.datasets.forEach(o => { const a = o.type || t.type, l = o.indexAxis || Mp(a, e), c = (Fi[a] || {}).scales || {}; Object.keys(c).forEach(d => { const f = function xL(t, e) { let n = t; return "_index_" === t ? n = e : "_value_" === t && (n = "x" === e ? "y" : "x"), n }(d, l), h = o[f + "AxisID"] || f; s[h] = s[h] || Object.create(null), Va(s[h], [{ axis: f }, r[h], c[d]]) }) }), Object.keys(s).forEach(o => { const a = s[o]; Va(a, [Ze.scales[a.type], Ze.scale]) }), s }(t, e) } function Yb(t) { return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t } const Xb = new Map, Qb = new Set; function X0(t, e) { let n = Xb.get(t); return n || (n = e(), Xb.set(t, n), Qb.add(n)), n } const nl = (t, e, n) => { const r = Jr(e, n); void 0 !== r && t.add(r) }; class PL { constructor(e) { this._config = function AL(t) { return (t = t || {}).data = Yb(t.data), Gb(t), t }(e), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(e) { this._config.type = e } get data() { return this._config.data } set data(e) { this._config.data = Yb(e) } get options() { return this._config.options } set options(e) { this._config.options = e } get plugins() { return this._config.plugins } update() { const e = this._config; this.clearCache(), Gb(e) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(e) { return X0(e, () => [[`datasets.${e}`, ""]]) } datasetAnimationScopeKeys(e, n) { return X0(`${e}.transition.${n}`, () => [[`datasets.${e}.transitions.${n}`, `transitions.${n}`], [`datasets.${e}`, ""]]) } datasetElementScopeKeys(e, n) { return X0(`${e}-${n}`, () => [[`datasets.${e}.elements.${n}`, `datasets.${e}`, `elements.${n}`, ""]]) } pluginScopeKeys(e) { const n = e.id; return X0(`${this.type}-plugin-${n}`, () => [[`plugins.${n}`, ...e.additionalOptionScopes || []]]) } _cachedScopes(e, n) { const r = this._scopeCache; let i = r.get(e); return (!i || n) && (i = new Map, r.set(e, i)), i } getOptionScopes(e, n, r) { const { options: i, type: s } = this, o = this._cachedScopes(e, r), a = o.get(n); if (a) return a; const l = new Set; n.forEach(c => { e && (l.add(e), c.forEach(d => nl(l, e, d))), c.forEach(d => nl(l, i, d)), c.forEach(d => nl(l, Fi[s] || {}, d)), c.forEach(d => nl(l, Ze, d)), c.forEach(d => nl(l, fp, d)) }); const u = Array.from(l); return 0 === u.length && u.push(Object.create(null)), Qb.has(n) && o.set(n, u), u } chartOptionScopes() { const { options: e, type: n } = this; return [e, Fi[n] || {}, Ze.datasets[n] || {}, { type: n }, Ze, fp] } resolveNamedOptions(e, n, r, i = [""]) { const s = { $shared: !0 }, { resolver: o, subPrefixes: a } = Kb(this._resolverCache, e, i); let l = o; (function RL(t, e) { const { isScriptable: n, isIndexable: r } = Jv(t); for (const i of e) { const s = n(i), o = r(i), a = (o || s) && t[i]; if (s && (ei(a) || OL(a)) || o && De(a)) return !0 } return !1 })(o, n) && (s.$shared = !1, l = so(o, r = ei(r) ? r() : r, this.createResolver(e, r, a))); for (const u of n) s[u] = l[u]; return s } createResolver(e, n, r = [""], i) { const { resolver: s } = Kb(this._resolverCache, e, r); return se(n) ? so(s, n, void 0, i) : s } } function Kb(t, e, n) { let r = t.get(e); r || (r = new Map, t.set(e, r)); const i = n.join(); let s = r.get(i); return s || (s = { resolver: mp(e, n), subPrefixes: n.filter(a => !a.toLowerCase().includes("hover")) }, r.set(i, s)), s } const OL = t => se(t) && Object.getOwnPropertyNames(t).reduce((e, n) => e || ei(t[n]), !1), NL = ["top", "bottom", "left", "right", "chartArea"]; function Jb(t, e) { return "top" === t || "bottom" === t || -1 === NL.indexOf(t) && "x" === e } function eT(t, e) { return function (n, r) { return n[t] === r[t] ? n[e] - r[e] : n[t] - r[t] } } function tT(t) { const e = t.chart, n = e.options.animation; e.notifyPlugins("afterRender"), z(n && n.onComplete, [t], e) } function LL(t) { const e = t.chart, n = e.options.animation; z(n && n.onProgress, [t], e) } function nT(t) { return ab() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const Q0 = {}, rT = t => { const e = nT(t); return Object.values(Q0).filter(n => n.canvas === e).pop() }; function ZL(t, e, n) { const r = Object.keys(t); for (const i of r) { const s = +i; if (s >= e) { const o = t[i]; delete t[i], (n > 0 || s > e) && (t[s + n] = o) } } } class sr { static register(...e) { ir.add(...e), iT() } static unregister(...e) { ir.remove(...e), iT() } constructor(e, n) { const r = this.config = new PL(n), i = nT(e), s = rT(i); if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused."); const o = r.createResolver(r.chartOptionScopes(), this.getContext()); this.platform = new (r.platform || function rL(t) { return !ab() || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? $4 : nL }(i)), this.platform.updateConfig(r); const a = this.platform.acquireContext(i, o.aspectRatio), l = a && a.canvas, u = l && l.height, c = l && l.width; this.id = HF(), this.ctx = a, this.canvas = l, this.width = c, this.height = u, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new bL, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function iN(t, e) { let n; return function (...r) { return e ? (clearTimeout(n), n = setTimeout(t, e, r)) : t.apply(this, r), e } }(d => this.update(d), o.resizeDelay || 0), this._dataChanges = [], Q0[this.id] = this, a && l ? (Er.listen(this, "complete", tT), Er.listen(this, "progress", LL), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item") } get aspectRatio() { const { options: { aspectRatio: e, maintainAspectRatio: n }, width: r, height: i, _aspectRatio: s } = this; return de(e) ? n && s ? s : i ? r / i : null : e } get data() { return this.config.data } set data(e) { this.config.data = e } get options() { return this._options } set options(e) { this.config.options = e } get registry() { return ir } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : lb(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return Xv(this.canvas, this.ctx), this } stop() { return Er.stop(this), this } resize(e, n) { Er.running(this) ? this._resizeBeforeDraw = { width: e, height: n } : this._resize(e, n) } _resize(e, n) { const r = this.options, o = this.platform.getMaximumSize(this.canvas, e, n, r.maintainAspectRatio && this.aspectRatio), a = r.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach"; this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, lb(this, a, !0) && (this.notifyPlugins("resize", { size: o }), z(r.onResize, [this, o], this), this.attached && this._doResize(l) && this.render()) } ensureScalesHaveIDs() { re(this.options.scales || {}, (r, i) => { r.id = i }) } buildOrUpdateScales() { const e = this.options, n = e.scales, r = this.scales, i = Object.keys(r).reduce((o, a) => (o[a] = !1, o), {}); let s = []; n && (s = s.concat(Object.keys(n).map(o => { const a = n[o], l = Sp(o, a), u = "r" === l, c = "x" === l; return { options: a, dposition: u ? "chartArea" : c ? "bottom" : "left", dtype: u ? "radialLinear" : c ? "category" : "linear" } }))), re(s, o => { const a = o.options, l = a.id, u = Sp(l, a), c = B(a.type, o.dtype); (void 0 === a.position || Jb(a.position, u) !== Jb(o.dposition)) && (a.position = o.dposition), i[l] = !0; let d = null; l in r && r[l].type === c ? d = r[l] : (d = new (ir.getScale(c))({ id: l, type: c, ctx: this.ctx, chart: this }), r[d.id] = d), d.init(a, e) }), re(i, (o, a) => { o || delete r[a] }), re(r, o => { vt.configure(this, o, o.options), vt.addBox(this, o) }) } _updateMetasets() { const e = this._metasets, n = this.data.datasets.length, r = e.length; if (e.sort((i, s) => i.index - s.index), r > n) { for (let i = n; i < r; ++i)this._destroyDatasetMeta(i); e.splice(n, r - n) } this._sortedMetasets = e.slice(0).sort(eT("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: e, data: { datasets: n } } = this; e.length > n.length && delete this._stacks, e.forEach((r, i) => { 0 === n.filter(s => s === r._dataset).length && this._destroyDatasetMeta(i) }) } buildOrUpdateControllers() { const e = [], n = this.data.datasets; let r, i; for (this._removeUnreferencedMetasets(), r = 0, i = n.length; r < i; r++) { const s = n[r]; let o = this.getDatasetMeta(r); const a = s.type || this.config.type; if (o.type && o.type !== a && (this._destroyDatasetMeta(r), o = this.getDatasetMeta(r)), o.type = a, o.indexAxis = s.indexAxis || Mp(a, this.options), o.order = s.order || 0, o.index = r, o.label = "" + s.label, o.visible = this.isDatasetVisible(r), o.controller) o.controller.updateIndex(r), o.controller.linkScales(); else { const l = ir.getController(a), { datasetElementType: u, dataElementType: c } = Ze.datasets[a]; Object.assign(l, { dataElementType: ir.getElement(c), datasetElementType: u && ir.getElement(u) }), o.controller = new l(this, r), e.push(o.controller) } } return this._updateMetasets(), e } _resetElements() { re(this.data.datasets, (e, n) => { this.getDatasetMeta(n).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(e) { const n = this.config; n.update(); const r = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !r.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", { mode: e, cancelable: !0 })) return; const s = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let o = 0; for (let u = 0, c = this.data.datasets.length; u < c; u++) { const { controller: d } = this.getDatasetMeta(u), f = !i && -1 === s.indexOf(d); d.buildOrUpdateElements(f), o = Math.max(+d.getMaxOverflow(), o) } o = this._minPadding = r.layout.autoPadding ? o : 0, this._updateLayout(o), i || re(s, u => { u.reset() }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", { mode: e }), this._layers.sort(eT("z", "_idx")); const { _active: a, _lastEvent: l } = this; l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render() } _updateScales() { re(this.scales, e => { vt.removeBox(this, e) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const e = this.options, n = new Set(Object.keys(this._listeners)), r = new Set(e.events); (!Pv(n, r) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: e } = this, n = this._getUniformDataChanges() || []; for (const { method: r, start: i, count: s } of n) ZL(e, i, "_removeElements" === r ? -s : s) } _getUniformDataChanges() { const e = this._dataChanges; if (!e || !e.length) return; this._dataChanges = []; const n = this.data.datasets.length, r = s => new Set(e.filter(o => o[0] === s).map((o, a) => a + "," + o.splice(1).join(","))), i = r(0); for (let s = 1; s < n; s++)if (!Pv(i, r(s))) return; return Array.from(i).map(s => s.split(",")).map(s => ({ method: s[1], start: +s[2], count: +s[3] })) } _updateLayout(e) { if (!1 === this.notifyPlugins("beforeLayout", { cancelable: !0 })) return; vt.update(this, this.width, this.height, e); const n = this.chartArea, r = n.width <= 0 || n.height <= 0; this._layers = [], re(this.boxes, i => { r && "chartArea" === i.position || (i.configure && i.configure(), this._layers.push(...i._layers())) }, this), this._layers.forEach((i, s) => { i._idx = s }), this.notifyPlugins("afterLayout") } _updateDatasets(e) { if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", { mode: e, cancelable: !0 })) { for (let n = 0, r = this.data.datasets.length; n < r; ++n)this.getDatasetMeta(n).controller.configure(); for (let n = 0, r = this.data.datasets.length; n < r; ++n)this._updateDataset(n, ei(e) ? e({ datasetIndex: n }) : e); this.notifyPlugins("afterDatasetsUpdate", { mode: e }) } } _updateDataset(e, n) { const r = this.getDatasetMeta(e), i = { meta: r, index: e, mode: n, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetUpdate", i) && (r.controller._update(n), i.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", i)) } render() { !1 !== this.notifyPlugins("beforeRender", { cancelable: !0 }) && (Er.has(this) ? this.attached && !Er.running(this) && Er.start(this) : (this.draw(), tT({ chart: this }))) } draw() { let e; if (this._resizeBeforeDraw) { const { width: r, height: i } = this._resizeBeforeDraw; this._resize(r, i), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || !1 === this.notifyPlugins("beforeDraw", { cancelable: !0 })) return; const n = this._layers; for (e = 0; e < n.length && n[e].z <= 0; ++e)n[e].draw(this.chartArea); for (this._drawDatasets(); e < n.length; ++e)n[e].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(e) { const n = this._sortedMetasets, r = []; let i, s; for (i = 0, s = n.length; i < s; ++i) { const o = n[i]; (!e || o.visible) && r.push(o) } return r } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (!1 === this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 })) return; const e = this.getSortedVisibleDatasetMetas(); for (let n = e.length - 1; n >= 0; --n)this._drawDataset(e[n]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(e) { const n = this.ctx, r = e._clip, i = !r.disabled, s = function BL(t) { const { xScale: e, yScale: n } = t; if (e && n) return { left: e.left, right: e.right, top: n.top, bottom: n.bottom } }(e) || this.chartArea, o = { meta: e, index: e.index, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetDraw", o) && (i && R0(n, { left: !1 === r.left ? 0 : s.left - r.left, right: !1 === r.right ? this.width : s.right + r.right, top: !1 === r.top ? 0 : s.top - r.top, bottom: !1 === r.bottom ? this.height : s.bottom + r.bottom }), e.controller.draw(), i && F0(n), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o)) } isPointInArea(e) { return xr(e, this.chartArea, this._minPadding) } getElementsAtEventForMode(e, n, r, i) { const s = N4.modes[n]; return "function" == typeof s ? s(this, e, r, i) : [] } getDatasetMeta(e) { const n = this.data.datasets[e], r = this._metasets; let i = r.filter(s => s && s._dataset === n).pop(); return i || (i = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: n && n.order || 0, index: e, _dataset: n, _parsed: [], _sorted: !1 }, r.push(i)), i } getContext() { return this.$context || (this.$context = ni(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(e) { const n = this.data.datasets[e]; if (!n) return !1; const r = this.getDatasetMeta(e); return "boolean" == typeof r.hidden ? !r.hidden : !n.hidden } setDatasetVisibility(e, n) { this.getDatasetMeta(e).hidden = !n } toggleDataVisibility(e) { this._hiddenIndices[e] = !this._hiddenIndices[e] } getDataVisibility(e) { return !this._hiddenIndices[e] } _updateVisibility(e, n, r) { const i = r ? "show" : "hide", s = this.getDatasetMeta(e), o = s.controller._resolveAnimations(void 0, i); Ba(n) ? (s.data[n].hidden = !r, this.update()) : (this.setDatasetVisibility(e, r), o.update(s, { visible: r }), this.update(a => a.datasetIndex === e ? i : void 0)) } hide(e, n) { this._updateVisibility(e, n, !1) } show(e, n) { this._updateVisibility(e, n, !0) } _destroyDatasetMeta(e) { const n = this._metasets[e]; n && n.controller && n.controller._destroy(), delete this._metasets[e] } _stop() { let e, n; for (this.stop(), Er.remove(this), e = 0, n = this.data.datasets.length; e < n; ++e)this._destroyDatasetMeta(e) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: e, ctx: n } = this; this._stop(), this.config.clearCache(), e && (this.unbindEvents(), Xv(e, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete Q0[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...e) { return this.canvas.toDataURL(...e) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const e = this._listeners, n = this.platform, r = (s, o) => { n.addEventListener(this, s, o), e[s] = o }, i = (s, o, a) => { s.offsetX = o, s.offsetY = a, this._eventHandler(s) }; re(this.options.events, s => r(s, i)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const e = this._responsiveListeners, n = this.platform, r = (l, u) => { n.addEventListener(this, l, u), e[l] = u }, i = (l, u) => { e[l] && (n.removeEventListener(this, l, u), delete e[l]) }, s = (l, u) => { this.canvas && this.resize(l, u) }; let o; const a = () => { i("attach", a), this.attached = !0, this.resize(), r("resize", s), r("detach", o) }; o = () => { this.attached = !1, i("resize", s), this._stop(), this._resize(0, 0), r("attach", a) }, n.isAttached(this.canvas) ? a() : o() } unbindEvents() { re(this._listeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._listeners = {}, re(this._responsiveListeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._responsiveListeners = void 0 } updateHoverStyle(e, n, r) { const i = r ? "set" : "remove"; let s, o, a, l; for ("dataset" === n && (s = this.getDatasetMeta(e[0].datasetIndex), s.controller["_" + i + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) { o = e[a]; const u = o && this.getDatasetMeta(o.datasetIndex).controller; u && u[i + "HoverStyle"](o.element, o.datasetIndex, o.index) } } getActiveElements() { return this._active || [] } setActiveElements(e) { const n = this._active || [], r = e.map(({ datasetIndex: s, index: o }) => { const a = this.getDatasetMeta(s); if (!a) throw new Error("No dataset found at index " + s); return { datasetIndex: s, element: a.data[o], index: o } }); !M0(r, n) && (this._active = r, this._lastEvent = null, this._updateHoverStyles(r, n)) } notifyPlugins(e, n, r) { return this._plugins.notify(this, e, n, r) } isPluginEnabled(e) { return 1 === this._plugins._cache.filter(n => n.plugin.id === e).length } _updateHoverStyles(e, n, r) { const i = this.options.hover, s = (l, u) => l.filter(c => !u.some(d => c.datasetIndex === d.datasetIndex && c.index === d.index)), o = s(n, e), a = r ? e : s(e, n); o.length && this.updateHoverStyle(o, i.mode, !1), a.length && i.mode && this.updateHoverStyle(a, i.mode, !0) } _eventHandler(e, n) { const r = { event: e, replay: n, cancelable: !0, inChartArea: this.isPointInArea(e) }, i = o => (o.options.events || this.options.events).includes(e.native.type); if (!1 === this.notifyPlugins("beforeEvent", r, i)) return; const s = this._handleEvent(e, n, r.inChartArea); return r.cancelable = !1, this.notifyPlugins("afterEvent", r, i), (s || r.changed) && this.render(), this } _handleEvent(e, n, r) { const { _active: i = [], options: s } = this, a = this._getActiveElements(e, i, r, n), l = function GF(t) { return "mouseup" === t.type || "click" === t.type || "contextmenu" === t.type }(e), u = function VL(t, e, n, r) { return n && "mouseout" !== t.type ? r ? e : t : null }(e, this._lastEvent, r, l); r && (this._lastEvent = null, z(s.onHover, [e, a, this], this), l && z(s.onClick, [e, a, this], this)); const c = !M0(a, i); return (c || n) && (this._active = a, this._updateHoverStyles(a, i, n)), this._lastEvent = u, c } _getActiveElements(e, n, r, i) { if ("mouseout" === e.type) return []; if (!r) return n; const s = this.options.hover; return this.getElementsAtEventForMode(e, s.mode, s, i) } } function iT() { return re(sr.instances, t => t._plugins.invalidate()) } function lo(t, e, n, r) { return { x: n + t * Math.cos(e), y: r + t * Math.sin(e) } } function K0(t, e, n, r, i, s) { const { x: o, y: a, startAngle: l, pixelMargin: u, innerRadius: c } = e, d = Math.max(e.outerRadius + r + n - u, 0), f = c > 0 ? c + r + n + u : 0; let h = 0; const p = i - l; if (r) { const $e = ((c > 0 ? c - r : 0) + (d > 0 ? d - r : 0)) / 2; h = (p - (0 !== $e ? p * $e / ($e + r) : p)) / 2 } const y = (p - Math.max(.001, p * d - n / Ee) / d) / 2, v = l + y + h, w = i - y - h, { outerStart: T, outerEnd: C, innerStart: D, innerEnd: M } = function UL(t, e, n, r) { const i = function HL(t) { return gp(t, ["outerStart", "outerEnd", "innerStart", "innerEnd"]) }(t.options.borderRadius), s = (n - e) / 2, o = Math.min(s, r * e / 2), a = l => { const u = (n - Math.min(s, l)) * r / 2; return at(l, 0, Math.min(s, u)) }; return { outerStart: a(i.outerStart), outerEnd: a(i.outerEnd), innerStart: at(i.innerStart, 0, o), innerEnd: at(i.innerEnd, 0, o) } }(e, f, d, w - v), S = d - T, A = d - C, F = v + T / S, W = w - C / A, q = f + D, te = f + M, Ue = v + D / q, ft = w - M / te; if (t.beginPath(), s) { const he = (F + W) / 2; if (t.arc(o, a, d, F, he), t.arc(o, a, d, he, W), C > 0) { const bt = lo(A, W, o, a); t.arc(bt.x, bt.y, C, W, w + Le) } const ve = lo(te, w, o, a); if (t.lineTo(ve.x, ve.y), M > 0) { const bt = lo(te, ft, o, a); t.arc(bt.x, bt.y, M, w + Le, ft + Math.PI) } const $e = (w - M / f + (v + D / f)) / 2; if (t.arc(o, a, f, w - M / f, $e, !0), t.arc(o, a, f, $e, v + D / f, !0), D > 0) { const bt = lo(q, Ue, o, a); t.arc(bt.x, bt.y, D, Ue + Math.PI, v - Le) } const Bn = lo(S, v, o, a); if (t.lineTo(Bn.x, Bn.y), T > 0) { const bt = lo(S, F, o, a); t.arc(bt.x, bt.y, T, v - Le, F) } } else { t.moveTo(o, a); const he = Math.cos(F) * d + o, ve = Math.sin(F) * d + a; t.lineTo(he, ve); const $e = Math.cos(W) * d + o, Bn = Math.sin(W) * d + a; t.lineTo($e, Bn) } t.closePath() } I(sr, "defaults", Ze), I(sr, "instances", Q0), I(sr, "overrides", Fi), I(sr, "registry", ir), I(sr, "version", "4.3.0"), I(sr, "getChart", rT); class rl extends Vn { constructor(e) { super(), I(this, "circumference"), I(this, "endAngle"), I(this, "fullCircles"), I(this, "innerRadius"), I(this, "outerRadius"), I(this, "pixelMargin"), I(this, "startAngle"), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, e && Object.assign(this, e) } inRange(e, n, r) { const i = this.getProps(["x", "y"], r), { angle: s, distance: o } = Lv(i, { x: e, y: n }), { startAngle: a, endAngle: l, innerRadius: u, outerRadius: c, circumference: d } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], r), f = (this.options.spacing + this.options.borderWidth) / 2, p = B(d, l - a) >= Ce || Ha(s, a, l), m = Dr(o, u + f, c + f); return p && m } getCenterPoint(e) { const { x: n, y: r, startAngle: i, endAngle: s, innerRadius: o, outerRadius: a } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], e), { offset: l, spacing: u } = this.options, c = (i + s) / 2, d = (o + a + u + l) / 2; return { x: n + Math.cos(c) * d, y: r + Math.sin(c) * d } } tooltipPosition(e) { return this.getCenterPoint(e) } draw(e) { const { options: n, circumference: r } = this, i = (n.offset || 0) / 4, s = (n.spacing || 0) / 2, o = n.circular; if (this.pixelMargin = "inner" === n.borderAlign ? .33 : 0, this.fullCircles = r > Ce ? Math.floor(r / Ce) : 0, 0 === r || this.innerRadius < 0 || this.outerRadius < 0) return; e.save(); const a = (this.startAngle + this.endAngle) / 2; e.translate(Math.cos(a) * i, Math.sin(a) * i); const u = i * (1 - Math.sin(Math.min(Ee, r || 0))); e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, function $L(t, e, n, r, i) { const { fullCircles: s, startAngle: o, circumference: a } = e; let l = e.endAngle; if (s) { K0(t, e, n, r, l, i); for (let u = 0; u < s; ++u)t.fill(); isNaN(a) || (l = o + (a % Ce || Ce)) } K0(t, e, n, r, l, i), t.fill() }(e, this, u, s, o), function zL(t, e, n, r, i) { const { fullCircles: s, startAngle: o, circumference: a, options: l } = e, { borderWidth: u, borderJoinStyle: c, borderDash: d, borderDashOffset: f } = l, h = "inner" === l.borderAlign; if (!u) return; t.setLineDash(d || []), t.lineDashOffset = f, h ? (t.lineWidth = 2 * u, t.lineJoin = c || "round") : (t.lineWidth = u, t.lineJoin = c || "bevel"); let p = e.endAngle; if (s) { K0(t, e, n, r, p, i); for (let m = 0; m < s; ++m)t.stroke(); isNaN(a) || (p = o + (a % Ce || Ce)) } h && function jL(t, e, n) { const { startAngle: r, pixelMargin: i, x: s, y: o, outerRadius: a, innerRadius: l } = e; let u = i / a; t.beginPath(), t.arc(s, o, a, r - u, n + u), l > i ? (u = i / l, t.arc(s, o, l, n + u, r - u, !0)) : t.arc(s, o, i, n + Le, r - Le), t.closePath(), t.clip() }(t, e, p), s || (K0(t, e, n, r, p, i), t.stroke()) }(e, this, u, s, o), e.restore() } } function sT(t, e, n = e) { t.lineCap = B(n.borderCapStyle, e.borderCapStyle), t.setLineDash(B(n.borderDash, e.borderDash)), t.lineDashOffset = B(n.borderDashOffset, e.borderDashOffset), t.lineJoin = B(n.borderJoinStyle, e.borderJoinStyle), t.lineWidth = B(n.borderWidth, e.borderWidth), t.strokeStyle = B(n.borderColor, e.borderColor) } function WL(t, e, n) { t.lineTo(n.x, n.y) } function oT(t, e, n = {}) { const r = t.length, { start: i = 0, end: s = r - 1 } = n, { start: o, end: a } = e, l = Math.max(i, o), u = Math.min(s, a); return { count: r, start: l, loop: e.loop, ilen: u < l && !(i < o && s < o || i > a && s > a) ? r + u - l : u - l } } function GL(t, e, n, r) { const { points: i, options: s } = e, { count: o, start: a, loop: l, ilen: u } = oT(i, n, r), c = function qL(t) { return t.stepped ? mN : t.tension || "monotone" === t.cubicInterpolationMode ? _N : WL }(s); let h, p, m, { move: d = !0, reverse: f } = r || {}; for (h = 0; h <= u; ++h)p = i[(a + (f ? u - h : h)) % o], !p.skip && (d ? (t.moveTo(p.x, p.y), d = !1) : c(t, m, p, f, s.stepped), m = p); return l && (p = i[(a + (f ? u : 0)) % o], c(t, m, p, f, s.stepped)), !!l } function YL(t, e, n, r) { const i = e.points, { count: s, start: o, ilen: a } = oT(i, n, r), { move: l = !0, reverse: u } = r || {}; let f, h, p, m, y, v, c = 0, d = 0; const w = C => (o + (u ? a - C : C)) % s, T = () => { m !== y && (t.lineTo(c, y), t.lineTo(c, m), t.lineTo(c, v)) }; for (l && (h = i[w(0)], t.moveTo(h.x, h.y)), f = 0; f <= a; ++f) { if (h = i[w(f)], h.skip) continue; const C = h.x, D = h.y, M = 0 | C; M === p ? (D < m ? m = D : D > y && (y = D), c = (d * c + C) / ++d) : (T(), t.lineTo(C, D), p = M, d = 0, m = y = D), v = D } T() } function Ip(t) { const e = t.options; return t._decimated || t._loop || e.tension || "monotone" === e.cubicInterpolationMode || e.stepped || e.borderDash && e.borderDash.length ? GL : YL } I(rl, "id", "arc"), I(rl, "defaults", { borderAlign: "center", borderColor: "#fff", borderDash: [], borderDashOffset: 0, borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: !0 }), I(rl, "defaultRoutes", { backgroundColor: "backgroundColor" }), I(rl, "descriptors", { _scriptable: !0, _indexable: e => "borderDash" !== e }); const JL = "function" == typeof Path2D; class ri extends Vn { constructor(e) { super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e) } updateControlPoints(e, n) { const r = this.options; !r.tension && "monotone" !== r.cubicInterpolationMode || r.stepped || this._pointsUpdated || (jN(this._points, r, e, r.spanGaps ? this._loop : this._fullLoop, n), this._pointsUpdated = !0) } set points(e) { this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1 } get points() { return this._points } get segments() { return this._segments || (this._segments = function n4(t, e) { const n = t.points, r = t.options.spanGaps, i = n.length; if (!i) return []; const s = !!t._loop, { start: o, end: a } = function e4(t, e, n, r) { let i = 0, s = e - 1; if (n && !r) for (; i < e && !t[i].skip;)i++; for (; i < e && t[i].skip;)i++; for (i %= e, n && (s += i); s > i && t[s % e].skip;)s--; return s %= e, { start: i, end: s } }(n, i, s, r); return function mb(t, e, n, r) { return r && r.setContext && n ? function r4(t, e, n, r) { const i = t._chart.getContext(), s = _b(t.options), { _datasetIndex: o, options: { spanGaps: a } } = t, l = n.length, u = []; let c = s, d = e[0].start, f = d; function h(p, m, y, v) { const w = a ? -1 : 1; if (p !== m) { for (p += l; n[p % l].skip;)p -= w; for (; n[m % l].skip;)m += w; p % l != m % l && (u.push({ start: p % l, end: m % l, loop: y, style: v }), c = v, d = m % l) } } for (const p of e) { d = a ? d : p.start; let y, m = n[d % l]; for (f = d + 1; f <= p.end; f++) { const v = n[f % l]; y = _b(r.setContext(ni(i, { type: "segment", p0: m, p1: v, p0DataIndex: (f - 1) % l, p1DataIndex: f % l, datasetIndex: o }))), i4(y, c) && h(d, f - 1, p.loop, c), m = v, c = y } d < f - 1 && h(d, f - 1, p.loop, c) } return u }(t, e, n, r) : e }(t, !0 === r ? [{ start: o, end: a, loop: s }] : function t4(t, e, n, r) { const i = t.length, s = []; let l, o = e, a = t[e]; for (l = e + 1; l <= n; ++l) { const u = t[l % i]; u.skip || u.stop ? a.skip || (s.push({ start: e % i, end: (l - 1) % i, loop: r = !1 }), e = o = u.stop ? l : null) : (o = l, a.skip && (e = l)), a = u } return null !== o && s.push({ start: e % i, end: o % i, loop: r }), s }(n, o, a < o ? a + i : a, !!t._fullLoop && 0 === o && a === i - 1), n, e) }(this, this.options.segment)) } first() { const e = this.segments; return e.length && this.points[e[0].start] } last() { const e = this.segments, r = e.length; return r && this.points[e[r - 1].end] } interpolate(e, n) { const r = this.options, i = e[n], s = this.points, o = gb(this, { property: n, start: i, end: i }); if (!o.length) return; const a = [], l = function XL(t) { return t.stepped ? YN : t.tension || "monotone" === t.cubicInterpolationMode ? XN : Bi }(r); let u, c; for (u = 0, c = o.length; u < c; ++u) { const { start: d, end: f } = o[u], h = s[d], p = s[f]; if (h === p) { a.push(h); continue } const y = l(h, p, Math.abs((i - h[n]) / (p[n] - h[n])), r.stepped); y[n] = e[n], a.push(y) } return 1 === a.length ? a[0] : a } pathSegment(e, n, r) { return Ip(this)(e, this, n, r) } path(e, n, r) { const i = this.segments, s = Ip(this); let o = this._loop; n = n || 0, r = r || this.points.length - n; for (const a of i) o &= s(e, this, a, { start: n, end: n + r - 1 }); return !!o } draw(e, n, r, i) { (this.points || []).length && (this.options || {}).borderWidth && (e.save(), function eZ(t, e, n, r) { JL && !e.options.segment ? function QL(t, e, n, r) { let i = e._path; i || (i = e._path = new Path2D, e.path(i, n, r) && i.closePath()), sT(t, e.options), t.stroke(i) }(t, e, n, r) : function KL(t, e, n, r) { const { segments: i, options: s } = e, o = Ip(e); for (const a of i) sT(t, s, a.style), t.beginPath(), o(t, e, a, { start: n, end: n + r - 1 }) && t.closePath(), t.stroke() }(t, e, n, r) }(e, this, r, i), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } } function aT(t, e, n, r) { const i = t.options, { [n]: s } = t.getProps([n], r); return Math.abs(e - s) < i.radius + i.hitRadius } I(ri, "id", "line"), I(ri, "defaults", { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }), I(ri, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }), I(ri, "descriptors", { _scriptable: !0, _indexable: e => "borderDash" !== e && "fill" !== e }); class J0 extends Vn { constructor(e) { super(), I(this, "parsed"), I(this, "skip"), I(this, "stop"), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, e && Object.assign(this, e) } inRange(e, n, r) { const i = this.options, { x: s, y: o } = this.getProps(["x", "y"], r); return Math.pow(e - s, 2) + Math.pow(n - o, 2) < Math.pow(i.hitRadius + i.radius, 2) } inXRange(e, n) { return aT(this, e, "x", n) } inYRange(e, n) { return aT(this, e, "y", n) } getCenterPoint(e) { const { x: n, y: r } = this.getProps(["x", "y"], e); return { x: n, y: r } } size(e) { let n = (e = e || this.options || {}).radius || 0; return n = Math.max(n, n && e.hoverRadius || 0), 2 * (n + (n && e.borderWidth || 0)) } draw(e, n) { const r = this.options; this.skip || r.radius < .1 || !xr(this, n, this.size(r) / 2) || (e.strokeStyle = r.borderColor, e.lineWidth = r.borderWidth, e.fillStyle = r.backgroundColor, pp(e, r, this.x, this.y)) } getRange() { const e = this.options || {}; return e.radius + e.hitRadius } } function lT(t, e) { const { x: n, y: r, base: i, width: s, height: o } = t.getProps(["x", "y", "base", "width", "height"], e); let a, l, u, c, d; return t.horizontal ? (d = o / 2, a = Math.min(n, i), l = Math.max(n, i), u = r - d, c = r + d) : (d = s / 2, a = n - d, l = n + d, u = Math.min(r, i), c = Math.max(r, i)), { left: a, top: u, right: l, bottom: c } } function ii(t, e, n, r) { return t ? 0 : at(e, n, r) } function Ap(t, e, n, r) { const i = null === e, s = null === n, a = t && !(i && s) && lT(t, r); return a && (i || Dr(e, a.left, a.right)) && (s || Dr(n, a.top, a.bottom)) } function sZ(t, e) { t.rect(e.x, e.y, e.w, e.h) } function Pp(t, e, n = {}) { const r = t.x !== n.x ? -e : 0, i = t.y !== n.y ? -e : 0; return { x: t.x + r, y: t.y + i, w: t.w + ((t.x + t.w !== n.x + n.w ? e : 0) - r), h: t.h + ((t.y + t.h !== n.y + n.h ? e : 0) - i), radius: t.radius } } I(J0, "id", "point"), I(J0, "defaults", { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }), I(J0, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); class ec extends Vn { constructor(e) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e) } draw(e) { const { inflateAmount: n, options: { borderColor: r, backgroundColor: i } } = this, { inner: s, outer: o } = function rZ(t) { const e = lT(t), n = e.right - e.left, r = e.bottom - e.top, i = function tZ(t, e, n) { const i = t.borderSkipped, s = Kv(t.options.borderWidth); return { t: ii(i.top, s.top, 0, n), r: ii(i.right, s.right, 0, e), b: ii(i.bottom, s.bottom, 0, n), l: ii(i.left, s.left, 0, e) } }(t, n / 2, r / 2), s = function nZ(t, e, n) { const { enableBorderRadius: r } = t.getProps(["enableBorderRadius"]), i = t.options.borderRadius, s = Zi(i), o = Math.min(e, n), a = t.borderSkipped, l = r || se(i); return { topLeft: ii(!l || a.top || a.left, s.topLeft, 0, o), topRight: ii(!l || a.top || a.right, s.topRight, 0, o), bottomLeft: ii(!l || a.bottom || a.left, s.bottomLeft, 0, o), bottomRight: ii(!l || a.bottom || a.right, s.bottomRight, 0, o) } }(t, n / 2, r / 2); return { outer: { x: e.left, y: e.top, w: n, h: r, radius: s }, inner: { x: e.left + i.l, y: e.top + i.t, w: n - i.l - i.r, h: r - i.t - i.b, radius: { topLeft: Math.max(0, s.topLeft - Math.max(i.t, i.l)), topRight: Math.max(0, s.topRight - Math.max(i.t, i.r)), bottomLeft: Math.max(0, s.bottomLeft - Math.max(i.b, i.l)), bottomRight: Math.max(0, s.bottomRight - Math.max(i.b, i.r)) } } } }(this), a = function iZ(t) { return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight }(o.radius) ? Wa : sZ; e.save(), (o.w !== s.w || o.h !== s.h) && (e.beginPath(), a(e, Pp(o, n, s)), e.clip(), a(e, Pp(s, -n, o)), e.fillStyle = r, e.fill("evenodd")), e.beginPath(), a(e, Pp(s, n)), e.fillStyle = i, e.fill(), e.restore() } inRange(e, n, r) { return Ap(this, e, n, r) } inXRange(e, n) { return Ap(this, e, null, n) } inYRange(e, n) { return Ap(this, null, e, n) } getCenterPoint(e) { const { x: n, y: r, base: i, horizontal: s } = this.getProps(["x", "y", "base", "horizontal"], e); return { x: s ? (n + i) / 2 : n, y: s ? r : (r + i) / 2 } } getRange(e) { return "x" === e ? this.width / 2 : this.height / 2 } } I(ec, "id", "bar"), I(ec, "defaults", { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }), I(ec, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); var oZ = Object.freeze({ __proto__: null, ArcElement: rl, BarElement: ec, LineElement: ri, PointElement: J0 }); const Op = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"], uT = Op.map(t => t.replace("rgb(", "rgba(").replace(")", ", 0.5)")); function cT(t) { return Op[t % Op.length] } function dT(t) { return uT[t % uT.length] } function fT(t) { let e; for (e in t) if (t[e].borderColor || t[e].backgroundColor) return !0; return !1 } var fZ = { id: "colors", defaults: { enabled: !0, forceOverride: !1 }, beforeLayout(t, e, n) { if (!n.enabled) return; const { data: { datasets: r }, options: i } = t.config, { elements: s } = i; if (!n.forceOverride && (fT(r) || function dZ(t) { return t && (t.borderColor || t.backgroundColor) }(i) || s && fT(s))) return; const o = function cZ(t) { let e = 0; return (n, r) => { const i = t.getDatasetMeta(r).controller; i instanceof ji ? e = function lZ(t, e) { return t.backgroundColor = t.data.map(() => cT(e++)), e }(n, e) : i instanceof Ya ? e = function uZ(t, e) { return t.backgroundColor = t.data.map(() => dT(e++)), e }(n, e) : i && (e = function aZ(t, e) { return t.borderColor = cT(e), t.backgroundColor = dT(e), ++e }(n, e)) } }(t); r.forEach(o) } }; function hT(t) { if (t._decimated) { const e = t._data; delete t._decimated, delete t._data, Object.defineProperty(t, "data", { configurable: !0, enumerable: !0, writable: !0, value: e }) } } function pT(t) { t.data.datasets.forEach(e => { hT(e) }) } var mZ = { id: "decimation", defaults: { algorithm: "min-max", enabled: !1 }, beforeElementsUpdate: (t, e, n) => { if (!n.enabled) return void pT(t); const r = t.width; t.data.datasets.forEach((i, s) => { const { _data: o, indexAxis: a } = i, l = t.getDatasetMeta(s), u = o || i.data; if ("y" === qa([a, t.options.indexAxis]) || !l.controller.supportsDecimation) return; const c = t.scales[l.xAxisID]; if ("linear" !== c.type && "time" !== c.type || t.options.parsing) return; let p, { start: d, count: f } = function gZ(t, e) { const n = e.length; let i, r = 0; const { iScale: s } = t, { min: o, max: a, minDefined: l, maxDefined: u } = s.getUserBounds(); return l && (r = at(Cr(e, s.axis, o).lo, 0, n - 1)), i = u ? at(Cr(e, s.axis, a).hi + 1, r, n) - r : n - r, { start: r, count: i } }(l, u); if (f <= (n.threshold || 4 * r)) hT(i); else { switch (de(o) && (i._data = u, delete i.data, Object.defineProperty(i, "data", { configurable: !0, enumerable: !0, get: function () { return this._decimated }, set: function (m) { this._data = m } })), n.algorithm) { case "lttb": p = function hZ(t, e, n, r, i) { const s = i.samples || r; if (s >= n) return t.slice(e, e + n); const o = [], a = (n - 2) / (s - 2); let l = 0; const u = e + n - 1; let d, f, h, p, m, c = e; for (o[l++] = t[c], d = 0; d < s - 2; d++) { let w, y = 0, v = 0; const T = Math.floor((d + 1) * a) + 1 + e, C = Math.min(Math.floor((d + 2) * a) + 1, n) + e, D = C - T; for (w = T; w < C; w++)y += t[w].x, v += t[w].y; y /= D, v /= D; const M = Math.floor(d * a) + 1 + e, S = Math.min(Math.floor((d + 1) * a) + 1, n) + e, { x: A, y: F } = t[c]; for (h = p = -1, w = M; w < S; w++)p = .5 * Math.abs((A - y) * (t[w].y - F) - (A - t[w].x) * (v - F)), p > h && (h = p, f = t[w], m = w); o[l++] = f, c = m } return o[l++] = t[u], o }(u, d, f, r, n); break; case "min-max": p = function pZ(t, e, n, r) { let o, a, l, u, c, d, f, h, p, m, i = 0, s = 0; const y = [], w = t[e].x, C = t[e + n - 1].x - w; for (o = e; o < e + n; ++o) { a = t[o], l = (a.x - w) / C * r, u = a.y; const D = 0 | l; if (D === c) u < p ? (p = u, d = o) : u > m && (m = u, f = o), i = (s * i + a.x) / ++s; else { const M = o - 1; if (!de(d) && !de(f)) { const S = Math.min(d, f), A = Math.max(d, f); S !== h && S !== M && y.push(uc(lc({}, t[S]), { x: i })), A !== h && A !== M && y.push(uc(lc({}, t[A]), { x: i })) } o > 0 && M !== h && y.push(t[M]), y.push(a), c = D, s = 0, p = m = u, d = f = h = o } } return y }(u, d, f, r); break; default: throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`) }i._decimated = p } }) }, destroy(t) { pT(t) } }; function Rp(t, e, n, r) { if (r) return; let i = e[t], s = n[t]; return "angle" === t && (i = Qt(i), s = Qt(s)), { property: t, start: i, end: s } } function Fp(t, e, n) { for (; e > t; e--) { const r = n[e]; if (!isNaN(r.x) && !isNaN(r.y)) break } return e } function gT(t, e, n, r) { return t && e ? r(t[n], e[n]) : t ? t[n] : e ? e[n] : 0 } function mT(t, e) { let n = [], r = !1; return De(t) ? (r = !0, n = t) : n = function yZ(t, e) { const { x: n = null, y: r = null } = t || {}, i = e.points, s = []; return e.segments.forEach(({ start: o, end: a }) => { a = Fp(o, a, i); const l = i[o], u = i[a]; null !== r ? (s.push({ x: l.x, y: r }), s.push({ x: u.x, y: r })) : null !== n && (s.push({ x: n, y: l.y }), s.push({ x: n, y: u.y })) }), s }(t, e), n.length ? new ri({ points: n, options: { tension: 0 }, _loop: r, _fullLoop: r }) : null } function _T(t) { return t && !1 !== t.fill } function wZ(t, e, n) { let i = t[e].fill; const s = [e]; let o; if (!n) return i; for (; !1 !== i && -1 === s.indexOf(i);) { if (!Ne(i)) return i; if (o = t[i], !o) return !1; if (o.visible) return i; s.push(i), i = o.fill } return !1 } function vZ(t, e, n) { const r = function DZ(t) { const e = t.options, n = e.fill; let r = B(n && n.target, n); return void 0 === r && (r = !!e.backgroundColor), !1 !== r && null !== r && (!0 === r ? "origin" : r) }(t); if (se(r)) return !isNaN(r.value) && r; let i = parseFloat(r); return Ne(i) && Math.floor(i) === i ? function bZ(t, e, n, r) { return ("-" === t || "+" === t) && (n = e + n), !(n === e || n < 0 || n >= r) && n }(r[0], e, i, n) : ["origin", "start", "end", "stack", "shape"].indexOf(r) >= 0 && r } function EZ(t, e, n) { const r = []; for (let i = 0; i < n.length; i++) { const s = n[i], { first: o, last: a, point: l } = MZ(s, e, "x"); if (!(!l || o && a)) if (o) r.unshift(l); else if (t.push(l), !a) break } t.push(...r) } function MZ(t, e, n) { const r = t.interpolate(e, n); if (!r) return {}; const i = r[n], s = t.segments, o = t.points; let a = !1, l = !1; for (let u = 0; u < s.length; u++) { const c = s[u], d = o[c.start][n], f = o[c.end][n]; if (Dr(i, d, f)) { a = i === d, l = i === f; break } } return { first: a, last: l, point: r } } class yT { constructor(e) { this.x = e.x, this.y = e.y, this.radius = e.radius } pathSegment(e, n, r) { const { x: i, y: s, radius: o } = this; return e.arc(i, s, o, (n = n || { start: 0, end: Ce }).end, n.start, !0), !r.bounds } interpolate(e) { const { x: n, y: r, radius: i } = this, s = e.angle; return { x: n + Math.cos(s) * i, y: r + Math.sin(s) * i, angle: s } } } function Np(t, e, n) { const r = function SZ(t) { const { chart: e, fill: n, line: r } = t; if (Ne(n)) return function IZ(t, e) { const n = t.getDatasetMeta(e); return n && t.isDatasetVisible(e) ? n.dataset : null }(e, n); if ("stack" === n) return function CZ(t) { const { scale: e, index: n, line: r } = t, i = [], s = r.segments, o = r.points, a = function xZ(t, e) { const n = [], r = t.getMatchingVisibleMetas("line"); for (let i = 0; i < r.length; i++) { const s = r[i]; if (s.index === e) break; s.hidden || n.unshift(s.dataset) } return n }(e, n); a.push(mT({ x: null, y: e.bottom }, r)); for (let l = 0; l < s.length; l++) { const u = s[l]; for (let c = u.start; c <= u.end; c++)EZ(i, o[c], a) } return new ri({ points: i, options: {} }) }(t); if ("shape" === n) return !0; const i = function AZ(t) { return (t.scale || {}).getPointPositionForValue ? function OZ(t) { const { scale: e, fill: n } = t, r = e.options, i = e.getLabels().length, s = r.reverse ? e.max : e.min, o = function kZ(t, e, n) { let r; return r = "start" === t ? n : "end" === t ? e.options.reverse ? e.min : e.max : se(t) ? t.value : e.getBaseValue(), r }(n, e, s), a = []; if (r.grid.circular) { const l = e.getPointPositionForValue(0, s); return new yT({ x: l.x, y: l.y, radius: e.getDistanceFromCenterForValue(o) }) } for (let l = 0; l < i; ++l)a.push(e.getPointPositionForValue(l, o)); return a }(t) : function PZ(t) { const { scale: e = {}, fill: n } = t, r = function TZ(t, e) { let n = null; return "start" === t ? n = e.bottom : "end" === t ? n = e.top : se(t) ? n = e.getPixelForValue(t.value) : e.getBasePixel && (n = e.getBasePixel()), n }(n, e); if (Ne(r)) { const i = e.isHorizontal(); return { x: i ? r : null, y: i ? null : r } } return null }(t) }(t); return i instanceof yT ? i : mT(i, r) }(e), { line: i, scale: s, axis: o } = e, a = i.options, l = a.fill, u = a.backgroundColor, { above: c = u, below: d = u } = l || {}; r && i.points.length && (R0(t, n), function RZ(t, e) { const { line: n, target: r, above: i, below: s, area: o, scale: a } = e, l = n._loop ? "angle" : e.axis; t.save(), "x" === l && s !== i && (wT(t, r, o.top), vT(t, { line: n, target: r, color: i, scale: a, property: l }), t.restore(), t.save(), wT(t, r, o.bottom)), vT(t, { line: n, target: r, color: s, scale: a, property: l }), t.restore() }(t, { line: i, target: r, above: c, below: d, area: n, scale: s, axis: o }), F0(t)) } function wT(t, e, n) { const { segments: r, points: i } = e; let s = !0, o = !1; t.beginPath(); for (const a of r) { const { start: l, end: u } = a, c = i[l], d = i[Fp(l, u, i)]; s ? (t.moveTo(c.x, c.y), s = !1) : (t.lineTo(c.x, n), t.lineTo(c.x, c.y)), o = !!e.pathSegment(t, a, { move: o }), o ? t.closePath() : t.lineTo(d.x, n) } t.lineTo(e.first().x, n), t.closePath(), t.clip() } function vT(t, e) { const { line: n, target: r, property: i, color: s, scale: o } = e, a = function _Z(t, e, n) { const r = t.segments, i = t.points, s = e.points, o = []; for (const a of r) { let { start: l, end: u } = a; u = Fp(l, u, i); const c = Rp(n, i[l], i[u], a.loop); if (!e.segments) { o.push({ source: a, target: c, start: i[l], end: i[u] }); continue } const d = gb(e, c); for (const f of d) { const h = Rp(n, s[f.start], s[f.end], f.loop), p = pb(a, i, h); for (const m of p) o.push({ source: m, target: f, start: { [n]: gT(c, h, "start", Math.max) }, end: { [n]: gT(c, h, "end", Math.min) } }) } } return o }(n, r, i); for (const { source: l, target: u, start: c, end: d } of a) { const { style: { backgroundColor: f = s } = {} } = l, h = !0 !== r; t.save(), t.fillStyle = f, FZ(t, o, h && Rp(i, c, d)), t.beginPath(); const p = !!n.pathSegment(t, l); let m; if (h) { p ? t.closePath() : bT(t, r, d, i); const y = !!r.pathSegment(t, u, { move: p, reverse: !0 }); m = p && y, m || bT(t, r, c, i) } t.closePath(), t.fill(m ? "evenodd" : "nonzero"), t.restore() } } function FZ(t, e, n) { const { top: r, bottom: i } = e.chart.chartArea, { property: s, start: o, end: a } = n || {}; "x" === s && (t.beginPath(), t.rect(o, r, a - o, i - r), t.clip()) } function bT(t, e, n, r) { const i = e.interpolate(n, r); i && t.lineTo(i.x, i.y) } var NZ = { id: "filler", afterDatasetsUpdate(t, e, n) { const r = (t.data.datasets || []).length, i = []; let s, o, a, l; for (o = 0; o < r; ++o)s = t.getDatasetMeta(o), a = s.dataset, l = null, a && a.options && a instanceof ri && (l = { visible: t.isDatasetVisible(o), index: o, fill: vZ(a, o, r), chart: t, axis: s.controller.options.indexAxis, scale: s.vScale, line: a }), s.$filler = l, i.push(l); for (o = 0; o < r; ++o)l = i[o], l && !1 !== l.fill && (l.fill = wZ(i, o, n.propagate)) }, beforeDraw(t, e, n) { const r = "beforeDraw" === n.drawTime, i = t.getSortedVisibleDatasetMetas(), s = t.chartArea; for (let o = i.length - 1; o >= 0; --o) { const a = i[o].$filler; !a || (a.line.updateControlPoints(s, a.axis), r && a.fill && Np(t.ctx, a, s)) } }, beforeDatasetsDraw(t, e, n) { if ("beforeDatasetsDraw" !== n.drawTime) return; const r = t.getSortedVisibleDatasetMetas(); for (let i = r.length - 1; i >= 0; --i) { const s = r[i].$filler; _T(s) && Np(t.ctx, s, t.chartArea) } }, beforeDatasetDraw(t, e, n) { const r = e.meta.$filler; !_T(r) || "beforeDatasetDraw" !== n.drawTime || Np(t.ctx, r, t.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const TT = (t, e) => { let { boxHeight: n = e, boxWidth: r = e } = t; return t.usePointStyle && (n = Math.min(n, e), r = t.pointStyleWidth || Math.min(r, e)), { boxWidth: r, boxHeight: n, itemHeight: Math.max(e, n) } }; class kT extends Vn { constructor(e) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n, r) { this.maxWidth = e, this.maxHeight = n, this._margins = r, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const e = this.options.labels || {}; let n = z(e.generateLabels, [this.chart], this) || []; e.filter && (n = n.filter(r => e.filter(r, this.chart.data))), e.sort && (n = n.sort((r, i) => e.sort(r, i, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n } fit() { const { options: e, ctx: n } = this; if (!e.display) return void (this.width = this.height = 0); const r = e.labels, i = tt(r.font), s = i.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = TT(r, s); let u, c; n.font = i.string, this.isHorizontal() ? (u = this.maxWidth, c = this._fitRows(o, s, a, l) + 10) : (c = this.maxHeight, u = this._fitCols(o, i, a, l) + 10), this.width = Math.min(u, e.maxWidth || this.maxWidth), this.height = Math.min(c, e.maxHeight || this.maxHeight) } _fitRows(e, n, r, i) { const { ctx: s, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], u = this.lineWidths = [0], c = i + a; let d = e; s.textAlign = "left", s.textBaseline = "middle"; let f = -1, h = -c; return this.legendItems.forEach((p, m) => { const y = r + n / 2 + s.measureText(p.text).width; (0 === m || u[u.length - 1] + y + 2 * a > o) && (d += c, u[u.length - (m > 0 ? 0 : 1)] = 0, h += c, f++), l[m] = { left: 0, top: h, row: f, width: y, height: i }, u[u.length - 1] += y + a }), d } _fitCols(e, n, r, i) { const { ctx: s, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], u = this.columnSizes = [], c = o - e; let d = a, f = 0, h = 0, p = 0, m = 0; return this.legendItems.forEach((y, v) => { const { itemWidth: w, itemHeight: T } = function ZZ(t, e, n, r, i) { const s = function VZ(t, e, n, r) { let i = t.text; return i && "string" != typeof i && (i = i.reduce((s, o) => s.length > o.length ? s : o)), e + n.size / 2 + r.measureText(i).width }(r, t, e, n), o = function BZ(t, e, n) { let r = t; return "string" != typeof e.text && (r = DT(e, n)), r }(i, r, e.lineHeight); return { itemWidth: s, itemHeight: o } }(r, n, s, y, i); v > 0 && h + T + 2 * a > c && (d += f + a, u.push({ width: f, height: h }), p += f + a, m++, f = h = 0), l[v] = { left: p, top: h, col: m, width: w, height: T }, f = Math.max(f, w), h += T + a }), d += f, u.push({ width: f, height: h }), d } adjustHitBoxes() { if (!this.options.display) return; const e = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: r, labels: { padding: i }, rtl: s } } = this, o = ao(s, this.left, this.width); if (this.isHorizontal()) { let a = 0, l = yt(r, this.left + i, this.right - this.lineWidths[a]); for (const u of n) a !== u.row && (a = u.row, l = yt(r, this.left + i, this.right - this.lineWidths[a])), u.top += this.top + e + i, u.left = o.leftForLtr(o.x(l), u.width), l += u.width + i } else { let a = 0, l = yt(r, this.top + e + i, this.bottom - this.columnSizes[a].height); for (const u of n) u.col !== a && (a = u.col, l = yt(r, this.top + e + i, this.bottom - this.columnSizes[a].height)), u.top = l, u.left += this.left + i, u.left = o.leftForLtr(o.x(u.left), u.width), l += u.height + i } } isHorizontal() { return "top" === this.options.position || "bottom" === this.options.position } draw() { if (this.options.display) { const e = this.ctx; R0(e, this), this._draw(), F0(e) } } _draw() { const { options: e, columnSizes: n, lineWidths: r, ctx: i } = this, { align: s, labels: o } = e, a = Ze.color, l = ao(e.rtl, this.left, this.width), u = tt(o.font), { padding: c } = o, d = u.size, f = d / 2; let h; this.drawTitle(), i.textAlign = l.textAlign("left"), i.textBaseline = "middle", i.lineWidth = .5, i.font = u.string; const { boxWidth: p, boxHeight: m, itemHeight: y } = TT(o, d), T = this.isHorizontal(), C = this._computeTitleHeight(); h = T ? { x: yt(s, this.left + c, this.right - r[0]), y: this.top + c + C, line: 0 } : { x: this.left + c, y: yt(s, this.top + C + c, this.bottom - n[0].height), line: 0 }, cb(this.ctx, e.textDirection); const D = y + c; this.legendItems.forEach((M, S) => { i.strokeStyle = M.fontColor, i.fillStyle = M.fontColor; const A = i.measureText(M.text).width, F = l.textAlign(M.textAlign || (M.textAlign = o.textAlign)), W = p + f + A; let q = h.x, te = h.y; l.setWidth(this.width), T ? S > 0 && q + W + c > this.right && (te = h.y += D, h.line++, q = h.x = yt(s, this.left + c, this.right - r[h.line])) : S > 0 && te + D > this.bottom && (q = h.x = q + n[h.line].width + c, h.line++, te = h.y = yt(s, this.top + C + c, this.bottom - n[h.line].height)), function (M, S, A) { if (isNaN(p) || p <= 0 || isNaN(m) || m < 0) return; i.save(); const F = B(A.lineWidth, 1); if (i.fillStyle = B(A.fillStyle, a), i.lineCap = B(A.lineCap, "butt"), i.lineDashOffset = B(A.lineDashOffset, 0), i.lineJoin = B(A.lineJoin, "miter"), i.lineWidth = F, i.strokeStyle = B(A.strokeStyle, a), i.setLineDash(B(A.lineDash, [])), o.usePointStyle) { const W = { radius: m * Math.SQRT2 / 2, pointStyle: A.pointStyle, rotation: A.rotation, borderWidth: F }, q = l.xPlus(M, p / 2); Qv(i, W, q, S + f, o.pointStyleWidth && p) } else { const W = S + Math.max((d - m) / 2, 0), q = l.leftForLtr(M, p), te = Zi(A.borderRadius); i.beginPath(), Object.values(te).some(Ue => 0 !== Ue) ? Wa(i, { x: q, y: W, w: p, h: m, radius: te }) : i.rect(q, W, p, m), i.fill(), 0 !== F && i.stroke() } i.restore() }(l.x(q), te, M), q = ((t, e, n, r) => t === (r ? "left" : "right") ? n : "center" === t ? (e + n) / 2 : e)(F, q + p + f, T ? q + W : this.right, e.rtl), function (M, S, A) { Li(i, A.text, M, S + y / 2, u, { strikethrough: A.hidden, textAlign: l.textAlign(A.textAlign) }) }(l.x(q), te, M), T ? h.x += W + c : h.y += "string" != typeof M.text ? DT(M, u.lineHeight) : D }), db(this.ctx, e.textDirection) } drawTitle() { const e = this.options, n = e.title, r = tt(n.font), i = wt(n.padding); if (!n.display) return; const s = ao(e.rtl, this.left, this.width), o = this.ctx, a = n.position, u = i.top + r.size / 2; let c, d = this.left, f = this.width; if (this.isHorizontal()) f = Math.max(...this.lineWidths), c = this.top + u, d = yt(e.align, d, this.right - f); else { const p = this.columnSizes.reduce((m, y) => Math.max(m, y.height), 0); c = u + yt(e.align, this.top, this.bottom - p - e.labels.padding - this._computeTitleHeight()) } const h = yt(a, d, d + f); o.textAlign = s.textAlign(up(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = r.string, Li(o, n.text, h, c, r) } _computeTitleHeight() { const e = this.options.title, n = tt(e.font), r = wt(e.padding); return e.display ? n.lineHeight + r.height : 0 } _getLegendItemAt(e, n) { let r, i, s; if (Dr(e, this.left, this.right) && Dr(n, this.top, this.bottom)) for (s = this.legendHitBoxes, r = 0; r < s.length; ++r)if (i = s[r], Dr(e, i.left, i.left + i.width) && Dr(n, i.top, i.top + i.height)) return this.legendItems[r]; return null } handleEvent(e) { const n = this.options; if (!function jZ(t, e) { return !(("mousemove" !== t && "mouseout" !== t || !e.onHover && !e.onLeave) && (!e.onClick || "click" !== t && "mouseup" !== t)) }(e.type, n)) return; const r = this._getLegendItemAt(e.x, e.y); if ("mousemove" === e.type || "mouseout" === e.type) { const i = this._hoveredItem, s = ((t, e) => null !== t && null !== e && t.datasetIndex === e.datasetIndex && t.index === e.index)(i, r); i && !s && z(n.onLeave, [e, i, this], this), this._hoveredItem = r, r && !s && z(n.onHover, [e, r, this], this) } else r && z(n.onClick, [e, r, this], this) } } function DT(t, e) { return e * (t.text ? t.text.length + .5 : 0) } var HZ = { id: "legend", _element: kT, start(t, e, n) { const r = t.legend = new kT({ ctx: t.ctx, options: n, chart: t }); vt.configure(t, r, n), vt.addBox(t, r) }, stop(t) { vt.removeBox(t, t.legend), delete t.legend }, beforeUpdate(t, e, n) { const r = t.legend; vt.configure(t, r, n), r.options = n }, afterUpdate(t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent(t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(t, e, n) { const r = e.datasetIndex, i = n.chart; i.isDatasetVisible(r) ? (i.hide(r), e.hidden = !0) : (i.show(r), e.hidden = !1) }, onHover: null, onLeave: null, labels: { color: t => t.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t) { const e = t.data.datasets, { labels: { usePointStyle: n, pointStyle: r, textAlign: i, color: s, useBorderRadius: o, borderRadius: a } } = t.legend.options; return t._getSortedDatasetMetas().map(l => { const u = l.controller.getStyle(n ? 0 : void 0), c = wt(u.borderWidth); return { text: e[l.index].label, fillStyle: u.backgroundColor, fontColor: s, hidden: !l.visible, lineCap: u.borderCapStyle, lineDash: u.borderDash, lineDashOffset: u.borderDashOffset, lineJoin: u.borderJoinStyle, lineWidth: (c.width + c.height) / 4, strokeStyle: u.borderColor, pointStyle: r || u.pointStyle, rotation: u.rotation, textAlign: i || u.textAlign, borderRadius: o && (a || u.borderRadius), datasetIndex: l.index } }, this) } }, title: { color: t => t.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: t => !t.startsWith("on"), labels: { _scriptable: t => !["generateLabels", "filter", "sort"].includes(t) } } }; class Lp extends Vn { constructor(e) { super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n) { const r = this.options; if (this.left = 0, this.top = 0, !r.display) return void (this.width = this.height = this.right = this.bottom = 0); this.width = this.right = e, this.height = this.bottom = n; const i = De(r.text) ? r.text.length : 1; this._padding = wt(r.padding); const s = i * tt(r.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = s : this.width = s } isHorizontal() { const e = this.options.position; return "top" === e || "bottom" === e } _drawArgs(e) { const { top: n, left: r, bottom: i, right: s, options: o } = this, a = o.align; let u, c, d, l = 0; return this.isHorizontal() ? (c = yt(a, r, s), d = n + e, u = s - r) : ("left" === o.position ? (c = r + e, d = yt(a, i, n), l = -.5 * Ee) : (c = s - e, d = yt(a, n, i), l = .5 * Ee), u = i - n), { titleX: c, titleY: d, maxWidth: u, rotation: l } } draw() { const e = this.ctx, n = this.options; if (!n.display) return; const r = tt(n.font), s = r.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: u } = this._drawArgs(s); Li(e, n.text, 0, 0, r, { color: n.color, maxWidth: l, rotation: u, textAlign: up(n.align), textBaseline: "middle", translation: [o, a] }) } } var $Z = { id: "title", _element: Lp, start(t, e, n) { !function UZ(t, e) { const n = new Lp({ ctx: t.ctx, options: e, chart: t }); vt.configure(t, n, e), vt.addBox(t, n), t.titleBlock = n }(t, n) }, stop(t) { vt.removeBox(t, t.titleBlock), delete t.titleBlock }, beforeUpdate(t, e, n) { const r = t.titleBlock; vt.configure(t, r, n), r.options = n }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const tc = new WeakMap; var zZ = { id: "subtitle", start(t, e, n) { const r = new Lp({ ctx: t.ctx, options: n, chart: t }); vt.configure(t, r, n), vt.addBox(t, r), tc.set(t, r) }, stop(t) { vt.removeBox(t, tc.get(t)), tc.delete(t) }, beforeUpdate(t, e, n) { const r = tc.get(t); vt.configure(t, r, n), r.options = n }, defaults: { align: "center", display: !1, font: { weight: "normal" }, fullSize: !0, padding: 0, position: "top", text: "", weight: 1500 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const il = { average(t) { if (!t.length) return !1; let e, n, r = 0, i = 0, s = 0; for (e = 0, n = t.length; e < n; ++e) { const o = t[e].element; if (o && o.hasValue()) { const a = o.tooltipPosition(); r += a.x, i += a.y, ++s } } return { x: r / s, y: i / s } }, nearest(t, e) { if (!t.length) return !1; let s, o, a, n = e.x, r = e.y, i = Number.POSITIVE_INFINITY; for (s = 0, o = t.length; s < o; ++s) { const l = t[s].element; if (l && l.hasValue()) { const c = ap(e, l.getCenterPoint()); c < i && (i = c, a = l) } } if (a) { const l = a.tooltipPosition(); n = l.x, r = l.y } return { x: n, y: r } } }; function or(t, e) { return e && (De(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function Mr(t) { return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t } function WZ(t, e) { const { element: n, datasetIndex: r, index: i } = e, s = t.getDatasetMeta(r).controller, { label: o, value: a } = s.getLabelAndValue(i); return { chart: t, label: o, parsed: s.getParsed(i), raw: t.data.datasets[r].data[i], formattedValue: a, dataset: s.getDataset(), dataIndex: i, datasetIndex: r, element: n } } function CT(t, e) { const n = t.chart.ctx, { body: r, footer: i, title: s } = t, { boxWidth: o, boxHeight: a } = e, l = tt(e.bodyFont), u = tt(e.titleFont), c = tt(e.footerFont), d = s.length, f = i.length, h = r.length, p = wt(e.padding); let m = p.height, y = 0, v = r.reduce((C, D) => C + D.before.length + D.lines.length + D.after.length, 0); v += t.beforeBody.length + t.afterBody.length, d && (m += d * u.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), v && (m += h * (e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight) + (v - h) * l.lineHeight + (v - 1) * e.bodySpacing), f && (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing); let w = 0; const T = function (C) { y = Math.max(y, n.measureText(C).width + w) }; return n.save(), n.font = u.string, re(t.title, T), n.font = l.string, re(t.beforeBody.concat(t.afterBody), T), w = e.displayColors ? o + 2 + e.boxPadding : 0, re(r, C => { re(C.before, T), re(C.lines, T), re(C.after, T) }), w = 0, n.font = c.string, re(t.footer, T), n.restore(), y += p.width, { width: y, height: m } } function YZ(t, e, n, r) { const { x: i, width: s } = n, { width: o, chartArea: { left: a, right: l } } = t; let u = "center"; return "center" === r ? u = i <= (a + l) / 2 ? "left" : "right" : i <= s / 2 ? u = "left" : i >= o - s / 2 && (u = "right"), function GZ(t, e, n, r) { const { x: i, width: s } = r, o = n.caretSize + n.caretPadding; if ("left" === t && i + s + o > e.width || "right" === t && i - s - o < 0) return !0 }(u, t, e, n) && (u = "center"), u } function xT(t, e, n) { const r = n.yAlign || e.yAlign || function qZ(t, e) { const { y: n, height: r } = e; return n < r / 2 ? "top" : n > t.height - r / 2 ? "bottom" : "center" }(t, n); return { xAlign: n.xAlign || e.xAlign || YZ(t, e, n, r), yAlign: r } } function ET(t, e, n, r) { const { caretSize: i, caretPadding: s, cornerRadius: o } = t, { xAlign: a, yAlign: l } = n, u = i + s, { topLeft: c, topRight: d, bottomLeft: f, bottomRight: h } = Zi(o); let p = function XZ(t, e) { let { x: n, width: r } = t; return "right" === e ? n -= r : "center" === e && (n -= r / 2), n }(e, a); const m = function QZ(t, e, n) { let { y: r, height: i } = t; return "top" === e ? r += n : r -= "bottom" === e ? i + n : i / 2, r }(e, l, u); return "center" === l ? "left" === a ? p += u : "right" === a && (p -= u) : "left" === a ? p -= Math.max(c, f) + i : "right" === a && (p += Math.max(d, h) + i), { x: at(p, 0, r.width - e.width), y: at(m, 0, r.height - e.height) } } function nc(t, e, n) { const r = wt(n.padding); return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - r.right : t.x + r.left } function MT(t) { return or([], Mr(t)) } function ST(t, e) { const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks; return n ? t.override(n) : t } const IT = { beforeTitle: kr, title(t) { if (t.length > 0) { const e = t[0], n = e.chart.data.labels, r = n ? n.length : 0; if (this && this.options && "dataset" === this.options.mode) return e.dataset.label || ""; if (e.label) return e.label; if (r > 0 && e.dataIndex < r) return n[e.dataIndex] } return "" }, afterTitle: kr, beforeBody: kr, beforeLabel: kr, label(t) { if (this && this.options && "dataset" === this.options.mode) return t.label + ": " + t.formattedValue || t.formattedValue; let e = t.dataset.label || ""; e && (e += ": "); const n = t.formattedValue; return de(n) || (e += n), e }, labelColor(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { borderColor: n.borderColor, backgroundColor: n.backgroundColor, borderWidth: n.borderWidth, borderDash: n.borderDash, borderDashOffset: n.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { pointStyle: n.pointStyle, rotation: n.rotation } }, afterLabel: kr, afterBody: kr, beforeFooter: kr, footer: kr, afterFooter: kr }; function Nt(t, e, n, r) { const i = t[e].call(n, r); return void 0 === i ? IT[e].call(n, r) : i } class Zp extends Vn { constructor(e) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(e) { this.options = e, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const e = this._cachedAnimations; if (e) return e; const n = this.chart, r = this.options.setContext(this.getContext()), i = r.enabled && n.options.animation && r.animations, s = new wb(this.chart, i); return i._cacheable && (this._cachedAnimations = Object.freeze(s)), s } getContext() { return this.$context || (this.$context = function KZ(t, e, n) { return ni(t, { tooltip: e, tooltipItems: n, type: "tooltip" }) }(this.chart.getContext(), this, this._tooltipItems)) } getTitle(e, n) { const { callbacks: r } = n, i = Nt(r, "beforeTitle", this, e), s = Nt(r, "title", this, e), o = Nt(r, "afterTitle", this, e); let a = []; return a = or(a, Mr(i)), a = or(a, Mr(s)), a = or(a, Mr(o)), a } getBeforeBody(e, n) { return MT(Nt(n.callbacks, "beforeBody", this, e)) } getBody(e, n) { const { callbacks: r } = n, i = []; return re(e, s => { const o = { before: [], lines: [], after: [] }, a = ST(r, s); or(o.before, Mr(Nt(a, "beforeLabel", this, s))), or(o.lines, Nt(a, "label", this, s)), or(o.after, Mr(Nt(a, "afterLabel", this, s))), i.push(o) }), i } getAfterBody(e, n) { return MT(Nt(n.callbacks, "afterBody", this, e)) } getFooter(e, n) { const { callbacks: r } = n, i = Nt(r, "beforeFooter", this, e), s = Nt(r, "footer", this, e), o = Nt(r, "afterFooter", this, e); let a = []; return a = or(a, Mr(i)), a = or(a, Mr(s)), a = or(a, Mr(o)), a } _createItems(e) { const n = this._active, r = this.chart.data, i = [], s = [], o = []; let l, u, a = []; for (l = 0, u = n.length; l < u; ++l)a.push(WZ(this.chart, n[l])); return e.filter && (a = a.filter((c, d, f) => e.filter(c, d, f, r))), e.itemSort && (a = a.sort((c, d) => e.itemSort(c, d, r))), re(a, c => { const d = ST(e.callbacks, c); i.push(Nt(d, "labelColor", this, c)), s.push(Nt(d, "labelPointStyle", this, c)), o.push(Nt(d, "labelTextColor", this, c)) }), this.labelColors = i, this.labelPointStyles = s, this.labelTextColors = o, this.dataPoints = a, a } update(e, n) { const r = this.options.setContext(this.getContext()), i = this._active; let s, o = []; if (i.length) { const a = il[r.position].call(this, i, this._eventPosition); o = this._createItems(r), this.title = this.getTitle(o, r), this.beforeBody = this.getBeforeBody(o, r), this.body = this.getBody(o, r), this.afterBody = this.getAfterBody(o, r), this.footer = this.getFooter(o, r); const l = this._size = CT(this, r), u = Object.assign({}, a, l), c = xT(this.chart, r, u), d = ET(r, u, c, this.chart); this.xAlign = c.xAlign, this.yAlign = c.yAlign, s = { opacity: 1, x: d.x, y: d.y, width: l.width, height: l.height, caretX: a.x, caretY: a.y } } else 0 !== this.opacity && (s = { opacity: 0 }); this._tooltipItems = o, this.$context = void 0, s && this._resolveAnimations().update(this, s), e && r.external && r.external.call(this, { chart: this.chart, tooltip: this, replay: n }) } drawCaret(e, n, r, i) { const s = this.getCaretPosition(e, r, i); n.lineTo(s.x1, s.y1), n.lineTo(s.x2, s.y2), n.lineTo(s.x3, s.y3) } getCaretPosition(e, n, r) { const { xAlign: i, yAlign: s } = this, { caretSize: o, cornerRadius: a } = r, { topLeft: l, topRight: u, bottomLeft: c, bottomRight: d } = Zi(a), { x: f, y: h } = e, { width: p, height: m } = n; let y, v, w, T, C, D; return "center" === s ? (C = h + m / 2, "left" === i ? (y = f, v = y - o, T = C + o, D = C - o) : (y = f + p, v = y + o, T = C - o, D = C + o), w = y) : (v = "left" === i ? f + Math.max(l, c) + o : "right" === i ? f + p - Math.max(u, d) - o : this.caretX, "top" === s ? (T = h, C = T - o, y = v - o, w = v + o) : (T = h + m, C = T + o, y = v + o, w = v - o), D = T), { x1: y, x2: v, x3: w, y1: T, y2: C, y3: D } } drawTitle(e, n, r) { const i = this.title, s = i.length; let o, a, l; if (s) { const u = ao(r.rtl, this.x, this.width); for (e.x = nc(this, r.titleAlign, r), n.textAlign = u.textAlign(r.titleAlign), n.textBaseline = "middle", o = tt(r.titleFont), a = r.titleSpacing, n.fillStyle = r.titleColor, n.font = o.string, l = 0; l < s; ++l)n.fillText(i[l], u.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, l + 1 === s && (e.y += r.titleMarginBottom - a) } } _drawColorBox(e, n, r, i, s) { const o = this.labelColors[r], a = this.labelPointStyles[r], { boxHeight: l, boxWidth: u } = s, c = tt(s.bodyFont), d = nc(this, "left", s), f = i.x(d), p = n.y + (l < c.lineHeight ? (c.lineHeight - l) / 2 : 0); if (s.usePointStyle) { const m = { radius: Math.min(u, l) / 2, pointStyle: a.pointStyle, rotation: a.rotation, borderWidth: 1 }, y = i.leftForLtr(f, u) + u / 2, v = p + l / 2; e.strokeStyle = s.multiKeyBackground, e.fillStyle = s.multiKeyBackground, pp(e, m, y, v), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, pp(e, m, y, v) } else { e.lineWidth = se(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0; const m = i.leftForLtr(f, u), y = i.leftForLtr(i.xPlus(f, 1), u - 2), v = Zi(o.borderRadius); Object.values(v).some(w => 0 !== w) ? (e.beginPath(), e.fillStyle = s.multiKeyBackground, Wa(e, { x: m, y: p, w: u, h: l, radius: v }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), Wa(e, { x: y, y: p + 1, w: u - 2, h: l - 2, radius: v }), e.fill()) : (e.fillStyle = s.multiKeyBackground, e.fillRect(m, p, u, l), e.strokeRect(m, p, u, l), e.fillStyle = o.backgroundColor, e.fillRect(y, p + 1, u - 2, l - 2)) } e.fillStyle = this.labelTextColors[r] } drawBody(e, n, r) { const { body: i } = this, { bodySpacing: s, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: u, boxPadding: c } = r, d = tt(r.bodyFont); let f = d.lineHeight, h = 0; const p = ao(r.rtl, this.x, this.width), m = function (A) { n.fillText(A, p.x(e.x + h), e.y + f / 2), e.y += f + s }, y = p.textAlign(o); let v, w, T, C, D, M, S; for (n.textAlign = o, n.textBaseline = "middle", n.font = d.string, e.x = nc(this, y, r), n.fillStyle = r.bodyColor, re(this.beforeBody, m), h = a && "right" !== y ? "center" === o ? u / 2 + c : u + 2 + c : 0, C = 0, M = i.length; C < M; ++C) { for (v = i[C], w = this.labelTextColors[C], n.fillStyle = w, re(v.before, m), T = v.lines, a && T.length && (this._drawColorBox(n, e, C, p, r), f = Math.max(d.lineHeight, l)), D = 0, S = T.length; D < S; ++D)m(T[D]), f = d.lineHeight; re(v.after, m) } h = 0, f = d.lineHeight, re(this.afterBody, m), e.y -= s } drawFooter(e, n, r) { const i = this.footer, s = i.length; let o, a; if (s) { const l = ao(r.rtl, this.x, this.width); for (e.x = nc(this, r.footerAlign, r), e.y += r.footerMarginTop, n.textAlign = l.textAlign(r.footerAlign), n.textBaseline = "middle", o = tt(r.footerFont), n.fillStyle = r.footerColor, n.font = o.string, a = 0; a < s; ++a)n.fillText(i[a], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + r.footerSpacing } } drawBackground(e, n, r, i) { const { xAlign: s, yAlign: o } = this, { x: a, y: l } = e, { width: u, height: c } = r, { topLeft: d, topRight: f, bottomLeft: h, bottomRight: p } = Zi(i.cornerRadius); n.fillStyle = i.backgroundColor, n.strokeStyle = i.borderColor, n.lineWidth = i.borderWidth, n.beginPath(), n.moveTo(a + d, l), "top" === o && this.drawCaret(e, n, r, i), n.lineTo(a + u - f, l), n.quadraticCurveTo(a + u, l, a + u, l + f), "center" === o && "right" === s && this.drawCaret(e, n, r, i), n.lineTo(a + u, l + c - p), n.quadraticCurveTo(a + u, l + c, a + u - p, l + c), "bottom" === o && this.drawCaret(e, n, r, i), n.lineTo(a + h, l + c), n.quadraticCurveTo(a, l + c, a, l + c - h), "center" === o && "left" === s && this.drawCaret(e, n, r, i), n.lineTo(a, l + d), n.quadraticCurveTo(a, l, a + d, l), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke() } _updateAnimationTarget(e) { const n = this.chart, r = this.$animations, i = r && r.x, s = r && r.y; if (i || s) { const o = il[e.position].call(this, this._active, this._eventPosition); if (!o) return; const a = this._size = CT(this, e), l = Object.assign({}, o, this._size), u = xT(n, e, l), c = ET(e, l, u, n); (i._to !== c.x || s._to !== c.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, c)) } } _willRender() { return !!this.opacity } draw(e) { const n = this.options.setContext(this.getContext()); let r = this.opacity; if (!r) return; this._updateAnimationTarget(n); const i = { width: this.width, height: this.height }, s = { x: this.x, y: this.y }; r = Math.abs(r) < .001 ? 0 : r; const o = wt(n.padding); n.enabled && (this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length) && (e.save(), e.globalAlpha = r, this.drawBackground(s, e, i, n), cb(e, n.textDirection), s.y += o.top, this.drawTitle(s, e, n), this.drawBody(s, e, n), this.drawFooter(s, e, n), db(e, n.textDirection), e.restore()) } getActiveElements() { return this._active || [] } setActiveElements(e, n) { const r = this._active, i = e.map(({ datasetIndex: a, index: l }) => { const u = this.chart.getDatasetMeta(a); if (!u) throw new Error("Cannot find a dataset at index " + a); return { datasetIndex: a, element: u.data[l], index: l } }), s = !M0(r, i), o = this._positionChanged(i, n); (s || o) && (this._active = i, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(e, n, r = !0) { if (n && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const i = this.options, s = this._active || [], o = this._getActiveElements(e, s, n, r), a = this._positionChanged(o, e), l = n || !M0(o, s) || a; return l && (this._active = o, (i.enabled || i.external) && (this._eventPosition = { x: e.x, y: e.y }, this.update(!0, n))), l } _getActiveElements(e, n, r, i) { const s = this.options; if ("mouseout" === e.type) return []; if (!i) return n; const o = this.chart.getElementsAtEventForMode(e, s.mode, s, r); return s.reverse && o.reverse(), o } _positionChanged(e, n) { const { caretX: r, caretY: i, options: s } = this, o = il[s.position].call(this, e, n); return !1 !== o && (r !== o.x || i !== o.y) } } I(Zp, "positioners", il); var e9 = Object.freeze({ __proto__: null, Colors: fZ, Decimation: mZ, Filler: NZ, Legend: HZ, SubTitle: zZ, Title: $Z, Tooltip: { id: "tooltip", _element: Zp, positioners: il, afterInit(t, e, n) { n && (t.tooltip = new Zp({ chart: t, options: n })) }, beforeUpdate(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, reset(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, afterDraw(t) { const e = t.tooltip; if (e && e._willRender()) { const n = { tooltip: e }; if (!1 === t.notifyPlugins("beforeTooltipDraw", uc(lc({}, n), { cancelable: !0 }))) return; e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", n) } }, afterEvent(t, e) { t.tooltip && t.tooltip.handleEvent(e.event, e.replay, e.inChartArea) && (e.changed = !0) }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t, e) => e.bodyFont.size, boxWidth: (t, e) => e.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: IT }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: t => "filter" !== t && "itemSort" !== t && "external" !== t, _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] } }); function AT(t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t } class Vp extends Ui { constructor(e) { super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(e) { const n = this._addedLabels; if (n.length) { const r = this.getLabels(); for (const { index: i, label: s } of n) r[i] === s && r.splice(i, 1); this._addedLabels = [] } super.init(e) } parse(e, n) { if (de(e)) return null; const r = this.getLabels(); return ((t, e) => null === t ? null : at(Math.round(t), 0, e))(n = isFinite(n) && r[n] === e ? n : function n9(t, e, n, r) { const i = t.indexOf(e); return -1 === i ? ((t, e, n, r) => ("string" == typeof e ? (n = t.push(e) - 1, r.unshift({ index: n, label: e })) : isNaN(e) && (n = null), n))(t, e, n, r) : i !== t.lastIndexOf(e) ? n : i }(r, e, B(n, e), this._addedLabels), r.length - 1) } determineDataLimits() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let { min: r, max: i } = this.getMinMax(!0); "ticks" === this.options.bounds && (e || (r = 0), n || (i = this.getLabels().length - 1)), this.min = r, this.max = i } buildTicks() { const e = this.min, n = this.max, r = this.options.offset, i = []; let s = this.getLabels(); s = 0 === e && n === s.length - 1 ? s : s.slice(e, n + 1), this._valueRange = Math.max(s.length - (r ? 0 : 1), 1), this._startValue = this.min - (r ? .5 : 0); for (let o = e; o <= n; o++)i.push({ value: o }); return i } getLabelForValue(e) { return AT.call(this, e) } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(e) { return "number" != typeof e && (e = this.parse(e)), null === e ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getValueForPixel(e) { return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange) } getBasePixel() { return this.bottom } } function PT(t, e, { horizontal: n, minRotation: r }) { const i = Ln(r), s = (n ? Math.sin(i) : Math.cos(i)) || .001; return Math.min(e / s, .75 * e * ("" + t).length) } I(Vp, "id", "category"), I(Vp, "defaults", { ticks: { callback: AT } }); class rc extends Ui { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(e, n) { return de(e) || ("number" == typeof e || e instanceof Number) && !isFinite(+e) ? null : +e } handleTickRangeOptions() { const { beginAtZero: e } = this.options, { minDefined: n, maxDefined: r } = this.getUserBounds(); let { min: i, max: s } = this; const o = l => i = n ? i : l, a = l => s = r ? s : l; if (e) { const l = hn(i), u = hn(s); l < 0 && u < 0 ? a(0) : l > 0 && u > 0 && o(0) } if (i === s) { let l = 0 === s ? 1 : Math.abs(.05 * s); a(s + l), e || o(i - l) } this.min = i, this.max = s } getTickLimit() { const e = this.options.ticks; let i, { maxTicksLimit: n, stepSize: r } = e; return r ? (i = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), n = n || 11), n && (i = Math.min(n, i)), i } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const e = this.options, n = e.ticks; let r = this.getTickLimit(); r = Math.max(2, r); const o = function i9(t, e) { const n = [], { bounds: i, step: s, min: o, max: a, precision: l, count: u, maxTicks: c, maxDigits: d, includeBounds: f } = t, h = s || 1, p = c - 1, { min: m, max: y } = e, v = !de(o), w = !de(a), T = !de(u), C = (y - m) / (d + 1); let M, S, A, F, D = Rv((y - m) / p / h) * h; if (D < 1e-14 && !v && !w) return [{ value: m }, { value: y }]; F = Math.ceil(y / D) - Math.floor(m / D), F > p && (D = Rv(F * D / p / h) * h), de(l) || (M = Math.pow(10, l), D = Math.ceil(D * M) / M), "ticks" === i ? (S = Math.floor(m / D) * D, A = Math.ceil(y / D) * D) : (S = m, A = y), v && w && s && function KF(t, e) { const n = Math.round(t); return n - e <= t && n + e >= t }((a - o) / s, D / 1e3) ? (F = Math.round(Math.min((a - o) / D, c)), D = (a - o) / F, S = o, A = a) : T ? (S = v ? o : S, A = w ? a : A, F = u - 1, D = (A - S) / F) : (F = (A - S) / D, F = ja(F, Math.round(F), D / 1e3) ? Math.round(F) : Math.ceil(F)); const W = Math.max(Nv(D), Nv(S)); M = Math.pow(10, de(l) ? W : l), S = Math.round(S * M) / M, A = Math.round(A * M) / M; let q = 0; for (v && (f && S !== o ? (n.push({ value: o }), S < o && q++, ja(Math.round((S + q * D) * M) / M, o, PT(o, C, t)) && q++) : S < o && q++); q < F; ++q) { const te = Math.round((S + q * D) * M) / M; if (w && te > a) break; n.push({ value: te }) } return w && f && A !== a ? n.length && ja(n[n.length - 1].value, a, PT(a, C, t)) ? n[n.length - 1].value = a : n.push({ value: a }) : (!w || A === a) && n.push({ value: A }), n }({ maxTicks: r, bounds: e.bounds, min: e.min, max: e.max, precision: n.precision, step: n.stepSize, count: n.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: n.minRotation || 0, includeBounds: !1 !== n.includeBounds }, this._range || this); return "ticks" === e.bounds && Fv(o, this, "value"), e.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o } configure() { const e = this.ticks; let n = this.min, r = this.max; if (super.configure(), this.options.offset && e.length) { const i = (r - n) / Math.max(e.length - 1, 1) / 2; n -= i, r += i } this._startValue = n, this._endValue = r, this._valueRange = r - n } getLabelForValue(e) { return $a(e, this.chart.options.locale, this.options.ticks.format) } } class Bp extends rc { determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = Ne(e) ? e : 0, this.max = Ne(n) ? n : 1, this.handleTickRangeOptions() } computeTickLimit() { const e = this.isHorizontal(), n = e ? this.width : this.height, r = Ln(this.options.ticks.minRotation), i = (e ? Math.sin(r) : Math.cos(r)) || .001, s = this._resolveTickFontOptions(0); return Math.ceil(n / Math.min(40, s.lineHeight / i)) } getPixelForValue(e) { return null === e ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getValueForPixel(e) { return this._startValue + this.getDecimalForPixel(e) * this._valueRange } } I(Bp, "id", "linear"), I(Bp, "defaults", { ticks: { callback: P0.formatters.numeric } }); const sl = t => Math.floor(ti(t)), $i = (t, e) => Math.pow(10, sl(t) + e); function OT(t) { return t / Math.pow(10, sl(t)) == 1 } function RT(t, e, n) { const r = Math.pow(10, n), i = Math.floor(t / r); return Math.ceil(e / r) - i } class jp extends Ui { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(e, n) { const r = rc.prototype.parse.apply(this, [e, n]); if (0 !== r) return Ne(r) && r > 0 ? r : null; this._zero = !0 } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = Ne(e) ? Math.max(0, e) : null, this.max = Ne(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Ne(this._userMin) && (this.min = e === $i(this.min, 0) ? $i(this.min, -1) : $i(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let r = this.min, i = this.max; const s = a => r = e ? r : a, o = a => i = n ? i : a; r === i && (r <= 0 ? (s(1), o(10)) : (s($i(r, -1)), o($i(i, 1)))), r <= 0 && s($i(i, -1)), i <= 0 && o($i(r, 1)), this.min = r, this.max = i } buildTicks() { const e = this.options, r = function o9(t, { min: e, max: n }) { e = Xt(t.min, e); const r = [], i = sl(e); let s = function s9(t, e) { let r = sl(e - t); for (; RT(t, e, r) > 10;)r++; for (; RT(t, e, r) < 10;)r--; return Math.min(r, sl(t)) }(e, n), o = s < 0 ? Math.pow(10, Math.abs(s)) : 1; const a = Math.pow(10, s), l = i > s ? Math.pow(10, i) : 0, u = Math.round((e - l) * o) / o, c = Math.floor((e - l) / a / 10) * a * 10; let d = Math.floor((u - c) / Math.pow(10, s)), f = Xt(t.min, Math.round((l + c + d * Math.pow(10, s)) * o) / o); for (; f < n;)r.push({ value: f, major: OT(f), significand: d }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (s++, d = 2, o = s >= 0 ? 1 : o), f = Math.round((l + c + d * Math.pow(10, s)) * o) / o; const h = Xt(t.max, f); return r.push({ value: h, major: OT(h), significand: d }), r }({ min: this._userMin, max: this._userMax }, this); return "ticks" === e.bounds && Fv(r, this, "value"), e.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r } getLabelForValue(e) { return void 0 === e ? "0" : $a(e, this.chart.options.locale, this.options.ticks.format) } configure() { const e = this.min; super.configure(), this._startValue = ti(e), this._valueRange = ti(this.max) - ti(e) } getPixelForValue(e) { return (void 0 === e || 0 === e) && (e = this.min), null === e || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (ti(e) - this._startValue) / this._valueRange) } getValueForPixel(e) { const n = this.getDecimalForPixel(e); return Math.pow(10, this._startValue + n * this._valueRange) } } function Hp(t) { const e = t.ticks; if (e.display && t.display) { const n = wt(e.backdropPadding); return B(e.font && e.font.size, Ze.font.size) + n.height } return 0 } function a9(t, e, n) { return n = De(n) ? n : [n], { w: gN(t, e.string, n), h: n.length * e.lineHeight } } function FT(t, e, n, r, i) { return t === r || t === i ? { start: e - n / 2, end: e + n / 2 } : t < r || t > i ? { start: e - n, end: e } : { start: e, end: e + n } } function u9(t, e, n, r, i) { const s = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n)); let a = 0, l = 0; r.start < e.l ? (a = (e.l - r.start) / s, t.l = Math.min(t.l, e.l - a)) : r.end > e.r && (a = (r.end - e.r) / s, t.r = Math.max(t.r, e.r + a)), i.start < e.t ? (l = (e.t - i.start) / o, t.t = Math.min(t.t, e.t - l)) : i.end > e.b && (l = (i.end - e.b) / o, t.b = Math.max(t.b, e.b + l)) } function c9(t, e, n) { const r = t.drawingArea, { extra: i, additionalAngle: s, padding: o, size: a } = n, l = t.getPointPosition(e, r + i + o, s), u = Math.round(op(Qt(l.angle + Le))), c = function g9(t, e, n) { return 90 === n || 270 === n ? t -= e / 2 : (n > 270 || n < 90) && (t -= e), t }(l.y, a.h, u), d = function h9(t) { return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right" }(u), f = function p9(t, e, n) { return "right" === n ? t -= e : "center" === n && (t -= e / 2), t }(l.x, a.w, d); return { visible: !0, x: l.x, y: c, textAlign: d, left: f, top: c, right: f + a.w, bottom: c + a.h } } function d9(t, e) { if (!e) return !0; const { left: n, top: r, right: i, bottom: s } = t; return !(xr({ x: n, y: r }, e) || xr({ x: n, y: s }, e) || xr({ x: i, y: r }, e) || xr({ x: i, y: s }, e)) } function m9(t, e, n) { const { left: r, top: i, right: s, bottom: o } = n, { backdropColor: a } = e; if (!de(a)) { const l = Zi(e.borderRadius), u = wt(e.backdropPadding); t.fillStyle = a; const c = r - u.left, d = i - u.top, f = s - r + u.width, h = o - i + u.height; Object.values(l).some(p => 0 !== p) ? (t.beginPath(), Wa(t, { x: c, y: d, w: f, h, radius: l }), t.fill()) : t.fillRect(c, d, f, h) } } function NT(t, e, n, r) { const { ctx: i } = t; if (n) i.arc(t.xCenter, t.yCenter, e, 0, Ce); else { let s = t.getPointPosition(0, e); i.moveTo(s.x, s.y); for (let o = 1; o < r; o++)s = t.getPointPosition(o, e), i.lineTo(s.x, s.y) } } I(jp, "id", "logarithmic"), I(jp, "defaults", { ticks: { callback: P0.formatters.logarithmic, major: { enabled: !0 } } }); class ol extends rc { constructor(e) { super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const e = this._padding = wt(Hp(this.options) / 2), n = this.width = this.maxWidth - e.width, r = this.height = this.maxHeight - e.height; this.xCenter = Math.floor(this.left + n / 2 + e.left), this.yCenter = Math.floor(this.top + r / 2 + e.top), this.drawingArea = Math.floor(Math.min(n, r) / 2) } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!1); this.min = Ne(e) && !isNaN(e) ? e : 0, this.max = Ne(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / Hp(this.options)) } generateTickLabels(e) { rc.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((n, r) => { const i = z(this.options.pointLabels.callback, [n, r], this); return i || 0 === i ? i : "" }).filter((n, r) => this.chart.getDataVisibility(r)) } fit() { const e = this.options; e.display && e.pointLabels.display ? function l9(t) { const e = { l: t.left + t._padding.left, r: t.right - t._padding.right, t: t.top + t._padding.top, b: t.bottom - t._padding.bottom }, n = Object.assign({}, e), r = [], i = [], s = t._pointLabels.length, o = t.options.pointLabels, a = o.centerPointLabels ? Ee / s : 0; for (let l = 0; l < s; l++) { const u = o.setContext(t.getPointLabelContext(l)); i[l] = u.padding; const c = t.getPointPosition(l, t.drawingArea + i[l], a), d = tt(u.font), f = a9(t.ctx, d, t._pointLabels[l]); r[l] = f; const h = Qt(t.getIndexAngle(l) + a), p = Math.round(op(h)); u9(n, e, h, FT(p, c.x, f.w, 0, 180), FT(p, c.y, f.h, 90, 270)) } t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b), t._pointLabelItems = function f9(t, e, n) { const r = [], i = t._pointLabels.length, s = t.options, { centerPointLabels: o, display: a } = s.pointLabels, l = { extra: Hp(s) / 2, additionalAngle: o ? Ee / i : 0 }; let u; for (let c = 0; c < i; c++) { l.padding = n[c], l.size = e[c]; const d = c9(t, c, l); r.push(d), "auto" === a && (d.visible = d9(d, u), d.visible && (u = d)) } return r }(t, r, i) }(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(e, n, r, i) { this.xCenter += Math.floor((e - n) / 2), this.yCenter += Math.floor((r - i) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, r, i)) } getIndexAngle(e) { return Qt(e * (Ce / (this._pointLabels.length || 1)) + Ln(this.options.startAngle || 0)) } getDistanceFromCenterForValue(e) { if (de(e)) return NaN; const n = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - e) * n : (e - this.min) * n } getValueForDistanceFromCenter(e) { if (de(e)) return NaN; const n = e / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - n : this.min + n } getPointLabelContext(e) { const n = this._pointLabels || []; if (e >= 0 && e < n.length) { const r = n[e]; return function w9(t, e, n) { return ni(t, { label: n, index: e, type: "pointLabel" }) }(this.getContext(), e, r) } } getPointPosition(e, n, r = 0) { const i = this.getIndexAngle(e) - Le + r; return { x: Math.cos(i) * n + this.xCenter, y: Math.sin(i) * n + this.yCenter, angle: i } } getPointPositionForValue(e, n) { return this.getPointPosition(e, this.getDistanceFromCenterForValue(n)) } getBasePosition(e) { return this.getPointPositionForValue(e || 0, this.getBaseValue()) } getPointLabelPosition(e) { const { left: n, top: r, right: i, bottom: s } = this._pointLabelItems[e]; return { left: n, top: r, right: i, bottom: s } } drawBackground() { const { backgroundColor: e, grid: { circular: n } } = this.options; if (e) { const r = this.ctx; r.save(), r.beginPath(), NT(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), r.closePath(), r.fillStyle = e, r.fill(), r.restore() } } drawGrid() { const e = this.ctx, n = this.options, { angleLines: r, grid: i, border: s } = n, o = this._pointLabels.length; let a, l, u; if (n.pointLabels.display && function _9(t, e) { const { ctx: n, options: { pointLabels: r } } = t; for (let i = e - 1; i >= 0; i--) { const s = t._pointLabelItems[i]; if (!s.visible) continue; const o = r.setContext(t.getPointLabelContext(i)); m9(n, o, s); const a = tt(o.font), { x: l, y: u, textAlign: c } = s; Li(n, t._pointLabels[i], l, u + a.lineHeight / 2, a, { color: o.color, textAlign: c, textBaseline: "middle" }) } }(this, o), i.display && this.ticks.forEach((c, d) => { if (0 !== d) { l = this.getDistanceFromCenterForValue(c.value); const f = this.getContext(d), h = i.setContext(f), p = s.setContext(f); !function y9(t, e, n, r, i) { const s = t.ctx, o = e.circular, { color: a, lineWidth: l } = e; !o && !r || !a || !l || n < 0 || (s.save(), s.strokeStyle = a, s.lineWidth = l, s.setLineDash(i.dash), s.lineDashOffset = i.dashOffset, s.beginPath(), NT(t, n, o, r), s.closePath(), s.stroke(), s.restore()) }(this, h, l, o, p) } }), r.display) { for (e.save(), a = o - 1; a >= 0; a--) { const c = r.setContext(this.getPointLabelContext(a)), { color: d, lineWidth: f } = c; !f || !d || (e.lineWidth = f, e.strokeStyle = d, e.setLineDash(c.borderDash), e.lineDashOffset = c.borderDashOffset, l = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max), u = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(u.x, u.y), e.stroke()) } e.restore() } } drawBorder() { } drawLabels() { const e = this.ctx, n = this.options, r = n.ticks; if (!r.display) return; const i = this.getIndexAngle(0); let s, o; e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(i), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => { if (0 === l && !n.reverse) return; const u = r.setContext(this.getContext(l)), c = tt(u.font); if (s = this.getDistanceFromCenterForValue(this.ticks[l].value), u.showLabelBackdrop) { e.font = c.string, o = e.measureText(a.label).width, e.fillStyle = u.backdropColor; const d = wt(u.backdropPadding); e.fillRect(-o / 2 - d.left, -s - c.size / 2 - d.top, o + d.width, c.size + d.height) } Li(e, a.label, 0, -s, c, { color: u.color }) }), e.restore() } drawTitle() { } } I(ol, "id", "radialLinear"), I(ol, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: P0.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback: e => e, padding: 5, centerPointLabels: !1 } }), I(ol, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), I(ol, "descriptors", { angleLines: { _fallback: "grid" } }); const ic = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, Lt = Object.keys(ic); function v9(t, e) { return t - e } function LT(t, e) { if (de(e)) return null; const n = t._adapter, { parser: r, round: i, isoWeekday: s } = t._parseOpts; let o = e; return "function" == typeof r && (o = r(o)), Ne(o) || (o = "string" == typeof r ? n.parse(o, r) : n.parse(o)), null === o ? null : (i && (o = "week" !== i || !io(s) && !0 !== s ? n.startOf(o, i) : n.startOf(o, "isoWeek", s)), +o) } function ZT(t, e, n, r) { const i = Lt.length; for (let s = Lt.indexOf(t); s < i - 1; ++s) { const o = ic[Lt[s]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER; if (o.common && Math.ceil((n - e) / (a * o.size)) <= r) return Lt[s] } return Lt[i - 1] } function VT(t, e, n) { if (n) { if (n.length) { const { lo: r, hi: i } = lp(n, e); t[n[r] >= e ? n[r] : n[i]] = !0 } } else t[e] = !0 } function BT(t, e, n) { const r = [], i = {}, s = e.length; let o, a; for (o = 0; o < s; ++o)a = e[o], i[a] = o, r.push({ value: a, major: !1 }); return 0 !== s && n ? function k9(t, e, n, r) { const i = t._adapter, s = +i.startOf(e[0].value, r), o = e[e.length - 1].value; let a, l; for (a = s; a <= o; a = +i.add(a, 1, r))l = n[a], l >= 0 && (e[l].major = !0); return e }(t, r, i, n) : r } class al extends Ui { constructor(e) { super(e), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(e, n = {}) { const r = e.time || (e.time = {}), i = this._adapter = new A4__date(e.adapters.date); i.init(n), Va(r.displayFormats, i.formats()), this._parseOpts = { parser: r.parser, round: r.round, isoWeekday: r.isoWeekday }, super.init(e), this._normalized = n.normalized } parse(e, n) { return void 0 === e ? null : LT(this, e) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const e = this.options, n = this._adapter, r = e.time.unit || "day"; let { min: i, max: s, minDefined: o, maxDefined: a } = this.getUserBounds(); function l(u) { !o && !isNaN(u.min) && (i = Math.min(i, u.min)), !a && !isNaN(u.max) && (s = Math.max(s, u.max)) } (!o || !a) && (l(this._getLabelBounds()), ("ticks" !== e.bounds || "labels" !== e.ticks.source) && l(this.getMinMax(!1))), i = Ne(i) && !isNaN(i) ? i : +n.startOf(Date.now(), r), s = Ne(s) && !isNaN(s) ? s : +n.endOf(Date.now(), r) + 1, this.min = Math.min(i, s - 1), this.max = Math.max(i + 1, s) } _getLabelBounds() { const e = this.getLabelTimestamps(); let n = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY; return e.length && (n = e[0], r = e[e.length - 1]), { min: n, max: r } } buildTicks() { const e = this.options, n = e.time, r = e.ticks, i = "labels" === r.source ? this.getLabelTimestamps() : this._generate(); "ticks" === e.bounds && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]); const s = this.min, a = function nN(t, e, n) { let r = 0, i = t.length; for (; r < i && t[r] < e;)r++; for (; i > r && t[i - 1] > n;)i--; return r > 0 || i < t.length ? t.slice(r, i) : t }(i, s, this.max); return this._unit = n.unit || (r.autoSkip ? ZT(n.minUnit, this.min, this.max, this._getLabelCapacity(s)) : function b9(t, e, n, r, i) { for (let s = Lt.length - 1; s >= Lt.indexOf(n); s--) { const o = Lt[s]; if (ic[o].common && t._adapter.diff(i, r, o) >= e - 1) return o } return Lt[n ? Lt.indexOf(n) : 0] }(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = r.major.enabled && "year" !== this._unit ? function T9(t) { for (let e = Lt.indexOf(t) + 1, n = Lt.length; e < n; ++e)if (ic[Lt[e]].common) return Lt[e] }(this._unit) : void 0, this.initOffsets(i), e.reverse && a.reverse(), BT(this, a, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(e => +e.value)) } initOffsets(e = []) { let i, s, n = 0, r = 0; this.options.offset && e.length && (i = this.getDecimalForValue(e[0]), n = 1 === e.length ? 1 - i : (this.getDecimalForValue(e[1]) - i) / 2, s = this.getDecimalForValue(e[e.length - 1]), r = 1 === e.length ? s : (s - this.getDecimalForValue(e[e.length - 2])) / 2); const o = e.length < 3 ? .5 : .25; n = at(n, 0, o), r = at(r, 0, o), this._offsets = { start: n, end: r, factor: 1 / (n + 1 + r) } } _generate() { const e = this._adapter, n = this.min, r = this.max, i = this.options, s = i.time, o = s.unit || ZT(s.minUnit, n, r, this._getLabelCapacity(n)), a = B(i.ticks.stepSize, 1), l = "week" === o && s.isoWeekday, u = io(l) || !0 === l, c = {}; let f, h, d = n; if (u && (d = +e.startOf(d, "isoWeek", l)), d = +e.startOf(d, u ? "day" : o), e.diff(r, n, o) > 1e5 * a) throw new Error(n + " and " + r + " are too far apart with stepSize of " + a + " " + o); const p = "data" === i.ticks.source && this.getDataTimestamps(); for (f = d, h = 0; f < r; f = +e.add(f, a, o), h++)VT(c, f, p); return (f === r || "ticks" === i.bounds || 1 === h) && VT(c, f, p), Object.keys(c).sort((m, y) => m - y).map(m => +m) } getLabelForValue(e) { const r = this.options.time; return this._adapter.format(e, r.tooltipFormat ? r.tooltipFormat : r.displayFormats.datetime) } format(e, n) { return this._adapter.format(e, n || this.options.time.displayFormats[this._unit]) } _tickFormatFunction(e, n, r, i) { const s = this.options, o = s.ticks.callback; if (o) return z(o, [e, n, r], this); const a = s.time.displayFormats, l = this._unit, u = this._majorUnit, d = u && a[u], f = r[n]; return this._adapter.format(e, i || (u && d && f && f.major ? d : l && a[l])) } generateTickLabels(e) { let n, r, i; for (n = 0, r = e.length; n < r; ++n)i = e[n], i.label = this._tickFormatFunction(i.value, n, e) } getDecimalForValue(e) { return null === e ? NaN : (e - this.min) / (this.max - this.min) } getPixelForValue(e) { const n = this._offsets, r = this.getDecimalForValue(e); return this.getPixelForDecimal((n.start + r) * n.factor) } getValueForPixel(e) { const n = this._offsets, r = this.getDecimalForPixel(e) / n.factor - n.end; return this.min + r * (this.max - this.min) } _getLabelSize(e) { const n = this.options.ticks, r = this.ctx.measureText(e).width, i = Ln(this.isHorizontal() ? n.maxRotation : n.minRotation), s = Math.cos(i), o = Math.sin(i), a = this._resolveTickFontOptions(0).size; return { w: r * s + a * o, h: r * o + a * s } } _getLabelCapacity(e) { const n = this.options.time, r = n.displayFormats, i = r[n.unit] || r.millisecond, s = this._tickFormatFunction(e, 0, BT(this, [e], this._majorUnit), i), o = this._getLabelSize(s), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1; return a > 0 ? a : 1 } getDataTimestamps() { let n, r, e = this._cache.data || []; if (e.length) return e; const i = this.getMatchingVisibleMetas(); if (this._normalized && i.length) return this._cache.data = i[0].controller.getAllParsedValues(this); for (n = 0, r = i.length; n < r; ++n)e = e.concat(i[n].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(e) } getLabelTimestamps() { const e = this._cache.labels || []; let n, r; if (e.length) return e; const i = this.getLabels(); for (n = 0, r = i.length; n < r; ++n)e.push(LT(this, i[n])); return this._cache.labels = this._normalized ? e : this.normalize(e) } normalize(e) { return Bv(e.sort(v9)) } } function sc(t, e, n) { let s, o, a, l, r = 0, i = t.length - 1; n ? (e >= t[r].pos && e <= t[i].pos && ({ lo: r, hi: i } = Cr(t, "pos", e)), ({ pos: s, time: a } = t[r]), ({ pos: o, time: l } = t[i])) : (e >= t[r].time && e <= t[i].time && ({ lo: r, hi: i } = Cr(t, "time", e)), ({ time: s, pos: a } = t[r]), ({ time: o, pos: l } = t[i])); const u = o - s; return u ? a + (l - a) * (e - s) / u : a } I(al, "id", "time"), I(al, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); class Up extends al { constructor(e) { super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const e = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(e); this._minPos = sc(n, this.min), this._tableRange = sc(n, this.max) - this._minPos, super.initOffsets(e) } buildLookupTable(e) { const { min: n, max: r } = this, i = [], s = []; let o, a, l, u, c; for (o = 0, a = e.length; o < a; ++o)u = e[o], u >= n && u <= r && i.push(u); if (i.length < 2) return [{ time: n, pos: 0 }, { time: r, pos: 1 }]; for (o = 0, a = i.length; o < a; ++o)c = i[o + 1], l = i[o - 1], u = i[o], Math.round((c + l) / 2) !== u && s.push({ time: u, pos: o / (a - 1) }); return s } _getTimestampsForTable() { let e = this._cache.all || []; if (e.length) return e; const n = this.getDataTimestamps(), r = this.getLabelTimestamps(); return e = n.length && r.length ? this.normalize(n.concat(r)) : n.length ? n : r, e = this._cache.all = e, e } getDecimalForValue(e) { return (sc(this._table, e) - this._minPos) / this._tableRange } getValueForPixel(e) { const n = this._offsets, r = this.getDecimalForPixel(e) / n.factor - n.end; return sc(this._table, r * this._tableRange + this._minPos, !0) } } I(Up, "id", "timeseries"), I(Up, "defaults", al.defaults); const C9 = [I4, oZ, e9, Object.freeze({ __proto__: null, CategoryScale: Vp, LinearScale: Bp, LogarithmicScale: jp, RadialLinearScale: ol, TimeScale: al, TimeSeriesScale: Up })]; var x9 = Ye(386), ll = Ye.n(x9); const ul = t => t && t.enabled && t.modifierKey, jT = (t, e) => t && e[t + "Key"], $p = (t, e) => t && !e[t + "Key"]; function si(t, e, n) { return void 0 === t || ("string" == typeof t ? -1 !== t.indexOf(e) : "function" == typeof t && -1 !== t({ chart: n }).indexOf(e)) } function zp(t, e) { return "function" == typeof t && (t = t({ chart: e })), "string" == typeof t ? { x: -1 !== t.indexOf("x"), y: -1 !== t.indexOf("y") } : { x: !1, y: !1 } } function HT(t, e, n) { const { mode: r = "xy", scaleMode: i, overScaleMode: s } = t || {}, o = function M9({ x: t, y: e }, n) { const r = n.scales, i = Object.keys(r); for (let s = 0; s < i.length; s++) { const o = r[i[s]]; if (e >= o.top && e <= o.bottom && t >= o.left && t <= o.right) return o } return null }(e, n), a = zp(r, n), l = zp(i, n); if (s) { const c = zp(s, n); for (const d of ["x", "y"]) c[d] && (l[d] = a[d], a[d] = !1) } if (o && l[o.axis]) return [o]; const u = []; return re(n.scales, function (c) { a[c.axis] && u.push(c) }), u } const Wp = new WeakMap; function He(t) { let e = Wp.get(t); return e || (e = { originalScaleLimits: {}, updatedScaleLimits: {}, handlers: {}, panDelta: {} }, Wp.set(t, e)), e } function UT(t, e, n) { const r = t.max - t.min, i = r * (e - 1), s = t.isHorizontal() ? n.x : n.y, o = Math.max(0, Math.min(1, (t.getValueForPixel(s) - t.min) / r || 0)); return { min: i * o, max: i * (1 - o) } } function $T(t, e, n, r, i) { let s = n[r]; if ("original" === s) { const o = t.originalScaleLimits[e.id][r]; s = B(o.options, o.scale) } return B(s, i) } function uo(t, { min: e, max: n }, r, i = !1) { const s = He(t.chart), { id: o, axis: a, options: l } = t, u = r && (r[o] || r[a]) || {}, { minRange: c = 0 } = u, d = $T(s, t, u, "min", -1 / 0), f = $T(s, t, u, "max", 1 / 0), h = i ? Math.max(n - e, c) : t.max - t.min, p = (h - n + e) / 2; return n += p, (e -= p) < d ? (e = d, n = Math.min(d + h, f)) : n > f && (n = f, e = Math.max(f - h, d)), l.min = e, l.max = n, s.updatedScaleLimits[t.id] = { min: e, max: n }, t.parse(e) !== t.min || t.parse(n) !== t.max } const zT = t => 0 === t || isNaN(t) ? 0 : t < 0 ? Math.min(Math.round(t), -1) : Math.max(Math.round(t), 1), L9 = { second: 500, minute: 3e4, hour: 18e5, day: 432e5, week: 3024e5, month: 1296e6, quarter: 5184e6, year: 157248e5 }; function WT(t, e, n, r = !1) { const { min: i, max: s, options: o } = t, l = L9[o.time && o.time.round] || 0, u = t.getValueForPixel(t.getPixelForValue(i + l) - e), c = t.getValueForPixel(t.getPixelForValue(s + l) - e), { min: d = -1 / 0, max: f = 1 / 0 } = r && n && n[t.axis] || {}; return !!(isNaN(u) || isNaN(c) || u < d || c > f) || uo(t, { min: u, max: c }, n, r) } function qT(t, e, n) { return WT(t, e, n, !0) } const qp = { category: function R9(t, e, n, r) { const i = UT(t, e, n); return t.min === t.max && e < 1 && function O9(t) { const n = t.getLabels().length - 1; t.min > 0 && (t.min -= 1), t.max < n && (t.max += 1) }(t), uo(t, { min: t.min + zT(i.min), max: t.max - zT(i.max) }, r, !0) }, default: function A9(t, e, n, r) { const i = UT(t, e, n); return uo(t, { min: t.min + i.min, max: t.max - i.max }, r, !0) } }, Gp = { default: function P9(t, e, n, r) { uo(t, function I9(t, e, n) { const r = t.getValueForPixel(e), i = t.getValueForPixel(n); return { min: Math.min(r, i), max: Math.max(r, i) } }(t, e, n), r, !0) } }, Yp = { category: function N9(t, e, n) { const i = t.getLabels().length - 1; let { min: s, max: o } = t; const a = Math.max(o - s, 1), l = Math.round(function F9(t) { return t.isHorizontal() ? t.width : t.height }(t) / Math.max(a, 10)), u = Math.round(Math.abs(e / l)); let c; return e < -l ? (o = Math.min(o + u, i), s = 1 === a ? o : o - a, c = o === i) : e > l && (s = Math.max(0, s - u), o = 1 === a ? s : s + a, c = 0 === s), uo(t, { min: s, max: o }, n) || c }, default: WT, logarithmic: qT, timeseries: qT }; function GT(t, e) { re(t, (n, r) => { e[r] || delete t[r] }) } function co(t, e) { const { scales: n } = t, { originalScaleLimits: r, updatedScaleLimits: i } = e; return re(n, function (s) { (function Z9(t, e, n) { const { id: r, options: { min: i, max: s } } = t; if (!e[r] || !n[r]) return !0; const o = n[r]; return o.min !== i || o.max !== s })(s, r, i) && (r[s.id] = { min: { scale: s.min, options: s.options.min }, max: { scale: s.max, options: s.options.max } }) }), GT(r, n), GT(i, n), r } function YT(t, e, n, r) { z(qp[t.type] || qp.default, [t, e, n, r]) } function XT(t, e, n, r, i) { z(Gp[t.type] || Gp.default, [t, e, n, r, i]) } function V9(t) { const e = t.chartArea; return { x: (e.left + e.right) / 2, y: (e.top + e.bottom) / 2 } } function Xp(t, e, n = "none") { const { x: r = 1, y: i = 1, focalPoint: s = V9(t) } = "number" == typeof e ? { x: e, y: e } : e, o = He(t), { options: { limits: a, zoom: l } } = o; co(t, o); const u = 1 !== r, c = 1 !== i; re(HT(l, s, t) || t.scales, function (f) { f.isHorizontal() && u ? YT(f, r, s, a) : !f.isHorizontal() && c && YT(f, i, s, a) }), t.update(n), z(l.onZoom, [{ chart: t }]) } function QT(t, e, n, r = "none") { const i = He(t), { options: { limits: s, zoom: o } } = i, { mode: a = "xy" } = o; co(t, i); const l = si(a, "x", t), u = si(a, "y", t); re(t.scales, function (c) { c.isHorizontal() && l ? XT(c, e.x, n.x, s) : !c.isHorizontal() && u && XT(c, e.y, n.y, s) }), t.update(r), z(o.onZoom, [{ chart: t }]) } function KT(t, e, n, r) { const { panDelta: i } = r, s = i[t.id] || 0; hn(s) === hn(e) && (e += s), i[t.id] = z(Yp[t.type] || Yp.default, [t, e, n]) ? 0 : e } function JT(t, e, n, r = "none") { const { x: i = 0, y: s = 0 } = "number" == typeof e ? { x: e, y: e } : e, o = He(t), { options: { pan: a, limits: l } } = o, { onPan: u } = a || {}; co(t, o); const c = 0 !== i, d = 0 !== s; re(n || t.scales, function (f) { f.isHorizontal() && c ? KT(f, i, l, o) : !f.isHorizontal() && d && KT(f, s, l, o) }), t.update(r), z(u, [{ chart: t }]) } function ek(t) { const e = He(t); co(t, e); const n = {}; for (const r of Object.keys(t.scales)) { const { min: i, max: s } = e.originalScaleLimits[r] || { min: {}, max: {} }; n[r] = { min: i.scale, max: s.scale } } return n } function Zt(t, e) { const { handlers: n } = He(t), r = n[e]; r && r.target && (r.target.removeEventListener(e, r), delete n[e]) } function cl(t, e, n, r) { const { handlers: i, options: s } = He(t), o = i[n]; o && o.target === e || (Zt(t, n), i[n] = a => r(t, a, s), i[n].target = e, e.addEventListener(n, i[n])) } function z9(t, e) { const n = He(t); n.dragStart && (n.dragging = !0, n.dragEnd = e, t.update("none")) } function W9(t, e) { const n = He(t); !n.dragStart || "Escape" !== e.key || (Zt(t, "keydown"), n.dragging = !1, n.dragStart = n.dragEnd = null, t.update("none")) } function tk(t, e, n) { const { onZoomStart: r, onZoomRejected: i } = n; if (r && !1 === z(r, [{ chart: t, event: e, point: rr(e, t) }])) return z(i, [{ chart: t, event: e }]), !1 } function q9(t, e) { const n = He(t), { pan: r, zoom: i = {} } = n.options; if (0 !== e.button || jT(ul(r), e) || $p(ul(i.drag), e)) return z(i.onZoomRejected, [{ chart: t, event: e }]); !1 !== tk(t, e, i) && (n.dragStart = e, cl(t, t.canvas, "mousemove", z9), cl(t, window.document, "keydown", W9)) } function nk(t, e, n, r) { const i = si(e, "x", t), s = si(e, "y", t); let { top: o, left: a, right: l, bottom: u, width: c, height: d } = t.chartArea; const f = rr(n, t), h = rr(r, t); i && (a = Math.min(f.x, h.x), l = Math.max(f.x, h.x)), s && (o = Math.min(f.y, h.y), u = Math.max(f.y, h.y)); const p = l - a, m = u - o; return { left: a, top: o, right: l, bottom: u, width: p, height: m, zoomX: i && p ? 1 + (c - p) / c : 1, zoomY: s && m ? 1 + (d - m) / d : 1 } } function G9(t, e) { const n = He(t); if (!n.dragStart) return; Zt(t, "mousemove"); const { mode: r, onZoomComplete: i, drag: { threshold: s = 0 } } = n.options.zoom, o = nk(t, r, n.dragStart, e), a = si(r, "x", t) ? o.width : 0, l = si(r, "y", t) ? o.height : 0, u = Math.sqrt(a * a + l * l); if (n.dragStart = n.dragEnd = null, u <= s) return n.dragging = !1, void t.update("none"); QT(t, { x: o.left, y: o.top }, { x: o.right, y: o.bottom }, "zoom"), setTimeout(() => n.dragging = !1, 500), z(i, [{ chart: t }]) } function X9(t, e) { const { handlers: { onZoomComplete: n }, options: { zoom: r } } = He(t); if (!function Y9(t, e, n) { if (!$p(ul(n.wheel), e)) return !1 !== tk(t, e, n) && (e.cancelable && e.preventDefault(), void 0 !== e.deltaY) || void 0; z(n.onZoomRejected, [{ chart: t, event: e }]) }(t, e, r)) return; const i = e.target.getBoundingClientRect(), s = 1 + (e.deltaY >= 0 ? -r.wheel.speed : r.wheel.speed); Xp(t, { x: s, y: s, focalPoint: { x: e.clientX - i.left, y: e.clientY - i.top } }), n && n() } function e7(t, e) { return function (n, r) { const { pan: i, zoom: s = {} } = e.options; if (!i || !i.enabled) return !1; const o = r && r.srcEvent; return !(o && !e.panning && "mouse" === r.pointerType && ($p(ul(i), o) || jT(ul(s.drag), o)) && (z(i.onPanRejected, [{ chart: t, event: r }]), 1)) } } function rk(t, e, n) { if (e.scale) { const { center: r, pointers: i } = n, s = 1 / e.scale * n.scale, o = n.target.getBoundingClientRect(), a = function t7(t, e) { const n = Math.abs(t.clientX - e.clientX), r = Math.abs(t.clientY - e.clientY), i = n / r; let s, o; return i > .3 && i < 1.7 ? s = o = !0 : n > r ? s = !0 : o = !0, { x: s, y: o } }(i[0], i[1]), l = e.options.zoom.mode; Xp(t, { x: a.x && si(l, "x", t) ? s : 1, y: a.y && si(l, "y", t) ? s : 1, focalPoint: { x: r.x - o.left, y: r.y - o.top } }), e.scale = n.scale } } function ik(t, e, n) { const r = e.delta; r && (e.panning = !0, JT(t, { x: n.deltaX - r.x, y: n.deltaY - r.y }, e.panScales), e.delta = { x: n.deltaX, y: n.deltaY }) } const Qp = new WeakMap; function oc(t, e, n) { const r = n.zoom.drag, { dragStart: i, dragEnd: s } = He(t); if (r.drawTime !== e || !s) return; const { left: o, top: a, width: l, height: u } = nk(t, n.zoom.mode, i, s), c = t.ctx; c.save(), c.beginPath(), c.fillStyle = r.backgroundColor || "rgba(225,225,225,0.3)", c.fillRect(o, a, l, u), r.borderWidth > 0 && (c.lineWidth = r.borderWidth, c.strokeStyle = r.borderColor || "rgba(225,225,225)", c.strokeRect(o, a, l, u)), c.restore() } var u7 = { id: "zoom", version: "2.0.1", defaults: { pan: { enabled: !1, mode: "xy", threshold: 10, modifierKey: null }, zoom: { wheel: { enabled: !1, speed: .1, modifierKey: null }, drag: { enabled: !1, drawTime: "beforeDatasetsDraw", modifierKey: null }, pinch: { enabled: !1 }, mode: "xy" } }, start: function (t, e, n) { He(t).options = n, Object.prototype.hasOwnProperty.call(n.zoom, "enabled") && console.warn("The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`."), (Object.prototype.hasOwnProperty.call(n.zoom, "overScaleMode") || Object.prototype.hasOwnProperty.call(n.pan, "overScaleMode")) && console.warn("The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired)."), ll() && function o7(t, e) { const n = He(t), r = t.canvas, { pan: i, zoom: s } = e, o = new (ll().Manager)(r); s && s.pinch.enabled && (o.add(new (ll().Pinch)), o.on("pinchstart", () => function n7(t, e) { e.options.zoom.pinch.enabled && (e.scale = 1) }(0, n)), o.on("pinch", a => rk(t, n, a)), o.on("pinchend", a => function r7(t, e, n) { e.scale && (rk(t, e, n), e.scale = null, z(e.options.zoom.onZoomComplete, [{ chart: t }])) }(t, n, a))), i && i.enabled && (o.add(new (ll().Pan)({ threshold: i.threshold, enable: e7(t, n) })), o.on("panstart", a => function i7(t, e, n) { const { enabled: r, onPanStart: i, onPanRejected: s } = e.options.pan; if (!r) return; const o = n.target.getBoundingClientRect(), a = { x: n.center.x - o.left, y: n.center.y - o.top }; if (!1 === z(i, [{ chart: t, event: n, point: a }])) return z(s, [{ chart: t, event: n }]); e.panScales = HT(e.options.pan, a, t), e.delta = { x: 0, y: 0 }, clearTimeout(e.panEndTimeout), ik(t, e, n) }(t, n, a)), o.on("panmove", a => ik(t, n, a)), o.on("panend", () => function s7(t, e) { e.delta = null, e.panning && (e.panEndTimeout = setTimeout(() => e.panning = !1, 500), z(e.options.pan.onPanComplete, [{ chart: t }])) }(t, n))), Qp.set(t, o) }(t, n), t.pan = (i, s, o) => JT(t, i, s, o), t.zoom = (i, s) => Xp(t, i, s), t.zoomRect = (i, s, o) => QT(t, i, s, o), t.zoomScale = (i, s, o) => function B9(t, e, n, r = "none") { co(t, He(t)), uo(t.scales[e], n, void 0, !0), t.update(r) }(t, i, s, o), t.resetZoom = i => function j9(t, e = "default") { const n = He(t), r = co(t, n); re(t.scales, function (i) { const s = i.options; r[i.id] ? (s.min = r[i.id].min.options, s.max = r[i.id].max.options) : (delete s.min, delete s.max) }), t.update(e), z(n.options.zoom.onZoomComplete, [{ chart: t }]) }(t, i), t.getZoomLevel = () => function U9(t) { const e = He(t); let n = 1, r = 1; return re(t.scales, function (i) { const s = function H9(t, e) { const n = t.originalScaleLimits[e]; if (!n) return; const { min: r, max: i } = n; return B(i.options, i.scale) - B(r.options, r.scale) }(e, i.id); if (s) { const o = Math.round(s / (i.max - i.min) * 100) / 100; n = Math.min(n, o), r = Math.max(r, o) } }), n < 1 ? n : r }(t), t.getInitialScaleBounds = () => ek(t), t.isZoomedOrPanned = () => function $9(t) { const e = ek(t); for (const n of Object.keys(t.scales)) { const { min: r, max: i } = e[n]; if (void 0 !== r && t.scales[n].min !== r || void 0 !== i && t.scales[n].max !== i) return !0 } return !1 }(t) }, beforeEvent(t) { const e = He(t); if (e.panning || e.dragging) return !1 }, beforeUpdate: function (t, e, n) { He(t).options = n, function K9(t, e) { const n = t.canvas, { wheel: r, drag: i, onZoomComplete: s } = e.zoom; r.enabled ? (cl(t, n, "wheel", X9), function Q9(t, e, n, r) { n && (He(t).handlers[e] = function E9(t, e) { let n; return function () { return clearTimeout(n), n = setTimeout(t, e), e } }(() => z(n, [{ chart: t }]), r)) }(t, "onZoomComplete", s, 250)) : Zt(t, "wheel"), i.enabled ? (cl(t, n, "mousedown", q9), cl(t, n.ownerDocument, "mouseup", G9)) : (Zt(t, "mousedown"), Zt(t, "mousemove"), Zt(t, "mouseup"), Zt(t, "keydown")) }(t, n) }, beforeDatasetsDraw(t, e, n) { oc(t, "beforeDatasetsDraw", n) }, afterDatasetsDraw(t, e, n) { oc(t, "afterDatasetsDraw", n) }, beforeDraw(t, e, n) { oc(t, "beforeDraw", n) }, afterDraw(t, e, n) { oc(t, "afterDraw", n) }, stop: function (t) { (function J9(t) { Zt(t, "mousedown"), Zt(t, "mousemove"), Zt(t, "mouseup"), Zt(t, "wheel"), Zt(t, "click"), Zt(t, "keydown") })(t), ll() && function a7(t) { const e = Qp.get(t); e && (e.remove("pinchstart"), e.remove("pinch"), e.remove("pinchend"), e.remove("panstart"), e.remove("pan"), e.remove("panend"), e.destroy(), Qp.delete(t)) }(t), function S9(t) { Wp.delete(t) }(t) }, panFunctions: Yp, zoomFunctions: qp, zoomRectFunctions: Gp }; let c7 = (() => { class t { constructor() { this.bigData = [], this.bigLabels = [], this.smallData = [], this.smallLabels = [], this.bigDataCreate(), this.bigLabelsCreate(), this.smallDataCreate(), this.smallLabelsCreate() } bigDataCreate() { this.bigData = [{ stream_am: "13704546", week_start_dt: "2023-06-29T20:00:00.000Z", week_end_dt: "2023-07-05T20:00:00.000Z", week_num: 27, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13360626", week_start_dt: "2023-06-22T20:00:00.000Z", week_end_dt: "2023-06-28T20:00:00.000Z", week_num: 26, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13437870", week_start_dt: "2023-06-15T20:00:00.000Z", week_end_dt: "2023-06-21T20:00:00.000Z", week_num: 25, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13140522", week_start_dt: "2023-06-08T20:00:00.000Z", week_end_dt: "2023-06-14T20:00:00.000Z", week_num: 24, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13619161", week_start_dt: "2023-06-01T20:00:00.000Z", week_end_dt: "2023-06-07T20:00:00.000Z", week_num: 23, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14256397", week_start_dt: "2023-05-25T20:00:00.000Z", week_end_dt: "2023-05-31T20:00:00.000Z", week_num: 22, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13679909", week_start_dt: "2023-05-18T20:00:00.000Z", week_end_dt: "2023-05-24T20:00:00.000Z", week_num: 21, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13619638", week_start_dt: "2023-05-11T20:00:00.000Z", week_end_dt: "2023-05-17T20:00:00.000Z", week_num: 20, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13280199", week_start_dt: "2023-05-04T20:00:00.000Z", week_end_dt: "2023-05-10T20:00:00.000Z", week_num: 19, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13414254", week_start_dt: "2023-04-27T20:00:00.000Z", week_end_dt: "2023-05-03T20:00:00.000Z", week_num: 18, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13350754", week_start_dt: "2023-04-20T20:00:00.000Z", week_end_dt: "2023-04-26T20:00:00.000Z", week_num: 17, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13663273", week_start_dt: "2023-04-13T20:00:00.000Z", week_end_dt: "2023-04-19T20:00:00.000Z", week_num: 16, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13573025", week_start_dt: "2023-04-06T20:00:00.000Z", week_end_dt: "2023-04-12T20:00:00.000Z", week_num: 15, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13536360", week_start_dt: "2023-03-30T20:00:00.000Z", week_end_dt: "2023-04-05T20:00:00.000Z", week_num: 14, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13351748", week_start_dt: "2023-03-23T20:00:00.000Z", week_end_dt: "2023-03-29T20:00:00.000Z", week_num: 13, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13248220", week_start_dt: "2023-03-16T20:00:00.000Z", week_end_dt: "2023-03-22T20:00:00.000Z", week_num: 12, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13043781", week_start_dt: "2023-03-09T20:00:00.000Z", week_end_dt: "2023-03-15T20:00:00.000Z", week_num: 11, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13067320", week_start_dt: "2023-03-02T20:00:00.000Z", week_end_dt: "2023-03-08T20:00:00.000Z", week_num: 10, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12856939", week_start_dt: "2023-02-23T20:00:00.000Z", week_end_dt: "2023-03-01T20:00:00.000Z", week_num: 9, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12885737", week_start_dt: "2023-02-16T20:00:00.000Z", week_end_dt: "2023-02-22T20:00:00.000Z", week_num: 8, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12691458", week_start_dt: "2023-02-09T20:00:00.000Z", week_end_dt: "2023-02-15T20:00:00.000Z", week_num: 7, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12829504", week_start_dt: "2023-02-02T20:00:00.000Z", week_end_dt: "2023-02-08T20:00:00.000Z", week_num: 6, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12761969", week_start_dt: "2023-01-26T20:00:00.000Z", week_end_dt: "2023-02-01T20:00:00.000Z", week_num: 5, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13046141", week_start_dt: "2023-01-19T20:00:00.000Z", week_end_dt: "2023-01-25T20:00:00.000Z", week_num: 4, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13042860", week_start_dt: "2023-01-12T20:00:00.000Z", week_end_dt: "2023-01-18T20:00:00.000Z", week_num: 3, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12824600", week_start_dt: "2023-01-05T20:00:00.000Z", week_end_dt: "2023-01-11T20:00:00.000Z", week_num: 2, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13083060", week_start_dt: "2022-12-29T20:00:00.000Z", week_end_dt: "2023-01-04T20:00:00.000Z", week_num: 1, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11905552", week_start_dt: "2022-12-22T20:00:00.000Z", week_end_dt: "2022-12-28T20:00:00.000Z", week_num: 52, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11436728", week_start_dt: "2022-12-15T20:00:00.000Z", week_end_dt: "2022-12-21T20:00:00.000Z", week_num: 51, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11460414", week_start_dt: "2022-12-08T20:00:00.000Z", week_end_dt: "2022-12-14T20:00:00.000Z", week_num: 50, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11842843", week_start_dt: "2022-12-01T20:00:00.000Z", week_end_dt: "2022-12-07T20:00:00.000Z", week_num: 49, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11550564", week_start_dt: "2022-11-24T20:00:00.000Z", week_end_dt: "2022-11-30T20:00:00.000Z", week_num: 48, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12137820", week_start_dt: "2022-11-17T20:00:00.000Z", week_end_dt: "2022-11-23T20:00:00.000Z", week_num: 47, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12305938", week_start_dt: "2022-11-10T20:00:00.000Z", week_end_dt: "2022-11-16T20:00:00.000Z", week_num: 46, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12426095", week_start_dt: "2022-11-03T20:00:00.000Z", week_end_dt: "2022-11-09T20:00:00.000Z", week_num: 45, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12404572", week_start_dt: "2022-10-27T20:00:00.000Z", week_end_dt: "2022-11-02T20:00:00.000Z", week_num: 44, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12333467", week_start_dt: "2022-10-20T20:00:00.000Z", week_end_dt: "2022-10-26T20:00:00.000Z", week_num: 43, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12911926", week_start_dt: "2022-10-13T20:00:00.000Z", week_end_dt: "2022-10-19T20:00:00.000Z", week_num: 42, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12953863", week_start_dt: "2022-10-06T20:00:00.000Z", week_end_dt: "2022-10-12T20:00:00.000Z", week_num: 41, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12778275", week_start_dt: "2022-09-29T20:00:00.000Z", week_end_dt: "2022-10-05T20:00:00.000Z", week_num: 40, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13153433", week_start_dt: "2022-09-22T20:00:00.000Z", week_end_dt: "2022-09-28T20:00:00.000Z", week_num: 39, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13340904", week_start_dt: "2022-09-15T20:00:00.000Z", week_end_dt: "2022-09-21T20:00:00.000Z", week_num: 38, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13830255", week_start_dt: "2022-09-08T20:00:00.000Z", week_end_dt: "2022-09-14T20:00:00.000Z", week_num: 37, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13706066", week_start_dt: "2022-09-01T20:00:00.000Z", week_end_dt: "2022-09-07T20:00:00.000Z", week_num: 36, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13533543", week_start_dt: "2022-08-25T20:00:00.000Z", week_end_dt: "2022-08-31T20:00:00.000Z", week_num: 35, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13732629", week_start_dt: "2022-08-18T20:00:00.000Z", week_end_dt: "2022-08-24T20:00:00.000Z", week_num: 34, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14020744", week_start_dt: "2022-08-11T20:00:00.000Z", week_end_dt: "2022-08-17T20:00:00.000Z", week_num: 33, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14238945", week_start_dt: "2022-08-04T20:00:00.000Z", week_end_dt: "2022-08-10T20:00:00.000Z", week_num: 32, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14126108", week_start_dt: "2022-07-28T20:00:00.000Z", week_end_dt: "2022-08-03T20:00:00.000Z", week_num: 31, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14196951", week_start_dt: "2022-07-21T20:00:00.000Z", week_end_dt: "2022-07-27T20:00:00.000Z", week_num: 30, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14238525", week_start_dt: "2022-07-14T20:00:00.000Z", week_end_dt: "2022-07-20T20:00:00.000Z", week_num: 29, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14060840", week_start_dt: "2022-07-07T20:00:00.000Z", week_end_dt: "2022-07-13T20:00:00.000Z", week_num: 28, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14092472", week_start_dt: "2022-06-30T20:00:00.000Z", week_end_dt: "2022-07-06T20:00:00.000Z", week_num: 27, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13764086", week_start_dt: "2022-06-23T20:00:00.000Z", week_end_dt: "2022-06-29T20:00:00.000Z", week_num: 26, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14070398", week_start_dt: "2022-06-16T20:00:00.000Z", week_end_dt: "2022-06-22T20:00:00.000Z", week_num: 25, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13733361", week_start_dt: "2022-06-09T20:00:00.000Z", week_end_dt: "2022-06-15T20:00:00.000Z", week_num: 24, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13798198", week_start_dt: "2022-06-02T20:00:00.000Z", week_end_dt: "2022-06-08T20:00:00.000Z", week_num: 23, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13798277", week_start_dt: "2022-05-26T20:00:00.000Z", week_end_dt: "2022-06-01T20:00:00.000Z", week_num: 22, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13784701", week_start_dt: "2022-05-19T20:00:00.000Z", week_end_dt: "2022-05-25T20:00:00.000Z", week_num: 21, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13985527", week_start_dt: "2022-05-12T20:00:00.000Z", week_end_dt: "2022-05-18T20:00:00.000Z", week_num: 20, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14212381", week_start_dt: "2022-05-05T20:00:00.000Z", week_end_dt: "2022-05-11T20:00:00.000Z", week_num: 19, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14256522", week_start_dt: "2022-04-28T20:00:00.000Z", week_end_dt: "2022-05-04T20:00:00.000Z", week_num: 18, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13446377", week_start_dt: "2022-04-21T20:00:00.000Z", week_end_dt: "2022-04-27T20:00:00.000Z", week_num: 17, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13397532", week_start_dt: "2022-04-14T20:00:00.000Z", week_end_dt: "2022-04-20T20:00:00.000Z", week_num: 16, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13652126", week_start_dt: "2022-04-07T20:00:00.000Z", week_end_dt: "2022-04-13T20:00:00.000Z", week_num: 15, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13273304", week_start_dt: "2022-03-31T20:00:00.000Z", week_end_dt: "2022-04-06T20:00:00.000Z", week_num: 14, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12890885", week_start_dt: "2022-03-24T20:00:00.000Z", week_end_dt: "2022-03-30T20:00:00.000Z", week_num: 13, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12975822", week_start_dt: "2022-03-17T20:00:00.000Z", week_end_dt: "2022-03-23T20:00:00.000Z", week_num: 12, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13016835", week_start_dt: "2022-03-10T20:00:00.000Z", week_end_dt: "2022-03-16T20:00:00.000Z", week_num: 11, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12952360", week_start_dt: "2022-03-03T20:00:00.000Z", week_end_dt: "2022-03-09T20:00:00.000Z", week_num: 10, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12264814", week_start_dt: "2022-02-24T20:00:00.000Z", week_end_dt: "2022-03-02T20:00:00.000Z", week_num: 9, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12061183", week_start_dt: "2022-02-17T20:00:00.000Z", week_end_dt: "2022-02-23T20:00:00.000Z", week_num: 8, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11715139", week_start_dt: "2022-02-10T20:00:00.000Z", week_end_dt: "2022-02-16T20:00:00.000Z", week_num: 7, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11421985", week_start_dt: "2022-02-03T20:00:00.000Z", week_end_dt: "2022-02-09T20:00:00.000Z", week_num: 6, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11509797", week_start_dt: "2022-01-27T20:00:00.000Z", week_end_dt: "2022-02-02T20:00:00.000Z", week_num: 5, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11169815", week_start_dt: "2022-01-20T20:00:00.000Z", week_end_dt: "2022-01-26T20:00:00.000Z", week_num: 4, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11636296", week_start_dt: "2022-01-13T20:00:00.000Z", week_end_dt: "2022-01-19T20:00:00.000Z", week_num: 3, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11510446", week_start_dt: "2022-01-06T20:00:00.000Z", week_end_dt: "2022-01-12T20:00:00.000Z", week_num: 2, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12116205", week_start_dt: "2021-12-30T20:00:00.000Z", week_end_dt: "2022-01-05T20:00:00.000Z", week_num: 1, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12026950", week_start_dt: "2021-12-23T20:00:00.000Z", week_end_dt: "2021-12-29T20:00:00.000Z", week_num: 52, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11697213", week_start_dt: "2021-12-16T20:00:00.000Z", week_end_dt: "2021-12-22T20:00:00.000Z", week_num: 51, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11736984", week_start_dt: "2021-12-09T20:00:00.000Z", week_end_dt: "2021-12-15T20:00:00.000Z", week_num: 50, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11935417", week_start_dt: "2021-12-02T20:00:00.000Z", week_end_dt: "2021-12-08T20:00:00.000Z", week_num: 49, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11955892", week_start_dt: "2021-11-25T20:00:00.000Z", week_end_dt: "2021-12-01T20:00:00.000Z", week_num: 48, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12341465", week_start_dt: "2021-11-18T20:00:00.000Z", week_end_dt: "2021-11-24T20:00:00.000Z", week_num: 47, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11967181", week_start_dt: "2021-11-11T20:00:00.000Z", week_end_dt: "2021-11-17T20:00:00.000Z", week_num: 46, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12159350", week_start_dt: "2021-11-04T20:00:00.000Z", week_end_dt: "2021-11-10T20:00:00.000Z", week_num: 45, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12067444", week_start_dt: "2021-10-28T20:00:00.000Z", week_end_dt: "2021-11-03T20:00:00.000Z", week_num: 44, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12247665", week_start_dt: "2021-10-21T20:00:00.000Z", week_end_dt: "2021-10-27T20:00:00.000Z", week_num: 43, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12306159", week_start_dt: "2021-10-14T20:00:00.000Z", week_end_dt: "2021-10-20T20:00:00.000Z", week_num: 42, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12271146", week_start_dt: "2021-10-07T20:00:00.000Z", week_end_dt: "2021-10-13T20:00:00.000Z", week_num: 41, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12065813", week_start_dt: "2021-09-30T20:00:00.000Z", week_end_dt: "2021-10-06T20:00:00.000Z", week_num: 40, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12286347", week_start_dt: "2021-09-23T20:00:00.000Z", week_end_dt: "2021-09-29T20:00:00.000Z", week_num: 39, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12840886", week_start_dt: "2021-09-16T20:00:00.000Z", week_end_dt: "2021-09-22T20:00:00.000Z", week_num: 38, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12553565", week_start_dt: "2021-09-09T20:00:00.000Z", week_end_dt: "2021-09-15T20:00:00.000Z", week_num: 37, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13031928", week_start_dt: "2021-09-02T20:00:00.000Z", week_end_dt: "2021-09-08T20:00:00.000Z", week_num: 36, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12740152", week_start_dt: "2021-08-26T20:00:00.000Z", week_end_dt: "2021-09-01T20:00:00.000Z", week_num: 35, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12761579", week_start_dt: "2021-08-19T20:00:00.000Z", week_end_dt: "2021-08-25T20:00:00.000Z", week_num: 34, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12685515", week_start_dt: "2021-08-12T20:00:00.000Z", week_end_dt: "2021-08-18T20:00:00.000Z", week_num: 33, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12635155", week_start_dt: "2021-08-05T20:00:00.000Z", week_end_dt: "2021-08-11T20:00:00.000Z", week_num: 32, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12591137", week_start_dt: "2021-07-29T20:00:00.000Z", week_end_dt: "2021-08-04T20:00:00.000Z", week_num: 31, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12546008", week_start_dt: "2021-07-22T20:00:00.000Z", week_end_dt: "2021-07-28T20:00:00.000Z", week_num: 30, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12879046", week_start_dt: "2021-07-15T20:00:00.000Z", week_end_dt: "2021-07-21T20:00:00.000Z", week_num: 29, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12942136", week_start_dt: "2021-07-08T20:00:00.000Z", week_end_dt: "2021-07-14T20:00:00.000Z", week_num: 28, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13107574", week_start_dt: "2021-07-01T20:00:00.000Z", week_end_dt: "2021-07-07T20:00:00.000Z", week_num: 27, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12314467", week_start_dt: "2021-06-24T20:00:00.000Z", week_end_dt: "2021-06-30T20:00:00.000Z", week_num: 26, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12578050", week_start_dt: "2021-06-17T20:00:00.000Z", week_end_dt: "2021-06-23T20:00:00.000Z", week_num: 25, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12848751", week_start_dt: "2021-06-10T20:00:00.000Z", week_end_dt: "2021-06-16T20:00:00.000Z", week_num: 24, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13091745", week_start_dt: "2021-06-03T20:00:00.000Z", week_end_dt: "2021-06-09T20:00:00.000Z", week_num: 23, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13042743", week_start_dt: "2021-05-27T20:00:00.000Z", week_end_dt: "2021-06-02T20:00:00.000Z", week_num: 22, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13029471", week_start_dt: "2021-05-20T20:00:00.000Z", week_end_dt: "2021-05-26T20:00:00.000Z", week_num: 21, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13015363", week_start_dt: "2021-05-13T20:00:00.000Z", week_end_dt: "2021-05-19T20:00:00.000Z", week_num: 20, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12898120", week_start_dt: "2021-05-06T20:00:00.000Z", week_end_dt: "2021-05-12T20:00:00.000Z", week_num: 19, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12884599", week_start_dt: "2021-04-29T20:00:00.000Z", week_end_dt: "2021-05-05T20:00:00.000Z", week_num: 18, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12790788", week_start_dt: "2021-04-22T20:00:00.000Z", week_end_dt: "2021-04-28T20:00:00.000Z", week_num: 17, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12793609", week_start_dt: "2021-04-15T20:00:00.000Z", week_end_dt: "2021-04-21T20:00:00.000Z", week_num: 16, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12639790", week_start_dt: "2021-04-08T20:00:00.000Z", week_end_dt: "2021-04-14T20:00:00.000Z", week_num: 15, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12999101", week_start_dt: "2021-04-01T20:00:00.000Z", week_end_dt: "2021-04-07T20:00:00.000Z", week_num: 14, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12822141", week_start_dt: "2021-03-25T20:00:00.000Z", week_end_dt: "2021-03-31T20:00:00.000Z", week_num: 13, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12775551", week_start_dt: "2021-03-18T20:00:00.000Z", week_end_dt: "2021-03-24T20:00:00.000Z", week_num: 12, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12511310", week_start_dt: "2021-03-11T20:00:00.000Z", week_end_dt: "2021-03-17T20:00:00.000Z", week_num: 11, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12399825", week_start_dt: "2021-03-04T20:00:00.000Z", week_end_dt: "2021-03-10T20:00:00.000Z", week_num: 10, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12502174", week_start_dt: "2021-02-25T20:00:00.000Z", week_end_dt: "2021-03-03T20:00:00.000Z", week_num: 9, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12546062", week_start_dt: "2021-02-18T20:00:00.000Z", week_end_dt: "2021-02-24T20:00:00.000Z", week_num: 8, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11969922", week_start_dt: "2021-02-11T20:00:00.000Z", week_end_dt: "2021-02-17T20:00:00.000Z", week_num: 7, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12177699", week_start_dt: "2021-02-04T20:00:00.000Z", week_end_dt: "2021-02-10T20:00:00.000Z", week_num: 6, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12298909", week_start_dt: "2021-01-28T20:00:00.000Z", week_end_dt: "2021-02-03T20:00:00.000Z", week_num: 5, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11884939", week_start_dt: "2021-01-21T20:00:00.000Z", week_end_dt: "2021-01-27T20:00:00.000Z", week_num: 4, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11642614", week_start_dt: "2021-01-14T20:00:00.000Z", week_end_dt: "2021-01-20T20:00:00.000Z", week_num: 3, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11459020", week_start_dt: "2021-01-07T20:00:00.000Z", week_end_dt: "2021-01-13T20:00:00.000Z", week_num: 2, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11355094", week_start_dt: "2020-12-31T20:00:00.000Z", week_end_dt: "2021-01-06T20:00:00.000Z", week_num: 1, year_num: 2021, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12236521", week_start_dt: "2020-12-24T20:00:00.000Z", week_end_dt: "2020-12-30T20:00:00.000Z", week_num: 52, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11170701", week_start_dt: "2020-12-17T20:00:00.000Z", week_end_dt: "2020-12-23T20:00:00.000Z", week_num: 51, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "10731832", week_start_dt: "2020-12-10T20:00:00.000Z", week_end_dt: "2020-12-16T20:00:00.000Z", week_num: 50, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "10858021", week_start_dt: "2020-12-03T20:00:00.000Z", week_end_dt: "2020-12-09T20:00:00.000Z", week_num: 49, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "10659731", week_start_dt: "2020-11-26T20:00:00.000Z", week_end_dt: "2020-12-02T20:00:00.000Z", week_num: 48, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11551451", week_start_dt: "2020-11-19T20:00:00.000Z", week_end_dt: "2020-11-25T20:00:00.000Z", week_num: 47, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "10989716", week_start_dt: "2020-11-12T20:00:00.000Z", week_end_dt: "2020-11-18T20:00:00.000Z", week_num: 46, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "10911868", week_start_dt: "2020-11-05T20:00:00.000Z", week_end_dt: "2020-11-11T20:00:00.000Z", week_num: 45, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "10698974", week_start_dt: "2020-10-29T20:00:00.000Z", week_end_dt: "2020-11-04T20:00:00.000Z", week_num: 44, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "10797703", week_start_dt: "2020-10-22T20:00:00.000Z", week_end_dt: "2020-10-28T20:00:00.000Z", week_num: 43, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11133064", week_start_dt: "2020-10-15T20:00:00.000Z", week_end_dt: "2020-10-21T20:00:00.000Z", week_num: 42, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11418511", week_start_dt: "2020-10-08T20:00:00.000Z", week_end_dt: "2020-10-14T20:00:00.000Z", week_num: 41, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11294382", week_start_dt: "2020-10-01T20:00:00.000Z", week_end_dt: "2020-10-07T20:00:00.000Z", week_num: 40, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11115591", week_start_dt: "2020-09-24T20:00:00.000Z", week_end_dt: "2020-09-30T20:00:00.000Z", week_num: 39, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11302823", week_start_dt: "2020-09-17T20:00:00.000Z", week_end_dt: "2020-09-23T20:00:00.000Z", week_num: 38, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11215816", week_start_dt: "2020-09-10T20:00:00.000Z", week_end_dt: "2020-09-16T20:00:00.000Z", week_num: 37, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11765035", week_start_dt: "2020-09-03T20:00:00.000Z", week_end_dt: "2020-09-09T20:00:00.000Z", week_num: 36, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11439790", week_start_dt: "2020-08-27T20:00:00.000Z", week_end_dt: "2020-09-02T20:00:00.000Z", week_num: 35, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11421646", week_start_dt: "2020-08-20T20:00:00.000Z", week_end_dt: "2020-08-26T20:00:00.000Z", week_num: 34, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11598721", week_start_dt: "2020-08-13T20:00:00.000Z", week_end_dt: "2020-08-19T20:00:00.000Z", week_num: 33, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11840573", week_start_dt: "2020-08-06T20:00:00.000Z", week_end_dt: "2020-08-12T20:00:00.000Z", week_num: 32, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11790040", week_start_dt: "2020-07-30T20:00:00.000Z", week_end_dt: "2020-08-05T20:00:00.000Z", week_num: 31, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11832628", week_start_dt: "2020-07-23T20:00:00.000Z", week_end_dt: "2020-07-29T20:00:00.000Z", week_num: 30, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11925546", week_start_dt: "2020-07-16T20:00:00.000Z", week_end_dt: "2020-07-22T20:00:00.000Z", week_num: 29, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11777700", week_start_dt: "2020-07-09T20:00:00.000Z", week_end_dt: "2020-07-15T20:00:00.000Z", week_num: 28, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12174431", week_start_dt: "2020-07-02T20:00:00.000Z", week_end_dt: "2020-07-08T20:00:00.000Z", week_num: 27, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12179247", week_start_dt: "2020-06-25T20:00:00.000Z", week_end_dt: "2020-07-01T20:00:00.000Z", week_num: 26, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11728913", week_start_dt: "2020-06-18T20:00:00.000Z", week_end_dt: "2020-06-24T20:00:00.000Z", week_num: 25, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11848474", week_start_dt: "2020-06-11T20:00:00.000Z", week_end_dt: "2020-06-17T20:00:00.000Z", week_num: 24, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11833533", week_start_dt: "2020-06-04T20:00:00.000Z", week_end_dt: "2020-06-10T20:00:00.000Z", week_num: 23, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11770157", week_start_dt: "2020-05-28T20:00:00.000Z", week_end_dt: "2020-06-03T20:00:00.000Z", week_num: 22, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12153395", week_start_dt: "2020-05-21T20:00:00.000Z", week_end_dt: "2020-05-27T20:00:00.000Z", week_num: 21, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12022570", week_start_dt: "2020-05-14T20:00:00.000Z", week_end_dt: "2020-05-20T20:00:00.000Z", week_num: 20, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11698165", week_start_dt: "2020-05-07T20:00:00.000Z", week_end_dt: "2020-05-13T20:00:00.000Z", week_num: 19, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11818181", week_start_dt: "2020-04-30T20:00:00.000Z", week_end_dt: "2020-05-06T20:00:00.000Z", week_num: 18, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11449104", week_start_dt: "2020-04-23T20:00:00.000Z", week_end_dt: "2020-04-29T20:00:00.000Z", week_num: 17, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11548944", week_start_dt: "2020-04-16T20:00:00.000Z", week_end_dt: "2020-04-22T20:00:00.000Z", week_num: 16, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11423648", week_start_dt: "2020-04-09T20:00:00.000Z", week_end_dt: "2020-04-15T20:00:00.000Z", week_num: 15, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11507775", week_start_dt: "2020-04-02T20:00:00.000Z", week_end_dt: "2020-04-08T20:00:00.000Z", week_num: 14, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11190437", week_start_dt: "2020-03-26T20:00:00.000Z", week_end_dt: "2020-04-01T20:00:00.000Z", week_num: 13, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11268239", week_start_dt: "2020-03-19T20:00:00.000Z", week_end_dt: "2020-03-25T20:00:00.000Z", week_num: 12, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11145534", week_start_dt: "2020-03-12T20:00:00.000Z", week_end_dt: "2020-03-18T20:00:00.000Z", week_num: 11, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11845758", week_start_dt: "2020-03-05T20:00:00.000Z", week_end_dt: "2020-03-11T20:00:00.000Z", week_num: 10, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12239387", week_start_dt: "2020-02-27T20:00:00.000Z", week_end_dt: "2020-03-04T20:00:00.000Z", week_num: 9, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12074622", week_start_dt: "2020-02-20T20:00:00.000Z", week_end_dt: "2020-02-26T20:00:00.000Z", week_num: 8, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12293754", week_start_dt: "2020-02-13T20:00:00.000Z", week_end_dt: "2020-02-19T20:00:00.000Z", week_num: 7, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12045433", week_start_dt: "2020-02-06T20:00:00.000Z", week_end_dt: "2020-02-12T20:00:00.000Z", week_num: 6, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12025783", week_start_dt: "2020-01-30T20:00:00.000Z", week_end_dt: "2020-02-05T20:00:00.000Z", week_num: 5, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11959958", week_start_dt: "2020-01-23T20:00:00.000Z", week_end_dt: "2020-01-29T20:00:00.000Z", week_num: 4, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11971604", week_start_dt: "2020-01-16T20:00:00.000Z", week_end_dt: "2020-01-22T20:00:00.000Z", week_num: 3, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12541397", week_start_dt: "2020-01-09T20:00:00.000Z", week_end_dt: "2020-01-15T20:00:00.000Z", week_num: 2, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12326503", week_start_dt: "2020-01-02T20:00:00.000Z", week_end_dt: "2020-01-08T20:00:00.000Z", week_num: 1, year_num: 2020, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13012323", week_start_dt: "2019-12-26T20:00:00.000Z", week_end_dt: "2020-01-01T20:00:00.000Z", week_num: 52, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12403502", week_start_dt: "2019-12-19T20:00:00.000Z", week_end_dt: "2019-12-25T20:00:00.000Z", week_num: 51, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12113650", week_start_dt: "2019-12-12T20:00:00.000Z", week_end_dt: "2019-12-18T20:00:00.000Z", week_num: 50, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12807824", week_start_dt: "2019-12-05T20:00:00.000Z", week_end_dt: "2019-12-11T20:00:00.000Z", week_num: 49, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11992339", week_start_dt: "2019-11-28T20:00:00.000Z", week_end_dt: "2019-12-04T20:00:00.000Z", week_num: 48, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12656291", week_start_dt: "2019-11-21T20:00:00.000Z", week_end_dt: "2019-11-27T20:00:00.000Z", week_num: 47, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12671449", week_start_dt: "2019-11-14T20:00:00.000Z", week_end_dt: "2019-11-20T20:00:00.000Z", week_num: 46, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12737515", week_start_dt: "2019-11-07T20:00:00.000Z", week_end_dt: "2019-11-13T20:00:00.000Z", week_num: 45, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12976311", week_start_dt: "2019-10-31T20:00:00.000Z", week_end_dt: "2019-11-06T20:00:00.000Z", week_num: 44, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13360908", week_start_dt: "2019-10-24T20:00:00.000Z", week_end_dt: "2019-10-30T20:00:00.000Z", week_num: 43, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13594747", week_start_dt: "2019-10-17T20:00:00.000Z", week_end_dt: "2019-10-23T20:00:00.000Z", week_num: 42, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13384170", week_start_dt: "2019-10-10T20:00:00.000Z", week_end_dt: "2019-10-16T20:00:00.000Z", week_num: 41, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "7753762", week_start_dt: "2019-10-03T20:00:00.000Z", week_end_dt: "2019-10-09T20:00:00.000Z", week_num: 40, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13003647", week_start_dt: "2019-09-26T20:00:00.000Z", week_end_dt: "2019-10-02T20:00:00.000Z", week_num: 39, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12612387", week_start_dt: "2019-09-19T20:00:00.000Z", week_end_dt: "2019-09-25T20:00:00.000Z", week_num: 38, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13584169", week_start_dt: "2019-09-12T20:00:00.000Z", week_end_dt: "2019-09-18T20:00:00.000Z", week_num: 37, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13577269", week_start_dt: "2019-09-05T20:00:00.000Z", week_end_dt: "2019-09-11T20:00:00.000Z", week_num: 36, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14207637", week_start_dt: "2019-08-29T20:00:00.000Z", week_end_dt: "2019-09-04T20:00:00.000Z", week_num: 35, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14014371", week_start_dt: "2019-08-22T20:00:00.000Z", week_end_dt: "2019-08-28T20:00:00.000Z", week_num: 34, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14298313", week_start_dt: "2019-08-15T20:00:00.000Z", week_end_dt: "2019-08-21T20:00:00.000Z", week_num: 33, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14467188", week_start_dt: "2019-08-08T20:00:00.000Z", week_end_dt: "2019-08-14T20:00:00.000Z", week_num: 32, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14648942", week_start_dt: "2019-08-01T20:00:00.000Z", week_end_dt: "2019-08-07T20:00:00.000Z", week_num: 31, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14781811", week_start_dt: "2019-07-25T20:00:00.000Z", week_end_dt: "2019-07-31T20:00:00.000Z", week_num: 30, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14865834", week_start_dt: "2019-07-18T20:00:00.000Z", week_end_dt: "2019-07-24T20:00:00.000Z", week_num: 29, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14946976", week_start_dt: "2019-07-11T20:00:00.000Z", week_end_dt: "2019-07-17T20:00:00.000Z", week_num: 28, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14445552", week_start_dt: "2019-07-04T20:00:00.000Z", week_end_dt: "2019-07-10T20:00:00.000Z", week_num: 27, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14473380", week_start_dt: "2019-06-27T20:00:00.000Z", week_end_dt: "2019-07-03T20:00:00.000Z", week_num: 26, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14824296", week_start_dt: "2019-06-20T20:00:00.000Z", week_end_dt: "2019-06-26T20:00:00.000Z", week_num: 25, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14817112", week_start_dt: "2019-06-13T20:00:00.000Z", week_end_dt: "2019-06-19T20:00:00.000Z", week_num: 24, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "15107369", week_start_dt: "2019-06-06T20:00:00.000Z", week_end_dt: "2019-06-12T20:00:00.000Z", week_num: 23, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "15345933", week_start_dt: "2019-05-30T20:00:00.000Z", week_end_dt: "2019-06-05T20:00:00.000Z", week_num: 22, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "15782947", week_start_dt: "2019-05-23T20:00:00.000Z", week_end_dt: "2019-05-29T20:00:00.000Z", week_num: 21, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "15611397", week_start_dt: "2019-05-16T20:00:00.000Z", week_end_dt: "2019-05-22T20:00:00.000Z", week_num: 20, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "15906652", week_start_dt: "2019-05-09T20:00:00.000Z", week_end_dt: "2019-05-15T20:00:00.000Z", week_num: 19, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "16182292", week_start_dt: "2019-05-02T20:00:00.000Z", week_end_dt: "2019-05-08T20:00:00.000Z", week_num: 18, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "16689012", week_start_dt: "2019-04-25T20:00:00.000Z", week_end_dt: "2019-05-01T20:00:00.000Z", week_num: 17, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "17790186", week_start_dt: "2019-04-18T20:00:00.000Z", week_end_dt: "2019-04-24T20:00:00.000Z", week_num: 16, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "18335007", week_start_dt: "2019-04-11T20:00:00.000Z", week_end_dt: "2019-04-17T20:00:00.000Z", week_num: 15, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "19174947", week_start_dt: "2019-04-04T20:00:00.000Z", week_end_dt: "2019-04-10T20:00:00.000Z", week_num: 14, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "20216314", week_start_dt: "2019-03-28T20:00:00.000Z", week_end_dt: "2019-04-03T20:00:00.000Z", week_num: 13, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5400660", week_start_dt: "2019-03-21T20:00:00.000Z", week_end_dt: "2019-03-27T20:00:00.000Z", week_num: 12, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5580436", week_start_dt: "2019-03-14T20:00:00.000Z", week_end_dt: "2019-03-20T20:00:00.000Z", week_num: 11, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5918917", week_start_dt: "2019-03-07T20:00:00.000Z", week_end_dt: "2019-03-13T20:00:00.000Z", week_num: 10, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "6239177", week_start_dt: "2019-02-28T20:00:00.000Z", week_end_dt: "2019-03-06T20:00:00.000Z", week_num: 9, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "6367588", week_start_dt: "2019-02-21T20:00:00.000Z", week_end_dt: "2019-02-27T20:00:00.000Z", week_num: 8, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5554439", week_start_dt: "2019-02-14T20:00:00.000Z", week_end_dt: "2019-02-20T20:00:00.000Z", week_num: 7, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "4599606", week_start_dt: "2019-02-07T20:00:00.000Z", week_end_dt: "2019-02-13T20:00:00.000Z", week_num: 6, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "4665358", week_start_dt: "2019-01-31T20:00:00.000Z", week_end_dt: "2019-02-06T20:00:00.000Z", week_num: 5, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "4635362", week_start_dt: "2019-01-24T20:00:00.000Z", week_end_dt: "2019-01-30T20:00:00.000Z", week_num: 4, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "4409609", week_start_dt: "2019-01-17T20:00:00.000Z", week_end_dt: "2019-01-23T20:00:00.000Z", week_num: 3, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5084003", week_start_dt: "2019-01-10T20:00:00.000Z", week_end_dt: "2019-01-16T20:00:00.000Z", week_num: 2, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5252413", week_start_dt: "2019-01-03T20:00:00.000Z", week_end_dt: "2019-01-09T20:00:00.000Z", week_num: 1, year_num: 2019, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "4837369", week_start_dt: "2018-12-27T20:00:00.000Z", week_end_dt: "2019-01-02T20:00:00.000Z", week_num: 52, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5119562", week_start_dt: "2018-12-20T20:00:00.000Z", week_end_dt: "2018-12-26T20:00:00.000Z", week_num: 51, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5195184", week_start_dt: "2018-12-13T20:00:00.000Z", week_end_dt: "2018-12-19T20:00:00.000Z", week_num: 50, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5085995", week_start_dt: "2018-12-06T20:00:00.000Z", week_end_dt: "2018-12-12T20:00:00.000Z", week_num: 49, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5506210", week_start_dt: "2018-11-29T20:00:00.000Z", week_end_dt: "2018-12-05T20:00:00.000Z", week_num: 48, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "5921493", week_start_dt: "2018-11-22T20:00:00.000Z", week_end_dt: "2018-11-28T20:00:00.000Z", week_num: 47, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "6987364", week_start_dt: "2018-11-15T20:00:00.000Z", week_end_dt: "2018-11-21T20:00:00.000Z", week_num: 46, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "7291624", week_start_dt: "2018-11-08T20:00:00.000Z", week_end_dt: "2018-11-14T20:00:00.000Z", week_num: 45, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "7046717", week_start_dt: "2018-11-01T20:00:00.000Z", week_end_dt: "2018-11-07T20:00:00.000Z", week_num: 44, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "3404458", week_start_dt: "2018-10-25T20:00:00.000Z", week_end_dt: "2018-10-31T20:00:00.000Z", week_num: 43, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "3089406", week_start_dt: "2018-10-18T20:00:00.000Z", week_end_dt: "2018-10-24T20:00:00.000Z", week_num: 42, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2616873", week_start_dt: "2018-10-11T20:00:00.000Z", week_end_dt: "2018-10-17T20:00:00.000Z", week_num: 41, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2412096", week_start_dt: "2018-10-04T20:00:00.000Z", week_end_dt: "2018-10-10T20:00:00.000Z", week_num: 40, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2205420", week_start_dt: "2018-09-27T20:00:00.000Z", week_end_dt: "2018-10-03T20:00:00.000Z", week_num: 39, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2296700", week_start_dt: "2018-09-20T20:00:00.000Z", week_end_dt: "2018-09-26T20:00:00.000Z", week_num: 38, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2355549", week_start_dt: "2018-09-13T20:00:00.000Z", week_end_dt: "2018-09-19T20:00:00.000Z", week_num: 37, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2310749", week_start_dt: "2018-09-06T20:00:00.000Z", week_end_dt: "2018-09-12T20:00:00.000Z", week_num: 36, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2404047", week_start_dt: "2018-08-30T20:00:00.000Z", week_end_dt: "2018-09-05T20:00:00.000Z", week_num: 35, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2364074", week_start_dt: "2018-08-23T20:00:00.000Z", week_end_dt: "2018-08-29T20:00:00.000Z", week_num: 34, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2165100", week_start_dt: "2018-08-16T20:00:00.000Z", week_end_dt: "2018-08-22T20:00:00.000Z", week_num: 33, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2246902", week_start_dt: "2018-08-09T20:00:00.000Z", week_end_dt: "2018-08-15T20:00:00.000Z", week_num: 32, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2339844", week_start_dt: "2018-08-02T20:00:00.000Z", week_end_dt: "2018-08-08T20:00:00.000Z", week_num: 31, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2405979", week_start_dt: "2018-07-26T20:00:00.000Z", week_end_dt: "2018-08-01T20:00:00.000Z", week_num: 30, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2377450", week_start_dt: "2018-07-19T20:00:00.000Z", week_end_dt: "2018-07-25T20:00:00.000Z", week_num: 29, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2315589", week_start_dt: "2018-07-12T20:00:00.000Z", week_end_dt: "2018-07-18T20:00:00.000Z", week_num: 28, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2119660", week_start_dt: "2018-07-05T20:00:00.000Z", week_end_dt: "2018-07-11T20:00:00.000Z", week_num: 27, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2278585", week_start_dt: "2018-06-28T20:00:00.000Z", week_end_dt: "2018-07-04T20:00:00.000Z", week_num: 26, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2216917", week_start_dt: "2018-06-21T20:00:00.000Z", week_end_dt: "2018-06-27T20:00:00.000Z", week_num: 25, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2212212", week_start_dt: "2018-06-14T20:00:00.000Z", week_end_dt: "2018-06-20T20:00:00.000Z", week_num: 24, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2245229", week_start_dt: "2018-06-07T20:00:00.000Z", week_end_dt: "2018-06-13T20:00:00.000Z", week_num: 23, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2310324", week_start_dt: "2018-05-31T20:00:00.000Z", week_end_dt: "2018-06-06T20:00:00.000Z", week_num: 22, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2416262", week_start_dt: "2018-05-24T20:00:00.000Z", week_end_dt: "2018-05-30T20:00:00.000Z", week_num: 21, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2387707", week_start_dt: "2018-05-17T20:00:00.000Z", week_end_dt: "2018-05-23T20:00:00.000Z", week_num: 20, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "2102566", week_start_dt: "2018-05-10T20:00:00.000Z", week_end_dt: "2018-05-16T20:00:00.000Z", week_num: 19, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1882377", week_start_dt: "2018-05-03T20:00:00.000Z", week_end_dt: "2018-05-09T20:00:00.000Z", week_num: 18, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1833598", week_start_dt: "2018-04-26T20:00:00.000Z", week_end_dt: "2018-05-02T20:00:00.000Z", week_num: 17, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1829368", week_start_dt: "2018-04-19T20:00:00.000Z", week_end_dt: "2018-04-25T20:00:00.000Z", week_num: 16, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1588970", week_start_dt: "2018-04-12T20:00:00.000Z", week_end_dt: "2018-04-18T20:00:00.000Z", week_num: 15, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1534360", week_start_dt: "2018-04-05T20:00:00.000Z", week_end_dt: "2018-04-11T20:00:00.000Z", week_num: 14, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1568757", week_start_dt: "2018-03-29T20:00:00.000Z", week_end_dt: "2018-04-04T20:00:00.000Z", week_num: 13, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1569864", week_start_dt: "2018-03-22T20:00:00.000Z", week_end_dt: "2018-03-28T20:00:00.000Z", week_num: 12, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1505997", week_start_dt: "2018-03-15T20:00:00.000Z", week_end_dt: "2018-03-21T20:00:00.000Z", week_num: 11, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1539169", week_start_dt: "2018-03-08T20:00:00.000Z", week_end_dt: "2018-03-14T20:00:00.000Z", week_num: 10, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1540195", week_start_dt: "2018-03-01T20:00:00.000Z", week_end_dt: "2018-03-07T20:00:00.000Z", week_num: 9, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1539766", week_start_dt: "2018-02-22T20:00:00.000Z", week_end_dt: "2018-02-28T20:00:00.000Z", week_num: 8, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1539194", week_start_dt: "2018-02-15T20:00:00.000Z", week_end_dt: "2018-02-21T20:00:00.000Z", week_num: 7, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1508425", week_start_dt: "2018-02-08T20:00:00.000Z", week_end_dt: "2018-02-14T20:00:00.000Z", week_num: 6, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1483424", week_start_dt: "2018-02-01T20:00:00.000Z", week_end_dt: "2018-02-07T20:00:00.000Z", week_num: 5, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1487365", week_start_dt: "2018-01-25T20:00:00.000Z", week_end_dt: "2018-01-31T20:00:00.000Z", week_num: 4, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1452823", week_start_dt: "2018-01-18T20:00:00.000Z", week_end_dt: "2018-01-24T20:00:00.000Z", week_num: 3, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1473379", week_start_dt: "2018-01-11T20:00:00.000Z", week_end_dt: "2018-01-17T20:00:00.000Z", week_num: 2, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1652653", week_start_dt: "2018-01-04T20:00:00.000Z", week_end_dt: "2018-01-10T20:00:00.000Z", week_num: 1, year_num: 2018, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1538598", week_start_dt: "2017-12-28T20:00:00.000Z", week_end_dt: "2018-01-03T20:00:00.000Z", week_num: 52, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1344630", week_start_dt: "2017-12-21T20:00:00.000Z", week_end_dt: "2017-12-27T20:00:00.000Z", week_num: 51, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1354134", week_start_dt: "2017-12-14T20:00:00.000Z", week_end_dt: "2017-12-20T20:00:00.000Z", week_num: 50, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1367651", week_start_dt: "2017-12-07T20:00:00.000Z", week_end_dt: "2017-12-13T20:00:00.000Z", week_num: 49, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1348892", week_start_dt: "2017-11-30T20:00:00.000Z", week_end_dt: "2017-12-06T20:00:00.000Z", week_num: 48, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1329019", week_start_dt: "2017-11-23T20:00:00.000Z", week_end_dt: "2017-11-29T20:00:00.000Z", week_num: 47, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1478550", week_start_dt: "2017-11-16T20:00:00.000Z", week_end_dt: "2017-11-22T20:00:00.000Z", week_num: 46, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1406650", week_start_dt: "2017-11-09T20:00:00.000Z", week_end_dt: "2017-11-15T20:00:00.000Z", week_num: 45, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1421878", week_start_dt: "2017-11-02T20:00:00.000Z", week_end_dt: "2017-11-08T20:00:00.000Z", week_num: 44, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1374701", week_start_dt: "2017-10-26T20:00:00.000Z", week_end_dt: "2017-11-01T20:00:00.000Z", week_num: 43, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1411849", week_start_dt: "2017-10-19T20:00:00.000Z", week_end_dt: "2017-10-25T20:00:00.000Z", week_num: 42, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1434213", week_start_dt: "2017-10-12T20:00:00.000Z", week_end_dt: "2017-10-18T20:00:00.000Z", week_num: 41, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1401242", week_start_dt: "2017-10-05T20:00:00.000Z", week_end_dt: "2017-10-11T20:00:00.000Z", week_num: 40, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1432197", week_start_dt: "2017-09-28T20:00:00.000Z", week_end_dt: "2017-10-04T20:00:00.000Z", week_num: 39, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1405252", week_start_dt: "2017-09-21T20:00:00.000Z", week_end_dt: "2017-09-27T20:00:00.000Z", week_num: 38, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1408794", week_start_dt: "2017-09-14T20:00:00.000Z", week_end_dt: "2017-09-20T20:00:00.000Z", week_num: 37, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1373115", week_start_dt: "2017-09-07T20:00:00.000Z", week_end_dt: "2017-09-13T20:00:00.000Z", week_num: 36, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1477107", week_start_dt: "2017-08-31T20:00:00.000Z", week_end_dt: "2017-09-06T20:00:00.000Z", week_num: 35, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1401071", week_start_dt: "2017-08-24T20:00:00.000Z", week_end_dt: "2017-08-30T20:00:00.000Z", week_num: 34, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1455706", week_start_dt: "2017-08-17T20:00:00.000Z", week_end_dt: "2017-08-23T20:00:00.000Z", week_num: 33, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1488855", week_start_dt: "2017-08-10T20:00:00.000Z", week_end_dt: "2017-08-16T20:00:00.000Z", week_num: 32, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1527621", week_start_dt: "2017-08-03T20:00:00.000Z", week_end_dt: "2017-08-09T20:00:00.000Z", week_num: 31, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1513567", week_start_dt: "2017-07-27T20:00:00.000Z", week_end_dt: "2017-08-02T20:00:00.000Z", week_num: 30, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1462704", week_start_dt: "2017-07-20T20:00:00.000Z", week_end_dt: "2017-07-26T20:00:00.000Z", week_num: 29, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1372689", week_start_dt: "2017-07-13T20:00:00.000Z", week_end_dt: "2017-07-19T20:00:00.000Z", week_num: 28, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1370468", week_start_dt: "2017-07-06T20:00:00.000Z", week_end_dt: "2017-07-12T20:00:00.000Z", week_num: 27, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1453949", week_start_dt: "2017-06-29T20:00:00.000Z", week_end_dt: "2017-07-05T20:00:00.000Z", week_num: 26, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1364745", week_start_dt: "2017-06-22T20:00:00.000Z", week_end_dt: "2017-06-28T20:00:00.000Z", week_num: 25, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1355253", week_start_dt: "2017-06-15T20:00:00.000Z", week_end_dt: "2017-06-21T20:00:00.000Z", week_num: 24, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1329335", week_start_dt: "2017-06-08T20:00:00.000Z", week_end_dt: "2017-06-14T20:00:00.000Z", week_num: 23, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1343501", week_start_dt: "2017-06-01T20:00:00.000Z", week_end_dt: "2017-06-07T20:00:00.000Z", week_num: 22, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1410908", week_start_dt: "2017-05-25T20:00:00.000Z", week_end_dt: "2017-05-31T20:00:00.000Z", week_num: 21, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1347060", week_start_dt: "2017-05-18T20:00:00.000Z", week_end_dt: "2017-05-24T20:00:00.000Z", week_num: 20, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1372253", week_start_dt: "2017-05-11T20:00:00.000Z", week_end_dt: "2017-05-17T20:00:00.000Z", week_num: 19, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1345670", week_start_dt: "2017-05-04T20:00:00.000Z", week_end_dt: "2017-05-10T20:00:00.000Z", week_num: 18, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1339796", week_start_dt: "2017-04-27T20:00:00.000Z", week_end_dt: "2017-05-03T20:00:00.000Z", week_num: 17, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1315406", week_start_dt: "2017-04-20T20:00:00.000Z", week_end_dt: "2017-04-26T20:00:00.000Z", week_num: 16, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1319080", week_start_dt: "2017-04-13T20:00:00.000Z", week_end_dt: "2017-04-19T20:00:00.000Z", week_num: 15, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1350133", week_start_dt: "2017-04-06T20:00:00.000Z", week_end_dt: "2017-04-12T20:00:00.000Z", week_num: 14, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1303950", week_start_dt: "2017-03-30T20:00:00.000Z", week_end_dt: "2017-04-05T20:00:00.000Z", week_num: 13, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1270545", week_start_dt: "2017-03-23T20:00:00.000Z", week_end_dt: "2017-03-29T20:00:00.000Z", week_num: 12, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1256750", week_start_dt: "2017-03-16T20:00:00.000Z", week_end_dt: "2017-03-22T20:00:00.000Z", week_num: 11, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1275949", week_start_dt: "2017-03-09T20:00:00.000Z", week_end_dt: "2017-03-15T20:00:00.000Z", week_num: 10, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1253596", week_start_dt: "2017-03-02T20:00:00.000Z", week_end_dt: "2017-03-08T20:00:00.000Z", week_num: 9, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1254948", week_start_dt: "2017-02-23T20:00:00.000Z", week_end_dt: "2017-03-01T20:00:00.000Z", week_num: 8, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1287769", week_start_dt: "2017-02-16T20:00:00.000Z", week_end_dt: "2017-02-22T20:00:00.000Z", week_num: 7, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1304844", week_start_dt: "2017-02-09T20:00:00.000Z", week_end_dt: "2017-02-15T20:00:00.000Z", week_num: 6, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1308314", week_start_dt: "2017-02-02T20:00:00.000Z", week_end_dt: "2017-02-08T20:00:00.000Z", week_num: 5, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1249059", week_start_dt: "2017-01-26T20:00:00.000Z", week_end_dt: "2017-02-01T20:00:00.000Z", week_num: 4, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1221325", week_start_dt: "2017-01-19T20:00:00.000Z", week_end_dt: "2017-01-25T20:00:00.000Z", week_num: 3, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1222398", week_start_dt: "2017-01-12T20:00:00.000Z", week_end_dt: "2017-01-18T20:00:00.000Z", week_num: 2, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1134337", week_start_dt: "2017-01-05T20:00:00.000Z", week_end_dt: "2017-01-11T20:00:00.000Z", week_num: 1, year_num: 2017, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "535949", week_start_dt: "2015-12-31T20:00:00.000Z", week_end_dt: "2016-01-06T20:00:00.000Z", week_num: 53, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1330411", week_start_dt: "2016-12-29T20:00:00.000Z", week_end_dt: "2017-01-04T20:00:00.000Z", week_num: 52, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1014623", week_start_dt: "2016-12-22T20:00:00.000Z", week_end_dt: "2016-12-28T20:00:00.000Z", week_num: 51, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "975059", week_start_dt: "2016-12-15T20:00:00.000Z", week_end_dt: "2016-12-21T20:00:00.000Z", week_num: 50, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "979419", week_start_dt: "2016-12-08T20:00:00.000Z", week_end_dt: "2016-12-14T20:00:00.000Z", week_num: 49, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "965780", week_start_dt: "2016-12-01T20:00:00.000Z", week_end_dt: "2016-12-07T20:00:00.000Z", week_num: 48, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "957459", week_start_dt: "2016-11-24T20:00:00.000Z", week_end_dt: "2016-11-30T20:00:00.000Z", week_num: 47, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1073807", week_start_dt: "2016-11-17T20:00:00.000Z", week_end_dt: "2016-11-23T20:00:00.000Z", week_num: 46, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1023682", week_start_dt: "2016-11-10T20:00:00.000Z", week_end_dt: "2016-11-16T20:00:00.000Z", week_num: 45, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "971169", week_start_dt: "2016-11-03T20:00:00.000Z", week_end_dt: "2016-11-09T20:00:00.000Z", week_num: 44, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "980081", week_start_dt: "2016-10-27T20:00:00.000Z", week_end_dt: "2016-11-02T20:00:00.000Z", week_num: 43, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1016433", week_start_dt: "2016-10-20T20:00:00.000Z", week_end_dt: "2016-10-26T20:00:00.000Z", week_num: 42, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1040172", week_start_dt: "2016-10-13T20:00:00.000Z", week_end_dt: "2016-10-19T20:00:00.000Z", week_num: 41, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1018637", week_start_dt: "2016-10-06T20:00:00.000Z", week_end_dt: "2016-10-12T20:00:00.000Z", week_num: 40, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1017396", week_start_dt: "2016-09-29T20:00:00.000Z", week_end_dt: "2016-10-05T20:00:00.000Z", week_num: 39, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1045120", week_start_dt: "2016-09-22T20:00:00.000Z", week_end_dt: "2016-09-28T20:00:00.000Z", week_num: 38, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1127675", week_start_dt: "2016-09-15T20:00:00.000Z", week_end_dt: "2016-09-21T20:00:00.000Z", week_num: 37, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1197849", week_start_dt: "2016-09-08T20:00:00.000Z", week_end_dt: "2016-09-14T20:00:00.000Z", week_num: 36, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1256015", week_start_dt: "2016-09-01T20:00:00.000Z", week_end_dt: "2016-09-07T20:00:00.000Z", week_num: 35, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1251590", week_start_dt: "2016-08-25T20:00:00.000Z", week_end_dt: "2016-08-31T20:00:00.000Z", week_num: 34, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1333021", week_start_dt: "2016-08-18T20:00:00.000Z", week_end_dt: "2016-08-24T20:00:00.000Z", week_num: 33, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1241653", week_start_dt: "2016-08-11T20:00:00.000Z", week_end_dt: "2016-08-17T20:00:00.000Z", week_num: 32, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1298261", week_start_dt: "2016-08-04T20:00:00.000Z", week_end_dt: "2016-08-10T20:00:00.000Z", week_num: 31, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1159112", week_start_dt: "2016-07-28T20:00:00.000Z", week_end_dt: "2016-08-03T20:00:00.000Z", week_num: 30, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1126396", week_start_dt: "2016-07-21T20:00:00.000Z", week_end_dt: "2016-07-27T20:00:00.000Z", week_num: 29, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1061782", week_start_dt: "2016-07-14T20:00:00.000Z", week_end_dt: "2016-07-20T20:00:00.000Z", week_num: 28, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1006593", week_start_dt: "2016-07-07T20:00:00.000Z", week_end_dt: "2016-07-13T20:00:00.000Z", week_num: 27, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1051791", week_start_dt: "2016-06-30T20:00:00.000Z", week_end_dt: "2016-07-06T20:00:00.000Z", week_num: 26, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1029543", week_start_dt: "2016-06-23T20:00:00.000Z", week_end_dt: "2016-06-29T20:00:00.000Z", week_num: 25, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1015549", week_start_dt: "2016-06-16T20:00:00.000Z", week_end_dt: "2016-06-22T20:00:00.000Z", week_num: 24, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1015212", week_start_dt: "2016-06-09T20:00:00.000Z", week_end_dt: "2016-06-15T20:00:00.000Z", week_num: 23, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1035239", week_start_dt: "2016-06-02T20:00:00.000Z", week_end_dt: "2016-06-08T20:00:00.000Z", week_num: 22, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1039288", week_start_dt: "2016-05-26T20:00:00.000Z", week_end_dt: "2016-06-01T20:00:00.000Z", week_num: 21, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1019483", week_start_dt: "2016-05-19T20:00:00.000Z", week_end_dt: "2016-05-25T20:00:00.000Z", week_num: 20, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1008032", week_start_dt: "2016-05-12T20:00:00.000Z", week_end_dt: "2016-05-18T20:00:00.000Z", week_num: 19, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1026809", week_start_dt: "2016-05-05T20:00:00.000Z", week_end_dt: "2016-05-11T20:00:00.000Z", week_num: 18, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1014668", week_start_dt: "2016-04-28T20:00:00.000Z", week_end_dt: "2016-05-04T20:00:00.000Z", week_num: 17, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1041707", week_start_dt: "2016-04-21T20:00:00.000Z", week_end_dt: "2016-04-27T20:00:00.000Z", week_num: 16, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "1020765", week_start_dt: "2016-04-14T20:00:00.000Z", week_end_dt: "2016-04-20T20:00:00.000Z", week_num: 15, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "989703", week_start_dt: "2016-04-07T20:00:00.000Z", week_end_dt: "2016-04-13T20:00:00.000Z", week_num: 14, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "934789", week_start_dt: "2016-03-31T20:00:00.000Z", week_end_dt: "2016-04-06T20:00:00.000Z", week_num: 13, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "921589", week_start_dt: "2016-03-24T20:00:00.000Z", week_end_dt: "2016-03-30T20:00:00.000Z", week_num: 12, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "867346", week_start_dt: "2016-03-17T20:00:00.000Z", week_end_dt: "2016-03-23T20:00:00.000Z", week_num: 11, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "873769", week_start_dt: "2016-03-10T20:00:00.000Z", week_end_dt: "2016-03-16T20:00:00.000Z", week_num: 10, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "868061", week_start_dt: "2016-03-03T20:00:00.000Z", week_end_dt: "2016-03-09T20:00:00.000Z", week_num: 9, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "874664", week_start_dt: "2016-02-25T20:00:00.000Z", week_end_dt: "2016-03-02T20:00:00.000Z", week_num: 8, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "875329", week_start_dt: "2016-02-18T20:00:00.000Z", week_end_dt: "2016-02-24T20:00:00.000Z", week_num: 7, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "829848", week_start_dt: "2016-02-11T20:00:00.000Z", week_end_dt: "2016-02-17T20:00:00.000Z", week_num: 6, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "812058", week_start_dt: "2016-02-04T20:00:00.000Z", week_end_dt: "2016-02-10T20:00:00.000Z", week_num: 5, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "803729", week_start_dt: "2016-01-28T20:00:00.000Z", week_end_dt: "2016-02-03T20:00:00.000Z", week_num: 4, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "830143", week_start_dt: "2016-01-21T20:00:00.000Z", week_end_dt: "2016-01-27T20:00:00.000Z", week_num: 3, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "716381", week_start_dt: "2016-01-14T20:00:00.000Z", week_end_dt: "2016-01-20T20:00:00.000Z", week_num: 2, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "644398", week_start_dt: "2016-01-07T20:00:00.000Z", week_end_dt: "2016-01-13T20:00:00.000Z", week_num: 1, year_num: 2016, release_dt: "1974-12-30T20:00:00.000Z" }] } bigLabelsCreate() { this.bigLabels = [{ week: 1, year: 2016 }, { week: 2, year: 2016 }, { week: 3, year: 2016 }, { week: 4, year: 2016 }, { week: 5, year: 2016 }, { week: 6, year: 2016 }, { week: 7, year: 2016 }, { week: 8, year: 2016 }, { week: 9, year: 2016 }, { week: 10, year: 2016 }, { week: 11, year: 2016 }, { week: 12, year: 2016 }, { week: 13, year: 2016 }, { week: 14, year: 2016 }, { week: 15, year: 2016 }, { week: 16, year: 2016 }, { week: 17, year: 2016 }, { week: 18, year: 2016 }, { week: 19, year: 2016 }, { week: 20, year: 2016 }, { week: 21, year: 2016 }, { week: 22, year: 2016 }, { week: 23, year: 2016 }, { week: 24, year: 2016 }, { week: 25, year: 2016 }, { week: 26, year: 2016 }, { week: 27, year: 2016 }, { week: 28, year: 2016 }, { week: 29, year: 2016 }, { week: 30, year: 2016 }, { week: 31, year: 2016 }, { week: 32, year: 2016 }, { week: 33, year: 2016 }, { week: 34, year: 2016 }, { week: 35, year: 2016 }, { week: 36, year: 2016 }, { week: 37, year: 2016 }, { week: 38, year: 2016 }, { week: 39, year: 2016 }, { week: 40, year: 2016 }, { week: 41, year: 2016 }, { week: 42, year: 2016 }, { week: 43, year: 2016 }, { week: 44, year: 2016 }, { week: 45, year: 2016 }, { week: 46, year: 2016 }, { week: 47, year: 2016 }, { week: 48, year: 2016 }, { week: 49, year: 2016 }, { week: 50, year: 2016 }, { week: 51, year: 2016 }, { week: 52, year: 2016 }, { week: 53, year: 2016 }, { week: 1, year: 2017 }, { week: 2, year: 2017 }, { week: 3, year: 2017 }, { week: 4, year: 2017 }, { week: 5, year: 2017 }, { week: 6, year: 2017 }, { week: 7, year: 2017 }, { week: 8, year: 2017 }, { week: 9, year: 2017 }, { week: 10, year: 2017 }, { week: 11, year: 2017 }, { week: 12, year: 2017 }, { week: 13, year: 2017 }, { week: 14, year: 2017 }, { week: 15, year: 2017 }, { week: 16, year: 2017 }, { week: 17, year: 2017 }, { week: 18, year: 2017 }, { week: 19, year: 2017 }, { week: 20, year: 2017 }, { week: 21, year: 2017 }, { week: 22, year: 2017 }, { week: 23, year: 2017 }, { week: 24, year: 2017 }, { week: 25, year: 2017 }, { week: 26, year: 2017 }, { week: 27, year: 2017 }, { week: 28, year: 2017 }, { week: 29, year: 2017 }, { week: 30, year: 2017 }, { week: 31, year: 2017 }, { week: 32, year: 2017 }, { week: 33, year: 2017 }, { week: 34, year: 2017 }, { week: 35, year: 2017 }, { week: 36, year: 2017 }, { week: 37, year: 2017 }, { week: 38, year: 2017 }, { week: 39, year: 2017 }, { week: 40, year: 2017 }, { week: 41, year: 2017 }, { week: 42, year: 2017 }, { week: 43, year: 2017 }, { week: 44, year: 2017 }, { week: 45, year: 2017 }, { week: 46, year: 2017 }, { week: 47, year: 2017 }, { week: 48, year: 2017 }, { week: 49, year: 2017 }, { week: 50, year: 2017 }, { week: 51, year: 2017 }, { week: 52, year: 2017 }, { week: 1, year: 2018 }, { week: 2, year: 2018 }, { week: 3, year: 2018 }, { week: 4, year: 2018 }, { week: 5, year: 2018 }, { week: 6, year: 2018 }, { week: 7, year: 2018 }, { week: 8, year: 2018 }, { week: 9, year: 2018 }, { week: 10, year: 2018 }, { week: 11, year: 2018 }, { week: 12, year: 2018 }, { week: 13, year: 2018 }, { week: 14, year: 2018 }, { week: 15, year: 2018 }, { week: 16, year: 2018 }, { week: 17, year: 2018 }, { week: 18, year: 2018 }, { week: 19, year: 2018 }, { week: 20, year: 2018 }, { week: 21, year: 2018 }, { week: 22, year: 2018 }, { week: 23, year: 2018 }, { week: 24, year: 2018 }, { week: 25, year: 2018 }, { week: 26, year: 2018 }, { week: 27, year: 2018 }, { week: 28, year: 2018 }, { week: 29, year: 2018 }, { week: 30, year: 2018 }, { week: 31, year: 2018 }, { week: 32, year: 2018 }, { week: 33, year: 2018 }, { week: 34, year: 2018 }, { week: 35, year: 2018 }, { week: 36, year: 2018 }, { week: 37, year: 2018 }, { week: 38, year: 2018 }, { week: 39, year: 2018 }, { week: 40, year: 2018 }, { week: 41, year: 2018 }, { week: 42, year: 2018 }, { week: 43, year: 2018 }, { week: 44, year: 2018 }, { week: 45, year: 2018 }, { week: 46, year: 2018 }, { week: 47, year: 2018 }, { week: 48, year: 2018 }, { week: 49, year: 2018 }, { week: 50, year: 2018 }, { week: 51, year: 2018 }, { week: 52, year: 2018 }, { week: 1, year: 2019 }, { week: 2, year: 2019 }, { week: 3, year: 2019 }, { week: 4, year: 2019 }, { week: 5, year: 2019 }, { week: 6, year: 2019 }, { week: 7, year: 2019 }, { week: 8, year: 2019 }, { week: 9, year: 2019 }, { week: 10, year: 2019 }, { week: 11, year: 2019 }, { week: 12, year: 2019 }, { week: 13, year: 2019 }, { week: 14, year: 2019 }, { week: 15, year: 2019 }, { week: 16, year: 2019 }, { week: 17, year: 2019 }, { week: 18, year: 2019 }, { week: 19, year: 2019 }, { week: 20, year: 2019 }, { week: 21, year: 2019 }, { week: 22, year: 2019 }, { week: 23, year: 2019 }, { week: 24, year: 2019 }, { week: 25, year: 2019 }, { week: 26, year: 2019 }, { week: 27, year: 2019 }, { week: 28, year: 2019 }, { week: 29, year: 2019 }, { week: 30, year: 2019 }, { week: 31, year: 2019 }, { week: 32, year: 2019 }, { week: 33, year: 2019 }, { week: 34, year: 2019 }, { week: 35, year: 2019 }, { week: 36, year: 2019 }, { week: 37, year: 2019 }, { week: 38, year: 2019 }, { week: 39, year: 2019 }, { week: 40, year: 2019 }, { week: 41, year: 2019 }, { week: 42, year: 2019 }, { week: 43, year: 2019 }, { week: 44, year: 2019 }, { week: 45, year: 2019 }, { week: 46, year: 2019 }, { week: 47, year: 2019 }, { week: 48, year: 2019 }, { week: 49, year: 2019 }, { week: 50, year: 2019 }, { week: 51, year: 2019 }, { week: 52, year: 2019 }, { week: 1, year: 2020 }, { week: 2, year: 2020 }, { week: 3, year: 2020 }, { week: 4, year: 2020 }, { week: 5, year: 2020 }, { week: 6, year: 2020 }, { week: 7, year: 2020 }, { week: 8, year: 2020 }, { week: 9, year: 2020 }, { week: 10, year: 2020 }, { week: 11, year: 2020 }, { week: 12, year: 2020 }, { week: 13, year: 2020 }, { week: 14, year: 2020 }, { week: 15, year: 2020 }, { week: 16, year: 2020 }, { week: 17, year: 2020 }, { week: 18, year: 2020 }, { week: 19, year: 2020 }, { week: 20, year: 2020 }, { week: 21, year: 2020 }, { week: 22, year: 2020 }, { week: 23, year: 2020 }, { week: 24, year: 2020 }, { week: 25, year: 2020 }, { week: 26, year: 2020 }, { week: 27, year: 2020 }, { week: 28, year: 2020 }, { week: 29, year: 2020 }, { week: 30, year: 2020 }, { week: 31, year: 2020 }, { week: 32, year: 2020 }, { week: 33, year: 2020 }, { week: 34, year: 2020 }, { week: 35, year: 2020 }, { week: 36, year: 2020 }, { week: 37, year: 2020 }, { week: 38, year: 2020 }, { week: 39, year: 2020 }, { week: 40, year: 2020 }, { week: 41, year: 2020 }, { week: 42, year: 2020 }, { week: 43, year: 2020 }, { week: 44, year: 2020 }, { week: 45, year: 2020 }, { week: 46, year: 2020 }, { week: 47, year: 2020 }, { week: 48, year: 2020 }, { week: 49, year: 2020 }, { week: 50, year: 2020 }, { week: 51, year: 2020 }, { week: 52, year: 2020 }, { week: 1, year: 2021 }, { week: 2, year: 2021 }, { week: 3, year: 2021 }, { week: 4, year: 2021 }, { week: 5, year: 2021 }, { week: 6, year: 2021 }, { week: 7, year: 2021 }, { week: 8, year: 2021 }, { week: 9, year: 2021 }, { week: 10, year: 2021 }, { week: 11, year: 2021 }, { week: 12, year: 2021 }, { week: 13, year: 2021 }, { week: 14, year: 2021 }, { week: 15, year: 2021 }, { week: 16, year: 2021 }, { week: 17, year: 2021 }, { week: 18, year: 2021 }, { week: 19, year: 2021 }, { week: 20, year: 2021 }, { week: 21, year: 2021 }, { week: 22, year: 2021 }, { week: 23, year: 2021 }, { week: 24, year: 2021 }, { week: 25, year: 2021 }, { week: 26, year: 2021 }, { week: 27, year: 2021 }, { week: 28, year: 2021 }, { week: 29, year: 2021 }, { week: 30, year: 2021 }, { week: 31, year: 2021 }, { week: 32, year: 2021 }, { week: 33, year: 2021 }, { week: 34, year: 2021 }, { week: 35, year: 2021 }, { week: 36, year: 2021 }, { week: 37, year: 2021 }, { week: 38, year: 2021 }, { week: 39, year: 2021 }, { week: 40, year: 2021 }, { week: 41, year: 2021 }, { week: 42, year: 2021 }, { week: 43, year: 2021 }, { week: 44, year: 2021 }, { week: 45, year: 2021 }, { week: 46, year: 2021 }, { week: 47, year: 2021 }, { week: 48, year: 2021 }, { week: 49, year: 2021 }, { week: 50, year: 2021 }, { week: 51, year: 2021 }, { week: 52, year: 2021 }, { week: 1, year: 2022 }, { week: 2, year: 2022 }, { week: 3, year: 2022 }, { week: 4, year: 2022 }, { week: 5, year: 2022 }, { week: 6, year: 2022 }, { week: 7, year: 2022 }, { week: 8, year: 2022 }, { week: 9, year: 2022 }, { week: 10, year: 2022 }, { week: 11, year: 2022 }, { week: 12, year: 2022 }, { week: 13, year: 2022 }, { week: 14, year: 2022 }, { week: 15, year: 2022 }, { week: 16, year: 2022 }, { week: 17, year: 2022 }, { week: 18, year: 2022 }, { week: 19, year: 2022 }, { week: 20, year: 2022 }, { week: 21, year: 2022 }, { week: 22, year: 2022 }, { week: 23, year: 2022 }, { week: 24, year: 2022 }, { week: 25, year: 2022 }, { week: 26, year: 2022 }, { week: 27, year: 2022 }, { week: 28, year: 2022 }, { week: 29, year: 2022 }, { week: 30, year: 2022 }, { week: 31, year: 2022 }, { week: 32, year: 2022 }, { week: 33, year: 2022 }, { week: 34, year: 2022 }, { week: 35, year: 2022 }, { week: 36, year: 2022 }, { week: 37, year: 2022 }, { week: 38, year: 2022 }, { week: 39, year: 2022 }, { week: 40, year: 2022 }, { week: 41, year: 2022 }, { week: 42, year: 2022 }, { week: 43, year: 2022 }, { week: 44, year: 2022 }, { week: 45, year: 2022 }, { week: 46, year: 2022 }, { week: 47, year: 2022 }, { week: 48, year: 2022 }, { week: 49, year: 2022 }, { week: 50, year: 2022 }, { week: 51, year: 2022 }, { week: 52, year: 2022 }, { week: 1, year: 2023 }, { week: 2, year: 2023 }, { week: 3, year: 2023 }, { week: 4, year: 2023 }, { week: 5, year: 2023 }, { week: 6, year: 2023 }, { week: 7, year: 2023 }, { week: 8, year: 2023 }, { week: 9, year: 2023 }, { week: 10, year: 2023 }, { week: 11, year: 2023 }, { week: 12, year: 2023 }, { week: 13, year: 2023 }, { week: 14, year: 2023 }, { week: 15, year: 2023 }, { week: 16, year: 2023 }, { week: 17, year: 2023 }, { week: 18, year: 2023 }, { week: 19, year: 2023 }, { week: 20, year: 2023 }, { week: 21, year: 2023 }, { week: 22, year: 2023 }, { week: 23, year: 2023 }, { week: 24, year: 2023 }, { week: 25, year: 2023 }, { week: 26, year: 2023 }, { week: 27, year: 2023 }] } bigDataReturn() { return this.bigData } bigLabelsReturn() { return this.bigLabels } smallDataCreate() { this.smallData = [{ stream_am: "13704546", week_start_dt: "2023-06-29T20:00:00.000Z", week_end_dt: "2023-07-05T20:00:00.000Z", week_num: 27, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13360626", week_start_dt: "2023-06-22T20:00:00.000Z", week_end_dt: "2023-06-28T20:00:00.000Z", week_num: 26, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13437870", week_start_dt: "2023-06-15T20:00:00.000Z", week_end_dt: "2023-06-21T20:00:00.000Z", week_num: 25, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13140522", week_start_dt: "2023-06-08T20:00:00.000Z", week_end_dt: "2023-06-14T20:00:00.000Z", week_num: 24, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13619161", week_start_dt: "2023-06-01T20:00:00.000Z", week_end_dt: "2023-06-07T20:00:00.000Z", week_num: 23, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14256397", week_start_dt: "2023-05-25T20:00:00.000Z", week_end_dt: "2023-05-31T20:00:00.000Z", week_num: 22, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13679909", week_start_dt: "2023-05-18T20:00:00.000Z", week_end_dt: "2023-05-24T20:00:00.000Z", week_num: 21, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13619638", week_start_dt: "2023-05-11T20:00:00.000Z", week_end_dt: "2023-05-17T20:00:00.000Z", week_num: 20, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13280199", week_start_dt: "2023-05-04T20:00:00.000Z", week_end_dt: "2023-05-10T20:00:00.000Z", week_num: 19, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13414254", week_start_dt: "2023-04-27T20:00:00.000Z", week_end_dt: "2023-05-03T20:00:00.000Z", week_num: 18, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13350754", week_start_dt: "2023-04-20T20:00:00.000Z", week_end_dt: "2023-04-26T20:00:00.000Z", week_num: 17, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13663273", week_start_dt: "2023-04-13T20:00:00.000Z", week_end_dt: "2023-04-19T20:00:00.000Z", week_num: 16, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13573025", week_start_dt: "2023-04-06T20:00:00.000Z", week_end_dt: "2023-04-12T20:00:00.000Z", week_num: 15, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13536360", week_start_dt: "2023-03-30T20:00:00.000Z", week_end_dt: "2023-04-05T20:00:00.000Z", week_num: 14, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13351748", week_start_dt: "2023-03-23T20:00:00.000Z", week_end_dt: "2023-03-29T20:00:00.000Z", week_num: 13, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13248220", week_start_dt: "2023-03-16T20:00:00.000Z", week_end_dt: "2023-03-22T20:00:00.000Z", week_num: 12, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13043781", week_start_dt: "2023-03-09T20:00:00.000Z", week_end_dt: "2023-03-15T20:00:00.000Z", week_num: 11, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13067320", week_start_dt: "2023-03-02T20:00:00.000Z", week_end_dt: "2023-03-08T20:00:00.000Z", week_num: 10, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12856939", week_start_dt: "2023-02-23T20:00:00.000Z", week_end_dt: "2023-03-01T20:00:00.000Z", week_num: 9, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12885737", week_start_dt: "2023-02-16T20:00:00.000Z", week_end_dt: "2023-02-22T20:00:00.000Z", week_num: 8, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12691458", week_start_dt: "2023-02-09T20:00:00.000Z", week_end_dt: "2023-02-15T20:00:00.000Z", week_num: 7, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12829504", week_start_dt: "2023-02-02T20:00:00.000Z", week_end_dt: "2023-02-08T20:00:00.000Z", week_num: 6, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12761969", week_start_dt: "2023-01-26T20:00:00.000Z", week_end_dt: "2023-02-01T20:00:00.000Z", week_num: 5, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13046141", week_start_dt: "2023-01-19T20:00:00.000Z", week_end_dt: "2023-01-25T20:00:00.000Z", week_num: 4, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13042860", week_start_dt: "2023-01-12T20:00:00.000Z", week_end_dt: "2023-01-18T20:00:00.000Z", week_num: 3, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12824600", week_start_dt: "2023-01-05T20:00:00.000Z", week_end_dt: "2023-01-11T20:00:00.000Z", week_num: 2, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13083060", week_start_dt: "2022-12-29T20:00:00.000Z", week_end_dt: "2023-01-04T20:00:00.000Z", week_num: 1, year_num: 2023, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11905552", week_start_dt: "2022-12-22T20:00:00.000Z", week_end_dt: "2022-12-28T20:00:00.000Z", week_num: 52, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11436728", week_start_dt: "2022-12-15T20:00:00.000Z", week_end_dt: "2022-12-21T20:00:00.000Z", week_num: 51, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11460414", week_start_dt: "2022-12-08T20:00:00.000Z", week_end_dt: "2022-12-14T20:00:00.000Z", week_num: 50, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11842843", week_start_dt: "2022-12-01T20:00:00.000Z", week_end_dt: "2022-12-07T20:00:00.000Z", week_num: 49, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "11550564", week_start_dt: "2022-11-24T20:00:00.000Z", week_end_dt: "2022-11-30T20:00:00.000Z", week_num: 48, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12137820", week_start_dt: "2022-11-17T20:00:00.000Z", week_end_dt: "2022-11-23T20:00:00.000Z", week_num: 47, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12305938", week_start_dt: "2022-11-10T20:00:00.000Z", week_end_dt: "2022-11-16T20:00:00.000Z", week_num: 46, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12426095", week_start_dt: "2022-11-03T20:00:00.000Z", week_end_dt: "2022-11-09T20:00:00.000Z", week_num: 45, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12404572", week_start_dt: "2022-10-27T20:00:00.000Z", week_end_dt: "2022-11-02T20:00:00.000Z", week_num: 44, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12333467", week_start_dt: "2022-10-20T20:00:00.000Z", week_end_dt: "2022-10-26T20:00:00.000Z", week_num: 43, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12911926", week_start_dt: "2022-10-13T20:00:00.000Z", week_end_dt: "2022-10-19T20:00:00.000Z", week_num: 42, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12953863", week_start_dt: "2022-10-06T20:00:00.000Z", week_end_dt: "2022-10-12T20:00:00.000Z", week_num: 41, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "12778275", week_start_dt: "2022-09-29T20:00:00.000Z", week_end_dt: "2022-10-05T20:00:00.000Z", week_num: 40, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13153433", week_start_dt: "2022-09-22T20:00:00.000Z", week_end_dt: "2022-09-28T20:00:00.000Z", week_num: 39, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13340904", week_start_dt: "2022-09-15T20:00:00.000Z", week_end_dt: "2022-09-21T20:00:00.000Z", week_num: 38, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13830255", week_start_dt: "2022-09-08T20:00:00.000Z", week_end_dt: "2022-09-14T20:00:00.000Z", week_num: 37, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13706066", week_start_dt: "2022-09-01T20:00:00.000Z", week_end_dt: "2022-09-07T20:00:00.000Z", week_num: 36, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13533543", week_start_dt: "2022-08-25T20:00:00.000Z", week_end_dt: "2022-08-31T20:00:00.000Z", week_num: 35, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "13732629", week_start_dt: "2022-08-18T20:00:00.000Z", week_end_dt: "2022-08-24T20:00:00.000Z", week_num: 34, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14020744", week_start_dt: "2022-08-11T20:00:00.000Z", week_end_dt: "2022-08-17T20:00:00.000Z", week_num: 33, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14238945", week_start_dt: "2022-08-04T20:00:00.000Z", week_end_dt: "2022-08-10T20:00:00.000Z", week_num: 32, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14126108", week_start_dt: "2022-07-28T20:00:00.000Z", week_end_dt: "2022-08-03T20:00:00.000Z", week_num: 31, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14196951", week_start_dt: "2022-07-21T20:00:00.000Z", week_end_dt: "2022-07-27T20:00:00.000Z", week_num: 30, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14238525", week_start_dt: "2022-07-14T20:00:00.000Z", week_end_dt: "2022-07-20T20:00:00.000Z", week_num: 29, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14060840", week_start_dt: "2022-07-07T20:00:00.000Z", week_end_dt: "2022-07-13T20:00:00.000Z", week_num: 28, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }, { stream_am: "14092472", week_start_dt: "2022-06-30T20:00:00.000Z", week_end_dt: "2022-07-06T20:00:00.000Z", week_num: 27, year_num: 2022, release_dt: "1974-12-30T20:00:00.000Z" }] } smallLabelsCreate() { this.smallLabels = [{ week: 27, year: 2022 }, { week: 28, year: 2022 }, { week: 29, year: 2022 }, { week: 30, year: 2022 }, { week: 31, year: 2022 }, { week: 32, year: 2022 }, { week: 33, year: 2022 }, { week: 34, year: 2022 }, { week: 35, year: 2022 }, { week: 36, year: 2022 }, { week: 37, year: 2022 }, { week: 38, year: 2022 }, { week: 39, year: 2022 }, { week: 40, year: 2022 }, { week: 41, year: 2022 }, { week: 42, year: 2022 }, { week: 43, year: 2022 }, { week: 44, year: 2022 }, { week: 45, year: 2022 }, { week: 46, year: 2022 }, { week: 47, year: 2022 }, { week: 48, year: 2022 }, { week: 49, year: 2022 }, { week: 50, year: 2022 }, { week: 51, year: 2022 }, { week: 52, year: 2022 }, { week: 1, year: 2023 }, { week: 2, year: 2023 }, { week: 3, year: 2023 }, { week: 4, year: 2023 }, { week: 5, year: 2023 }, { week: 6, year: 2023 }, { week: 7, year: 2023 }, { week: 8, year: 2023 }, { week: 9, year: 2023 }, { week: 10, year: 2023 }, { week: 11, year: 2023 }, { week: 12, year: 2023 }, { week: 13, year: 2023 }, { week: 14, year: 2023 }, { week: 15, year: 2023 }, { week: 16, year: 2023 }, { week: 17, year: 2023 }, { week: 18, year: 2023 }, { week: 19, year: 2023 }, { week: 20, year: 2023 }, { week: 21, year: 2023 }, { week: 22, year: 2023 }, { week: 23, year: 2023 }, { week: 24, year: 2023 }, { week: 25, year: 2023 }, { week: 26, year: 2023 }, { week: 27, year: 2023 }] } smallDataReturn() { return this.smallData } smallLabelsReturn() { return this.smallLabels } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = oe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const d7 = ["canvas"]; let f7 = (() => { class t { constructor(n) { this.testChartDataService = n, this.canvasId = "canvasId", this.labels = [], this.data = [], this.dates = new Set, this.weeks = [], this.years = [], sr.register(...C9), sr.register(u7) } ngOnInit() { this.createWeeks(), this.createData() } ngAfterViewInit() { this.initCanvas() } initCanvas() { var n; this.chart = new sr(null === (n = this._canvas) || void 0 === n ? void 0 : n.nativeElement, { type: "line", data: { labels: this.weeks, datasets: [{ label: "Bohemian Rhapsody by Queen", data: this.data, fill: !1, borderColor: "rgb(75, 192, 192)", tension: .1 }], datas: [...this.dates], years: this.years }, plugins: [{ afterDraw: r => { var i; console.log(r); const s = r.ctx; if (s.save(), console.log(r), !r.data.years) return; console.log(r.data.years); let o = 0; const a = [], l = r.scales.y.bottom, u = r.scales.x.right; s.strokeStyle = "lightgray", s.beginPath(), s.moveTo(60, l + 65), s.lineTo(u, l + 65), s.stroke(); for (let c = 0; c < r.data.years.length; c++) { const d = [...this.dates].filter(T => T.includes(this.years[c])); console.log(d), o += d.length; let p = 0; for (let T = 0; T < r.data.datasets.length; T++) { const C = r.getDatasetMeta(T); if (console.log(C.data[o - 1]), null === (i = C.data[o - 1]) || void 0 === i ? void 0 : i.x) { p = C.data[o - 1].x; break } } const m = p - 10, y = r.scales.y.bottom, v = 75; s.textAlign = "center", s.font = "12px Arial", s.fillStyle = "black", a.push(m), console.log(m, a[c - 1]), s.fillText(r.data.years[c], c > 0 ? (m - a[c - 1]) / 2 + a[c - 1] + 15 : m / 2 + 40, y + v), s.strokeStyle = "lightgray"; const w = []; w.push(m), w.forEach(T => { s.beginPath(), s.moveTo(T + 10, y), s.lineTo(T + 10, y + 60), s.stroke() }) } s.restore() } }], options: { plugins: { zoom: { pan: { enabled: !0, mode: "x", modifierKey: "ctrl" }, zoom: { drag: { enabled: !0 }, mode: "x" } } }, scales: { x: { ticks: { maxRotation: 90, minRotation: 90, padding: 20 } } } } }), this.chart.render() } createWeeks() { let n = []; n = "small" === this.weekCount ? this.testChartDataService.smallLabelsReturn() : this.testChartDataService.bigLabelsReturn(), this.years = [...new Set(this._labelsObjectToArray(n, "year"))]; for (let r = 0; r < n.length; r++)this.weeks.push(`WK${n[r].week >= 10 ? n[r].week : "0" + n[r].week}`); this.labels = n } createData() { let n = []; n = "small" === this.weekCount ? this.testChartDataService.smallDataReturn() : this.testChartDataService.bigDataReturn(), this.labels.forEach(r => { let i; i = n.find(s => (null == s ? void 0 : s.week_num) === r.week && (null == s ? void 0 : s.year_num) === r.year), this.dates.add(`${r.week}_${r.year}`), this.data.push(i ? i.stream_am : null) }) } _labelsObjectToArray(n, r) { return n.map(i => i[r]) } initCanvas2() { } } return t.\u0275fac = function (n) { return new (n || t)(N(c7)) }, t.\u0275cmp = Io({ type: t, selectors: [["app-test-chart"]], viewQuery: function (n, r) { if (1 & n && W1(d7, 5), 2 & n) { let i; Bu(i = function ju() { return function AI(t, e) { return t[19].queries[e].queryList }(x(), bg()) }()) && (r._canvas = i.first) } }, inputs: { weekCount: "weekCount" }, decls: 6, vars: 0, consts: [[1, "song-component"], [1, "canvas"], [2, "max-width", "800px", "max-height", "500px !important"], ["canvas", ""], ["nz-button", "", "nzType", "primary", 2, "margin-right", "5px", 3, "click"]], template: function (n, r) { 1 & n && (oa(0, "div", 0)(1, "div", 1), aa(2, "canvas", 2, 3), oa(4, "button", 4), la("click", function () { return r.chart.resetZoom() }), O2(5, " Reset Zoom "), Mu()()()) }, styles: [".canvas[_ngcontent-%COMP%]{padding:30px}.canvas[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{margin-top:20px;padding:5px 10px;background-color:#0f7bd3;border:none;border-radius:10px;color:#fff;cursor:pointer}"] }), t })(), h7 = (() => { class t { constructor() { this.title = "testChart2" } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275cmp = Io({ type: t, selectors: [["app-root"]], decls: 2, vars: 2, consts: [[3, "weekCount"]], template: function (n, r) { 1 & n && aa(0, "app-test-chart", 0)(1, "app-test-chart", 0), 2 & n && (Eu("weekCount", "small"), function Bm(t) { jm(ue(), x(), xt() + t, !1) }(1), Eu("weekCount", "big")) }, directives: [f7], styles: [""] }), t })(), p7 = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = gi({ type: t, bootstrap: [h7] }), t.\u0275inj = Fr({ providers: [], imports: [[ZP, wF]] }), t })(); (function yA() { xy = !1 })(), NP().bootstrapModule(p7).catch(t => console.error(t)) }, 386: (nt, Ie, Ye) => { var ge; !function (rt, zi, gl, _e) { "use strict"; var Pt, po = ["", "webkit", "Moz", "MS", "ms", "o"], ml = zi.createElement("div"), At = Math.round, Kt = Math.abs, Wi = Date.now; function qi(g, _, b) { return setTimeout(oi(g, b), _) } function Sr(g, _, b) { return !!Array.isArray(g) && (pn(g, b[_], b), !0) } function pn(g, _, b) { var k; if (g) if (g.forEach) g.forEach(_, b); else if (g.length !== _e) for (k = 0; k < g.length;)_.call(b, g[k], k, g), k++; else for (k in g) g.hasOwnProperty(k) && _.call(b, g[k], k, g) } function yl(g, _, b) { var k = "DEPRECATED METHOD: " + _ + "\n" + b + " AT \n"; return function () { var E = new Error("get-stack-trace"), R = E && E.stack ? E.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", G = rt.console && (rt.console.warn || rt.console.log); return G && G.call(rt.console, k, R), g.apply(this, arguments) } } Pt = "function" != typeof Object.assign ? function (_) { if (_ === _e || null === _) throw new TypeError("Cannot convert undefined or null to object"); for (var b = Object(_), k = 1; k < arguments.length; k++) { var E = arguments[k]; if (E !== _e && null !== E) for (var R in E) E.hasOwnProperty(R) && (b[R] = E[R]) } return b } : Object.assign; var jn = yl(function (_, b, k) { for (var E = Object.keys(b), R = 0; R < E.length;)(!k || k && _[E[R]] === _e) && (_[E[R]] = b[E[R]]), R++; return _ }, "extend", "Use `assign`."), Gi = yl(function (_, b) { return jn(_, b, !0) }, "merge", "Use `assign`."); function Tt(g, _, b) { var E, k = _.prototype; (E = g.prototype = Object.create(k)).constructor = g, E._super = k, b && Pt(E, b) } function oi(g, _) { return function () { return g.apply(_, arguments) } } function go(g, _) { return "function" == typeof g ? g.apply(_ && _[0] || _e, _) : g } function Yi(g, _) { return g === _e ? _ : g } function Xi(g, _, b) { pn(Ir(_), function (k) { g.addEventListener(k, b, !1) }) } function Hn(g, _, b) { pn(Ir(_), function (k) { g.removeEventListener(k, b, !1) }) } function ai(g, _) { for (; g;) { if (g == _) return !0; g = g.parentNode } return !1 } function ar(g, _) { return g.indexOf(_) > -1 } function Ir(g) { return g.trim().split(/\s+/g) } function Ar(g, _, b) { if (g.indexOf && !b) return g.indexOf(_); for (var k = 0; k < g.length;) { if (b && g[k][b] == _ || !b && g[k] === _) return k; k++ } return -1 } function Pr(g) { return Array.prototype.slice.call(g, 0) } function Un(g, _, b) { for (var k = [], E = [], R = 0; R < g.length;) { var G = _ ? g[R][_] : g[R]; Ar(E, G) < 0 && k.push(g[R]), E[R] = G, R++ } return b && (k = _ ? k.sort(function (st, lt) { return st[_] > lt[_] }) : k.sort()), k } function mo(g, _) { for (var b, k, E = _[0].toUpperCase() + _.slice(1), R = 0; R < po.length;) { if ((k = (b = po[R]) ? b + E : _) in g) return k; R++ } return _e } var wl = 1; function _o(g) { var _ = g.ownerDocument || g; return _.defaultView || _.parentWindow || rt } var vl = "ontouchstart" in rt, dc = mo(rt, "PointerEvent") !== _e, gn = vl && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), Or = "touch", Be = "mouse", yo = ["x", "y"], es = ["clientX", "clientY"]; function ht(g, _) { var b = this; this.manager = g, this.callback = _, this.element = g.element, this.target = g.options.inputTarget, this.domHandler = function (k) { go(g.options.enable, [g]) && b.handler(k) }, this.init() } function wo(g, _, b) { var k = b.pointers.length, E = b.changedPointers.length, R = 1 & _ && k - E == 0, G = 12 & _ && k - E == 0; b.isFirst = !!R, b.isFinal = !!G, R && (g.session = {}), b.eventType = _, function kl(g, _) { var b = g.session, k = _.pointers, E = k.length; b.firstInput || (b.firstInput = Dl(_)), E > 1 && !b.firstMultiple ? b.firstMultiple = Dl(_) : 1 === E && (b.firstMultiple = !1); var R = b.firstInput, G = b.firstMultiple, fe = G ? G.center : R.center, st = _.center = yn(k); _.timeStamp = Wi(), _.deltaTime = _.timeStamp - R.timeStamp, _.angle = bo(fe, st), _.distance = ci(fe, st), function pc(g, _) { var b = _.center, k = g.offsetDelta || {}, E = g.prevDelta || {}, R = g.prevInput || {}; (1 === _.eventType || 4 === R.eventType) && (E = g.prevDelta = { x: R.deltaX || 0, y: R.deltaY || 0 }, k = g.offsetDelta = { x: b.x, y: b.y }), _.deltaX = E.x + (b.x - k.x), _.deltaY = E.y + (b.y - k.y) }(b, _), _.offsetDirection = Cl(_.deltaX, _.deltaY); var lt = vo(_.deltaTime, _.deltaX, _.deltaY); _.overallVelocityX = lt.x, _.overallVelocityY = lt.y, _.overallVelocity = Kt(lt.x) > Kt(lt.y) ? lt.x : lt.y, _.scale = G ? function _c(g, _) { return ci(_[0], _[1], es) / ci(g[0], g[1], es) }(G.pointers, k) : 1, _.rotation = G ? function mc(g, _) { return bo(_[1], _[0], es) + bo(g[1], g[0], es) }(G.pointers, k) : 0, _.maxPointers = b.prevInput ? _.pointers.length > b.prevInput.maxPointers ? _.pointers.length : b.prevInput.maxPointers : _.pointers.length, function gc(g, _) { var E, R, G, fe, b = g.lastInterval || _, k = _.timeStamp - b.timeStamp; if (8 != _.eventType && (k > 25 || b.velocity === _e)) { var st = _.deltaX - b.deltaX, lt = _.deltaY - b.deltaY, kn = vo(k, st, lt); R = kn.x, G = kn.y, E = Kt(kn.x) > Kt(kn.y) ? kn.x : kn.y, fe = Cl(st, lt), g.lastInterval = _ } else E = b.velocity, R = b.velocityX, G = b.velocityY, fe = b.direction; _.velocity = E, _.velocityX = R, _.velocityY = G, _.direction = fe }(b, _); var kn = g.element; ai(_.srcEvent.target, kn) && (kn = _.srcEvent.target), _.target = kn }(g, b), g.emit("hammer.input", b), g.recognize(b), g.session.prevInput = b } function Dl(g) { for (var _ = [], b = 0; b < g.pointers.length;)_[b] = { clientX: At(g.pointers[b].clientX), clientY: At(g.pointers[b].clientY) }, b++; return { timeStamp: Wi(), pointers: _, center: yn(_), deltaX: g.deltaX, deltaY: g.deltaY } } function yn(g) { var _ = g.length; if (1 === _) return { x: At(g[0].clientX), y: At(g[0].clientY) }; for (var b = 0, k = 0, E = 0; E < _;)b += g[E].clientX, k += g[E].clientY, E++; return { x: At(b / _), y: At(k / _) } } function vo(g, _, b) { return { x: _ / g || 0, y: b / g || 0 } } function Cl(g, _) { return g === _ ? 1 : Kt(g) >= Kt(_) ? g < 0 ? 2 : 4 : _ < 0 ? 8 : 16 } function ci(g, _, b) { b || (b = yo); var k = _[b[0]] - g[b[0]], E = _[b[1]] - g[b[1]]; return Math.sqrt(k * k + E * E) } function bo(g, _, b) { return b || (b = yo), 180 * Math.atan2(_[b[1]] - g[b[1]], _[b[0]] - g[b[0]]) / Math.PI } ht.prototype = { handler: function () { }, init: function () { this.evEl && Xi(this.element, this.evEl, this.domHandler), this.evTarget && Xi(this.target, this.evTarget, this.domHandler), this.evWin && Xi(_o(this.element), this.evWin, this.domHandler) }, destroy: function () { this.evEl && Hn(this.element, this.evEl, this.domHandler), this.evTarget && Hn(this.target, this.evTarget, this.domHandler), this.evWin && Hn(_o(this.element), this.evWin, this.domHandler) } }; var yc = { mousedown: 1, mousemove: 2, mouseup: 4 }, wc = "mousedown", vc = "mousemove mouseup"; function ts() { this.evEl = wc, this.evWin = vc, this.pressed = !1, ht.apply(this, arguments) } Tt(ts, ht, { handler: function (_) { var b = yc[_.type]; 1 & b && 0 === _.button && (this.pressed = !0), 2 & b && 1 !== _.which && (b = 4), this.pressed && (4 & b && (this.pressed = !1), this.callback(this.manager, b, { pointers: [_], changedPointers: [_], pointerType: Be, srcEvent: _ })) } }); var bc = { pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8 }, Tc = { 2: Or, 3: "pen", 4: Be, 5: "kinect" }, xl = "pointerdown", kc = "pointermove pointerup pointercancel"; function ns() { this.evEl = xl, this.evWin = kc, ht.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } rt.MSPointerEvent && !rt.PointerEvent && (xl = "MSPointerDown", kc = "MSPointerMove MSPointerUp MSPointerCancel"), Tt(ns, ht, { handler: function (_) { var b = this.store, k = !1, E = _.type.toLowerCase().replace("ms", ""), R = bc[E], G = Tc[_.pointerType] || _.pointerType, fe = G == Or, st = Ar(b, _.pointerId, "pointerId"); 1 & R && (0 === _.button || fe) ? st < 0 && (b.push(_), st = b.length - 1) : 12 & R && (k = !0), !(st < 0) && (b[st] = _, this.callback(this.manager, R, { pointers: b, changedPointers: [_], pointerType: G, srcEvent: _ }), k && b.splice(st, 1)) } }); var El = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }, Ml = "touchstart", Sl = "touchstart touchmove touchend touchcancel"; function To() { this.evTarget = Ml, this.evWin = Sl, this.started = !1, ht.apply(this, arguments) } function Dc(g, _) { var b = Pr(g.touches), k = Pr(g.changedTouches); return 12 & _ && (b = Un(b.concat(k), "identifier", !0)), [b, k] } Tt(To, ht, { handler: function (_) { var b = El[_.type]; if (1 === b && (this.started = !0), this.started) { var k = Dc.call(this, _, b); 12 & b && k[0].length - k[1].length == 0 && (this.started = !1), this.callback(this.manager, b, { pointers: k[0], changedPointers: k[1], pointerType: Or, srcEvent: _ }) } } }); var Il = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }, Al = "touchstart touchmove touchend touchcancel"; function di() { this.evTarget = Al, this.targetIds = {}, ht.apply(this, arguments) } function Pl(g, _) { var b = Pr(g.touches), k = this.targetIds; if (3 & _ && 1 === b.length) return k[b[0].identifier] = !0, [b, b]; var E, R, G = Pr(g.changedTouches), fe = [], st = this.target; if (R = b.filter(function (lt) { return ai(lt.target, st) }), 1 === _) for (E = 0; E < R.length;)k[R[E].identifier] = !0, E++; for (E = 0; E < G.length;)k[G[E].identifier] && fe.push(G[E]), 12 & _ && delete k[G[E].identifier], E++; return fe.length ? [Un(R.concat(fe), "identifier", !0), fe] : void 0 } function ko() { ht.apply(this, arguments); var g = oi(this.handler, this); this.touch = new di(this.manager, g), this.mouse = new ts(this.manager, g), this.primaryTouch = null, this.lastTouches = [] } function Cc(g, _) { 1 & g ? (this.primaryTouch = _.changedPointers[0].identifier, Rl.call(this, _)) : 12 & g && Rl.call(this, _) } function Rl(g) { var _ = g.changedPointers[0]; if (_.identifier === this.primaryTouch) { var b = { x: _.clientX, y: _.clientY }; this.lastTouches.push(b); var k = this.lastTouches; setTimeout(function () { var R = k.indexOf(b); R > -1 && k.splice(R, 1) }, 2500) } } function Fl(g) { for (var _ = g.srcEvent.clientX, b = g.srcEvent.clientY, k = 0; k < this.lastTouches.length; k++) { var E = this.lastTouches[k], R = Math.abs(_ - E.x), G = Math.abs(b - E.y); if (R <= 25 && G <= 25) return !0 } return !1 } Tt(di, ht, { handler: function (_) { var b = Il[_.type], k = Pl.call(this, _, b); !k || this.callback(this.manager, b, { pointers: k[0], changedPointers: k[1], pointerType: Or, srcEvent: _ }) } }), Tt(ko, ht, { handler: function (_, b, k) { var R = k.pointerType == Be; if (!(R && k.sourceCapabilities && k.sourceCapabilities.firesTouchEvents)) { if (k.pointerType == Or) Cc.call(this, b, k); else if (R && Fl.call(this, k)) return; this.callback(_, b, k) } }, destroy: function () { this.touch.destroy(), this.mouse.destroy() } }); var Nl = mo(ml.style, "touchAction"), Ll = Nl !== _e, en = "compute", Pe = "manipulation", Vt = "none", kt = "pan-x", rs = "pan-y", is = function xc() { if (!Ll) return !1; var g = {}, _ = rt.CSS && rt.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function (b) { g[b] = !_ || rt.CSS.supports("touch-action", b) }), g }(); function Do(g, _) { this.manager = g, this.set(_) } function bn(g) { this.options = Pt({}, this.defaults, g || {}), this.id = function Ve() { return wl++ }(), this.manager = null, this.options.enable = Yi(this.options.enable, !0), this.state = 1, this.simultaneous = {}, this.requireFail = [] } function xo(g) { return 16 & g ? "cancel" : 8 & g ? "end" : 4 & g ? "move" : 2 & g ? "start" : "" } function Vl(g) { return 16 == g ? "down" : 8 == g ? "up" : 2 == g ? "left" : 4 == g ? "right" : "" } function ss(g, _) { var b = _.manager; return b ? b.get(g) : g } function ye() { bn.apply(this, arguments) } function os() { ye.apply(this, arguments), this.pX = null, this.pY = null } function Eo() { ye.apply(this, arguments) } function hi() { bn.apply(this, arguments), this._timer = null, this._input = null } function pe() { ye.apply(this, arguments) } function pi() { ye.apply(this, arguments) } function ae() { bn.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function Tn(g, _) { return (_ = _ || {}).recognizers = Yi(_.recognizers, Tn.defaults.preset), new j(g, _) } function j(g, _) { this.options = Pt({}, Tn.defaults, _ || {}), this.options.inputTarget = this.options.inputTarget || g, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = g, this.input = function hc(g) { return new (g.options.inputClass || (dc ? ns : gn ? di : vl ? ko : ts))(g, wo) }(this), this.touchAction = new Do(this, this.options.touchAction), Mo(this, !0), pn(this.options.recognizers, function (b) { var k = this.add(new b[0](b[1])); b[2] && k.recognizeWith(b[2]), b[3] && k.requireFailure(b[3]) }, this) } function Mo(g, _) { var k, b = g.element; b.style && (pn(g.options.cssProps, function (E, R) { k = mo(b.style, R), _ ? (g.oldCssProps[k] = b.style[k], b.style[k] = E) : b.style[k] = g.oldCssProps[k] || "" }), _ || (g.oldCssProps = {})) } Do.prototype = { set: function (g) { g == en && (g = this.compute()), Ll && this.manager.element.style && is[g] && (this.manager.element.style[Nl] = g), this.actions = g.toLowerCase().trim() }, update: function () { this.set(this.manager.options.touchAction) }, compute: function () { var g = []; return pn(this.manager.recognizers, function (_) { go(_.options.enable, [_]) && (g = g.concat(_.getTouchAction())) }), function Co(g) { if (ar(g, Vt)) return Vt; var _ = ar(g, kt), b = ar(g, rs); return _ && b ? Vt : _ || b ? _ ? kt : rs : ar(g, Pe) ? Pe : "auto" }(g.join(" ")) }, preventDefaults: function (g) { var _ = g.srcEvent, b = g.offsetDirection; if (!this.manager.session.prevented) { var k = this.actions, E = ar(k, Vt) && !is[Vt], R = ar(k, rs) && !is[rs], G = ar(k, kt) && !is[kt]; if (E && 1 === g.pointers.length && g.distance < 2 && g.deltaTime < 250) return; return G && R || !(E || R && 6 & b || G && 24 & b) ? void 0 : this.preventSrc(_) } _.preventDefault() }, preventSrc: function (g) { this.manager.session.prevented = !0, g.preventDefault() } }, bn.prototype = { defaults: {}, set: function (g) { return Pt(this.options, g), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function (g) { if (Sr(g, "recognizeWith", this)) return this; var _ = this.simultaneous; return _[(g = ss(g, this)).id] || (_[g.id] = g, g.recognizeWith(this)), this }, dropRecognizeWith: function (g) { return Sr(g, "dropRecognizeWith", this) || (g = ss(g, this), delete this.simultaneous[g.id]), this }, requireFailure: function (g) { if (Sr(g, "requireFailure", this)) return this; var _ = this.requireFail; return -1 === Ar(_, g = ss(g, this)) && (_.push(g), g.requireFailure(this)), this }, dropRequireFailure: function (g) { if (Sr(g, "dropRequireFailure", this)) return this; g = ss(g, this); var _ = Ar(this.requireFail, g); return _ > -1 && this.requireFail.splice(_, 1), this }, hasRequireFailures: function () { return this.requireFail.length > 0 }, canRecognizeWith: function (g) { return !!this.simultaneous[g.id] }, emit: function (g) { var _ = this, b = this.state; function k(E) { _.manager.emit(E, g) } b < 8 && k(_.options.event + xo(b)), k(_.options.event), g.additionalEvent && k(g.additionalEvent), b >= 8 && k(_.options.event + xo(b)) }, tryEmit: function (g) { if (this.canEmit()) return this.emit(g); this.state = 32 }, canEmit: function () { for (var g = 0; g < this.requireFail.length;) { if (!(33 & this.requireFail[g].state)) return !1; g++ } return !0 }, recognize: function (g) { var _ = Pt({}, g); if (!go(this.options.enable, [this, _])) return this.reset(), void (this.state = 32); 56 & this.state && (this.state = 1), this.state = this.process(_), 30 & this.state && this.tryEmit(_) }, process: function (g) { }, getTouchAction: function () { }, reset: function () { } }, Tt(ye, bn, { defaults: { pointers: 1 }, attrTest: function (g) { var _ = this.options.pointers; return 0 === _ || g.pointers.length === _ }, process: function (g) { var _ = this.state, b = g.eventType, k = 6 & _, E = this.attrTest(g); return k && (8 & b || !E) ? 16 | _ : k || E ? 4 & b ? 8 | _ : 2 & _ ? 4 | _ : 2 : 32 } }), Tt(os, ye, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: 30 }, getTouchAction: function () { var g = this.options.direction, _ = []; return 6 & g && _.push(rs), 24 & g && _.push(kt), _ }, directionTest: function (g) { var _ = this.options, b = !0, k = g.distance, E = g.direction, R = g.deltaX, G = g.deltaY; return E & _.direction || (6 & _.direction ? (E = 0 === R ? 1 : R < 0 ? 2 : 4, b = R != this.pX, k = Math.abs(g.deltaX)) : (E = 0 === G ? 1 : G < 0 ? 8 : 16, b = G != this.pY, k = Math.abs(g.deltaY))), g.direction = E, b && k > _.threshold && E & _.direction }, attrTest: function (g) { return ye.prototype.attrTest.call(this, g) && (2 & this.state || !(2 & this.state) && this.directionTest(g)) }, emit: function (g) { this.pX = g.deltaX, this.pY = g.deltaY; var _ = Vl(g.direction); _ && (g.additionalEvent = this.options.event + _), this._super.emit.call(this, g) } }), Tt(Eo, ye, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function () { return [Vt] }, attrTest: function (g) { return this._super.attrTest.call(this, g) && (Math.abs(g.scale - 1) > this.options.threshold || 2 & this.state) }, emit: function (g) { 1 !== g.scale && (g.additionalEvent = this.options.event + (g.scale < 1 ? "in" : "out")), this._super.emit.call(this, g) } }), Tt(hi, bn, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function () { return ["auto"] }, process: function (g) { var _ = this.options, b = g.pointers.length === _.pointers, k = g.distance < _.threshold, E = g.deltaTime > _.time; if (this._input = g, !k || !b || 12 & g.eventType && !E) this.reset(); else if (1 & g.eventType) this.reset(), this._timer = qi(function () { this.state = 8, this.tryEmit() }, _.time, this); else if (4 & g.eventType) return 8; return 32 }, reset: function () { clearTimeout(this._timer) }, emit: function (g) { 8 === this.state && (g && 4 & g.eventType ? this.manager.emit(this.options.event + "up", g) : (this._input.timeStamp = Wi(), this.manager.emit(this.options.event, this._input))) } }), Tt(pe, ye, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function () { return [Vt] }, attrTest: function (g) { return this._super.attrTest.call(this, g) && (Math.abs(g.rotation) > this.options.threshold || 2 & this.state) } }), Tt(pi, ye, { defaults: { event: "swipe", threshold: 10, velocity: .3, direction: 30, pointers: 1 }, getTouchAction: function () { return os.prototype.getTouchAction.call(this) }, attrTest: function (g) { var b, _ = this.options.direction; return 30 & _ ? b = g.overallVelocity : 6 & _ ? b = g.overallVelocityX : 24 & _ && (b = g.overallVelocityY), this._super.attrTest.call(this, g) && _ & g.offsetDirection && g.distance > this.options.threshold && g.maxPointers == this.options.pointers && Kt(b) > this.options.velocity && 4 & g.eventType }, emit: function (g) { var _ = Vl(g.offsetDirection); _ && this.manager.emit(this.options.event + _, g), this.manager.emit(this.options.event, g) } }), Tt(ae, bn, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function () { return [Pe] }, process: function (g) { var _ = this.options, b = g.pointers.length === _.pointers, k = g.distance < _.threshold, E = g.deltaTime < _.time; if (this.reset(), 1 & g.eventType && 0 === this.count) return this.failTimeout(); if (k && E && b) { if (4 != g.eventType) return this.failTimeout(); var R = !this.pTime || g.timeStamp - this.pTime < _.interval, G = !this.pCenter || ci(this.pCenter, g.center) < _.posThreshold; if (this.pTime = g.timeStamp, this.pCenter = g.center, G && R ? this.count += 1 : this.count = 1, this._input = g, 0 == this.count % _.taps) return this.hasRequireFailures() ? (this._timer = qi(function () { this.state = 8, this.tryEmit() }, _.interval, this), 2) : 8 } return 32 }, failTimeout: function () { return this._timer = qi(function () { this.state = 32 }, this.options.interval, this), 32 }, reset: function () { clearTimeout(this._timer) }, emit: function () { 8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), Tn.VERSION = "2.0.7", Tn.defaults = { domEvents: !1, touchAction: en, enable: !0, inputTarget: null, inputClass: null, preset: [[pe, { enable: !1 }], [Eo, { enable: !1 }, ["rotate"]], [pi, { direction: 6 }], [os, { direction: 6 }, ["swipe"]], [ae], [ae, { event: "doubletap", taps: 2 }, ["tap"]], [hi]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }, j.prototype = { set: function (g) { return Pt(this.options, g), g.touchAction && this.touchAction.update(), g.inputTarget && (this.input.destroy(), this.input.target = g.inputTarget, this.input.init()), this }, stop: function (g) { this.session.stopped = g ? 2 : 1 }, recognize: function (g) { var _ = this.session; if (!_.stopped) { this.touchAction.preventDefaults(g); var b, k = this.recognizers, E = _.curRecognizer; (!E || E && 8 & E.state) && (E = _.curRecognizer = null); for (var R = 0; R < k.length;)b = k[R], 2 === _.stopped || E && b != E && !b.canRecognizeWith(E) ? b.reset() : b.recognize(g), !E && 14 & b.state && (E = _.curRecognizer = b), R++ } }, get: function (g) { if (g instanceof bn) return g; for (var _ = this.recognizers, b = 0; b < _.length; b++)if (_[b].options.event == g) return _[b]; return null }, add: function (g) { if (Sr(g, "add", this)) return this; var _ = this.get(g.options.event); return _ && this.remove(_), this.recognizers.push(g), g.manager = this, this.touchAction.update(), g }, remove: function (g) { if (Sr(g, "remove", this)) return this; if (g = this.get(g)) { var _ = this.recognizers, b = Ar(_, g); -1 !== b && (_.splice(b, 1), this.touchAction.update()) } return this }, on: function (g, _) { if (g !== _e && _ !== _e) { var b = this.handlers; return pn(Ir(g), function (k) { b[k] = b[k] || [], b[k].push(_) }), this } }, off: function (g, _) { if (g !== _e) { var b = this.handlers; return pn(Ir(g), function (k) { _ ? b[k] && b[k].splice(Ar(b[k], _), 1) : delete b[k] }), this } }, emit: function (g, _) { this.options.domEvents && function Jp(g, _) { var b = zi.createEvent("Event"); b.initEvent(g, !0, !0), b.gesture = _, _.target.dispatchEvent(b) }(g, _); var b = this.handlers[g] && this.handlers[g].slice(); if (b && b.length) { _.type = g, _.preventDefault = function () { _.srcEvent.preventDefault() }; for (var k = 0; k < b.length;)b[k](_), k++ } }, destroy: function () { this.element && Mo(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, Pt(Tn, { INPUT_START: 1, INPUT_MOVE: 2, INPUT_END: 4, INPUT_CANCEL: 8, STATE_POSSIBLE: 1, STATE_BEGAN: 2, STATE_CHANGED: 4, STATE_ENDED: 8, STATE_RECOGNIZED: 8, STATE_CANCELLED: 16, STATE_FAILED: 32, DIRECTION_NONE: 1, DIRECTION_LEFT: 2, DIRECTION_RIGHT: 4, DIRECTION_UP: 8, DIRECTION_DOWN: 16, DIRECTION_HORIZONTAL: 6, DIRECTION_VERTICAL: 24, DIRECTION_ALL: 30, Manager: j, Input: ht, TouchAction: Do, TouchInput: di, MouseInput: ts, PointerEventInput: ns, TouchMouseInput: ko, SingleTouchInput: To, Recognizer: bn, AttrRecognizer: ye, Tap: ae, Pan: os, Swipe: pi, Pinch: Eo, Rotate: pe, Press: hi, on: Xi, off: Hn, each: pn, merge: Gi, extend: jn, assign: Pt, inherit: Tt, bindFn: oi, prefixed: mo }), (void 0 !== rt ? rt : "undefined" != typeof self ? self : {}).Hammer = Tn, (ge = function () { return Tn }.call(Ie, Ye, Ie, nt)) !== _e && (nt.exports = ge) }(window, document) } }, nt => { nt(nt.s = 997) }]);
  </script>
</body>

</html>
